//  Copyright 2020 Marius Ackerman
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

// Package slot generates Rust code for parser slots
package slot

import (
	"bytes"
	"fmt"
	"text/template"

	"github.com/bruceiv/pegll/ast"

	"github.com/bruceiv/pegll/frstflw"
	"github.com/bruceiv/pegll/gslot"
	"github.com/bruceiv/pegll/symbols"
	"github.com/goccmack/goutil/ioutil"
)

func Gen(slotFile string, g *ast.GoGLL, gs *gslot.GSlot, ff *frstflw.FF) {
	tmpl, err := template.New("Rust Slot").Parse(slotTmpl)
	if err != nil {
		panic(err)
	}
	buf, data := new(bytes.Buffer), getData(g, gs, ff)
	if err = tmpl.Execute(buf, data); err != nil {
		panic(err)
	}
	if err := ioutil.WriteFile(slotFile, buf.Bytes()); err != nil {
		panic(err)
	}
}

type Data struct {
	Package string
	Slots   []*SlotData
	Alts    []*AltData
}

type AltData struct {
	NT     string
	Labels []string
}

type SlotData struct {
	Label   string
	NT      string
	Alt     int
	Pos     int
	Symbols []string
	Comment string
}

func getData(g *ast.GoGLL, gs *gslot.GSlot, ff *frstflw.FF) *Data {
	return &Data{
		Package: g.Package.GetString(),
		Slots:   getSlotData(gs),
		Alts:    getAltData(g, gs, ff),
	}
}

func getAltData(g *ast.GoGLL, gs *gslot.GSlot, ff *frstflw.FF) (data []*AltData) {
	for _, r := range g.SyntaxRules {
		d := &AltData{r.Head.ID(), getLabelList(r, g, gs, ff)}
		data = append(data, d)
	}
	return
}

func getLabelList(rule *ast.SyntaxRule, g *ast.GoGLL, gs *gslot.GSlot, ff *frstflw.FF) (labels []string) {
	for i := range rule.Alternates {
		labels = append(labels,
			gslot.NewLabel(rule.Head.ID(), i, 0, gs, ff).Label())
	}
	return
}

func getSlotData(gs *gslot.GSlot) (data []*SlotData) {
	for _, s := range gs.Slots() {
		d := &SlotData{
			Label:   s.Label(),
			NT:      s.Head,
			Alt:     s.Alternate,
			Pos:     s.Pos,
			Symbols: getSymbols(s.Symbols()),
			Comment: s.String(),
		}
		data = append(data, d)
	}
	return
}

func getSymbols(syms symbols.Symbols) []string {
	ss := make([]string, len(syms))
	for i, sym := range syms {
		switch s := sym.(type) {
		case symbols.NT:
			ss[i] = fmt.Sprintf("NT(NT::%s)", s.Literal())
		case symbols.T:
			ss[i] = fmt.Sprintf("T(T::T%d)", s-symbols.StartOfTokens)
		default:
			panic("invalid")
		}
	}
	return ss
}

const slotTmpl = `//! Module slot is generated by gogll. Do not edit. 

extern crate lazy_static;

use lazy_static::lazy_static;

use super::symbols::{Symbol, NT, T};
use std::collections::HashMap;
use std::fmt;

#[derive(Hash, Eq, PartialEq, Clone, Copy, Debug)]
pub enum Label { {{range $i, $l := .Slots}}
    {{$l.Label}},{{end}}
}

#[allow(dead_code)]
pub struct Slot {
    nt:      NT,
    alt:     usize,
    pos:     usize,
    symbols: Vec<Symbol>,
    label: 	 Label,
}

#[derive(Hash, Eq, PartialEq)]
pub struct Index {
    pub nt:      NT,
    pub alt:     usize,
    pub pos:     usize,
}

#[allow(dead_code)]
pub fn get_alternates(nt: &NT) -> &'static Vec<Label> {
    if let Some(alts) = ALTERNATES.get(nt) {
        return alts
    }
    panic!("{} has no alternates", nt)
}

#[allow(dead_code)]
pub fn get_label(nt: &NT, alt: usize, pos: usize) -> Label {
    if let Some(l) = LABELS.get(&Index{nt: nt.clone(), alt: alt, pos: pos}) {
        return l.clone()
    }
    panic!("No label for {} alt {} pos {}", nt, alt, pos)
}

impl <'a>Label {
    #[allow(dead_code)]
    pub fn eor(&self) -> bool {
        self.slot().eor()
    }
    
    #[allow(dead_code)]
    pub fn head(&self) -> &'static NT {
        &self.slot().nt
    }
    
    pub fn index(&self) -> Index {
        let s = self.slot();
        Index{nt: s.nt, alt: s.alt, pos: s.pos}
    }
    
    #[allow(dead_code)]
    pub fn alternate(&self) -> usize {
        self.slot().alt
    }
    
    #[allow(dead_code)]
    pub fn pos(&self) -> usize {
        self.slot().pos
    }
    
    #[allow(dead_code)]
    pub fn slot(&self) -> &'static Slot {
        if let Some(s) = SLOTS.get(self) {
            return s
        }
        panic!("Invalid slot label {}", self)
    }

    #[allow(dead_code)]
    pub fn symbols(&self) -> &'a Vec<Symbol> {
        &self.slot().symbols
    }
}
/*** end of impl Label***/

impl fmt::Display for Label {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let slt = self.slot();
        let mut s = format!("{} :", slt.nt);
        for (i, sym) in slt.symbols.iter().enumerate() {
            if i == slt.pos {
                s.push_str("•")
            }
            s.push_str(&format!("{} ", sym));
        }
        write!(f, "{}", s)
    }
}

impl Slot {
    #[allow(dead_code)]
    pub fn eor(&self) -> bool {
        self.pos >= self.symbols.len()
    }    
} /*** impl Slot ***/


impl fmt::Display for Slot {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut s = format!("{} : ", self.nt);
        for (i, sym) in self.symbols.iter().enumerate() {
            if i == self.pos {
                s.push_str("•")
            }
            s.push_str(&format!("{} ", sym));
        }
        if self.pos >= self.symbols.len() {
            s.push_str("•")
        }
        write!(f, "{}", s)
    }
}

lazy_static! {
    static ref ALTERNATES: HashMap<NT, Vec<Label>> = {
        let mut m = HashMap::new(); {{range $a := .Alts}}
        m.insert(NT::{{$a.NT}}, 
            vec![ {{range $l := $a.Labels}}
                Label::{{$l}},{{end}}
            ]);{{end}}
        m
     };

    static ref LABELS: HashMap<Index, Label> = { 
        let mut m = HashMap::new(); {{range $i, $s := .Slots}}
        m.insert(Index{nt:NT::{{$s.NT}}, alt:{{$s.Alt}}, pos:{{$s.Pos}}}, Label::{{$s.Label}}); {{end}}
        m
    };

    static ref SLOTS: HashMap<Label, Slot> = {
        let mut m = HashMap::new(); {{range $i, $s := .Slots}}
        // {{$s.Comment}}
        m.insert(Label::{{$s.Label}}, 
            Slot{
                nt: NT::{{$s.NT}},
                alt: {{$s.Alt}},
                pos: {{$s.Pos}},
                symbols: vec![ {{range $sym := $s.Symbols}}
                    Symbol::{{$sym}}, {{end}}
                ],
                label: Label::{{$s.Label}},
            });{{end}}
        m
	};
}
`

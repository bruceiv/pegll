//  Copyright 2020 Marius Ackerman
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

// Package token generates the Rust token module
package token

import (
	"bytes"
	"text/template"

	"github.com/bruceiv/pegll/symbols"
	"github.com/goccmack/goutil/ioutil"
)

type Data struct {
	Types        []*TypeDef
	TypeToString []string
}

type TypeDef struct {
	Name, Comment string
	Suppress      bool
}

func Gen(fname string) {
	// fmt.Println(fname)
	tmpl, err := template.New("Rust token").Parse(tmplSrc)
	if err != nil {
		panic(err)
	}
	w := new(bytes.Buffer)
	if err := tmpl.Execute(w, getData()); err != nil {
		panic(err)
	}
	if err := ioutil.WriteFile(fname, w.Bytes()); err != nil {
		panic(err)
	}
}

func getData() *Data {
	return &Data{
		Types:        getTypes(),
		TypeToString: symbols.GetTerminalTypeStrings(),
	}
}

func getTypes() (types []*TypeDef) {
	for _, t := range symbols.GetTerminals() {
		types = append(types,
			&TypeDef{
				Name: t.TypeString(),

				Comment:  t.Literal(),
				Suppress: t.Suppress(),
			})
	}
	return
}

const tmplSrc = `
//! Module token is generated by GoGLL. Do not edit

extern crate lazy_static;

use std::rc::Rc;
use std::fmt;
use lazy_static::lazy_static;
use std::collections::HashMap;

/// Token is returned by the lexer for every scanned lexical token
pub struct Token {
	pub typ: Type,
	pub lext: usize, 
	pub rext: usize,
	
	input: Rc<Vec<char>>,
}

#[derive(PartialEq, Eq, Hash, Clone, Copy)]
pub enum Type {	{{range $t := .Types}}
	{{$t.Name}}, // "{{$t.Comment}}"{{end}}
}

/**
New returns a new token.  
lext is the left extent and rext the right extent of the token in the input.  
input is the input slice scanned by the lexer.
*/
pub fn new<'a>(t: Type, lext: usize, rext: usize, input: &Rc<Vec<char>>) -> Rc<Token> {
	Rc::new(Token{
		typ:   t,
		lext:  lext,
		rext:  rext,
		input: input.clone(),
	})
}

impl Token {
	/// get_line_column returns the (line, column) of the left extent of the token
	pub fn get_line_column(&self) -> (usize, usize) {
		let mut line = 1;
		let mut col = 1;
		let mut j = 0;
		while j < self.lext {
			match self.input[j] {
			'\n' => {
				line += 1;
				col = 1
			},
			'\t' => col += 4,
			_ => col += 1
			}
			j += 1
		}
		(line, col)
	}

	/// returns the id of the token
	#[allow(dead_code)]
	pub fn id(&self) -> &'static str {
		TYPE_TO_ID[&self.typ]
	}
	
	/// literal returns the literal runes of t scanned by the lexer
	pub fn literal(&self) -> Vec<char> {
		self.input[self.lext..self.rext].to_vec()
	}
	
    /// literal_string returns the literal string of t scanned by the lexer
    #[allow(dead_code)]
	pub fn literal_string(&self) -> String {
		self.literal().iter().collect::<String>()
	}
	
	/// returns true iff this token is suppressed by the lexer
	#[allow(dead_code)]
	pub fn suppress(&self) -> bool {
		SUPPRESS[&self.typ]
	}

} // impl Token

impl <'a>fmt::Display for Token {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		let (ln, col) = self.get_line_column();
		write!(f, "({}, ({},{}) {})", 
			self.typ, ln, col, self.literal().iter().collect::<String>())
	}

}

impl <'a>Type {
	/// id returns the token type ID of token Type t
	#[allow(dead_code)]
	pub fn id(&self) -> &'a str {
		TYPE_TO_ID[self]
	}
	
}

impl <'a>fmt::Display for Type {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		write!(f, "{}", TYPE_TO_ID[self])
	}

}

lazy_static! {
    static ref TYPE_TO_ID: HashMap<Type, &'static str> = {
        let mut m = HashMap::new(); {{range $t := .Types}}
		m.insert(Type::{{$t.Name}}, "{{$t.Comment}}");{{end}}
        m
    };
}

lazy_static! {
	static ref ID_TO_TYPE: HashMap<&'static str, Type> = {
		let mut m = HashMap::new(); {{range $t := .Types}}
		m.insert("{{$t.Comment}}", Type::{{$t.Name}}); {{end}}
		m
	};
}

lazy_static! {
	static ref STRING_TO_TYPE: HashMap<&'static str, Type> = {
		let mut m = HashMap::new(); {{range $typ := .TypeToString}}
		m.insert("{{$typ}}", Type::{{$typ}}); {{end}}
		m
	};
}

lazy_static! {
    static ref SUPPRESS: HashMap<Type, bool> = {
        let mut m = HashMap::new(); {{range $t := .Types}}
		m.insert(Type::{{$t.Name}}, {{$t.Suppress}});{{end}}
        m
    };
}
`

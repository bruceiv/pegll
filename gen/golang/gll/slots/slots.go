//  Copyright 2021 Aaron Moss
//  Copyright 2019 Marius Ackerman
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

// Package slots generates a Go parser slots package
package slots

import (
	"bytes"
	"text/template"

	"github.com/bruceiv/pegll/ast"
	"github.com/bruceiv/pegll/frstflw"
	"github.com/bruceiv/pegll/gslot"
	gsyms "github.com/bruceiv/pegll/symbols"
	"github.com/goccmack/goutil/ioutil"
)

func Gen(slotFile string, g *ast.GoGLL, gs *gslot.GSlot, ff *frstflw.FF) {
	tmpl, err := template.New("Slot").Parse(slotTmpl)
	if err != nil {
		panic(err)
	}
	buf, data := new(bytes.Buffer), getData(g, gs, ff)
	if err = tmpl.Execute(buf, data); err != nil {
		panic(err)
	}
	if err := ioutil.WriteFile(slotFile, buf.Bytes()); err != nil {
		panic(err)
	}
}

type Data struct {
	Package string
	Slots   []*SlotData
	Alts    []*AltData
}

type AltData struct {
	NT     string
	Labels string
}

type SlotData struct {
	Label    string
	NT       string
	Alt      int
	Pos      int
	Nullable bool
	Symbols  []string
	FirstT   []string
}

func getData(g *ast.GoGLL, gs *gslot.GSlot, ff *frstflw.FF) *Data {
	return &Data{
		Package: g.Package.GetString(),
		Slots:   getSlotData(gs, ff),
		Alts:    getAltData(g, gs, ff),
	}
}

func getAltData(g *ast.GoGLL, gs *gslot.GSlot, ff *frstflw.FF) (data []*AltData) {
	for _, r := range g.SyntaxRules {
		d := &AltData{r.Head.ID(), getLabelList(r, g, gs, ff)}
		data = append(data, d)
	}
	return
}

func getLabelList(rule *ast.SyntaxRule, g *ast.GoGLL, gs *gslot.GSlot, ff *frstflw.FF) string {
	buf := new(bytes.Buffer)
	for i := range rule.Alternates {
		if i > 0 {
			buf.WriteString(",")
		}
		buf.WriteString(gslot.NewLabel(rule.Head.ID(), i, 0, gs, ff).Label())
	}
	return buf.String()
}

func getSlotData(gs *gslot.GSlot, ff *frstflw.FF) (data []*SlotData) {
	for _, s := range gs.Slots() {
		d := &SlotData{
			Label:    s.Label(),
			NT:       s.Head,
			Alt:      s.Alternate,
			Pos:      s.Pos,
			Nullable: isNullable(s, ff),
			Symbols:  s.Symbols().GoStrings(),
			FirstT:   firstT(s, ff),
		}
		data = append(data, d)
	}
	return
}

// true if the remainder of the symbols in the sequence represented by this slot can
// match while consuming no input
func isNullable(s gslot.Label, ff *frstflw.FF) bool {
	syms := s.Symbols()
	for i := s.Pos; i < len(syms); i++ {
		if !ff.IsNullable(syms[i].String()) {
			return false
		}
	}
	return true
}

// gets FIRST set for a slot
func firstT(s gslot.Label, ff *frstflw.FF) []string {
	fsts := ff.FirstOfString(s.Symbols().Strings()[s.Pos:])
	fsts.Remove(frstflw.Empty)
	r := make([]string, 0, fsts.Len())
	for _, lit := range fsts.Elements() {
		t := gsyms.TerminalLiteralToType(lit)
		r = append(r, t.GoString())
	}
	return r
}

const slotTmpl = `
// Package slot is generated by gogll. Do not edit. 
package slot

import(
	"bytes"
	"fmt"
	
	"{{.Package}}/parser/symbols"
	"{{.Package}}/token"
)

type Label int

const({{range $i, $l := .Slots}}
	{{$l.Label}}{{if not $i}} Label = iota{{end}}{{end}}
)

type Slot struct {
	NT      symbols.NT
	Alt     int
	Pos     int
	Symbols symbols.Symbols
	Label 	Label
}

type Index struct {
	NT      symbols.NT
	Alt     int
	Pos     int
}

func GetAlternates(nt symbols.NT) []Label {
	alts, exist := alternates[nt]
	if !exist {
		panic(fmt.Sprintf("Invalid NT %s", nt))
	}
	return alts
}

func GetLabel(nt symbols.NT, alt, pos int) Label {
	l, exist := slotIndex[Index{nt,alt,pos}]
	if exist {
		return l
	}
	panic(fmt.Sprintf("Error: no slot label for NT=%s, alt=%d, pos=%d", nt, alt, pos))
}

func (l Label) EoR() bool {
	return l.Slot().EoR()
}

func (l Label) Head() symbols.NT {
	return l.Slot().NT
}

func (l Label) Index() Index {
	s := l.Slot()
	return Index{s.NT, s.Alt, s.Pos}
}

func (l Label) Alternate() int {
	return l.Slot().Alt
}

func (l Label) Pos() int {
	return l.Slot().Pos
}

func (l Label) Slot() *Slot {
	s, exist := slots[l]
	if !exist {
		panic(fmt.Sprintf("Invalid slot label %d", l))
	}
	return s
}

func (l Label) String() string {
	return l.Slot().String()
}

func (l Label) Symbols() symbols.Symbols {
	return l.Slot().Symbols
}

func (l Label) IsNullable() bool {
	return nullable[l]
}

func (l Label) FirstContains(typ token.Type) bool {
	return firstT[l][typ]
}

func (l Label) IsLookahead() bool {
	s := l.Slot()
	return s.Pos > 0 && s.Symbols[s.Pos-1].IsLookahead()
}

func (s *Slot) EoR() bool {
	return s.Pos >= len(s.Symbols)
}

func (s *Slot) Successor() *Slot {
	if s.EoR() {
		return nil
	} else {
		// TODO try slots[s.Label + 1]
		return slots[slotIndex[Index{s.NT,s.Alt,s.Pos+1}]]
	}
}

func (s *Slot) String() string {
	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, "%s : ", s.NT)
	for i, sym := range s.Symbols {
		if i == s.Pos {
			fmt.Fprintf(buf, "∙")
		}
		fmt.Fprintf(buf, "%s ", sym)
	}
	if s.Pos >= len(s.Symbols) {
		fmt.Fprintf(buf, "∙")
	}
	return buf.String()
}

var slots = map[Label]*Slot{ {{range $i, $s := .Slots}}
	{{$s.Label}}: {
		symbols.NT_{{$s.NT}}, {{$s.Alt}}, {{$s.Pos}}, 
		symbols.Symbols{ {{range $sym := $s.Symbols}} 
			symbols.{{$sym}},{{end}}
		}, 
		{{$s.Label}}, 
	},{{end}}
}

var slotIndex = map[Index]Label { {{range $i, $s := .Slots}}
	Index{ symbols.NT_{{$s.NT}},{{$s.Alt}},{{$s.Pos}} }: {{$s.Label}},{{end}}
}

var alternates = map[symbols.NT][]Label{ {{range $i, $a := .Alts}}
	symbols.NT_{{$a.NT}}:[]Label{ {{$a.Labels}} },{{end}}
}

var nullable = []bool { {{range $i, $s := .Slots}}
	{{$s.Nullable}}, // {{$s.Label}} {{end}}
}

var firstT = []map[token.Type]bool { {{range $i, $s := .Slots}}
	{ {{range $j, $t := $s.FirstT}} token.{{$t}}: true, {{end}} }, // {{$s.Label}} {{end}}
}
`

//  Copyright 2021 Aaron Moss
//  Copyright 2019 Marius Ackerman
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

// Package symbols generates a Go parser symbols package
package symbols

import (
	"bytes"
	"fmt"
	"text/template"

	"github.com/bruceiv/pegll/ast"
	"github.com/bruceiv/pegll/frstflw"
	"github.com/goccmack/goutil/ioutil"
)

type Data struct {
	NonTerminals []string
	Terminals    []string
	Lookaheads   []string
	SyntaxSuffs  []string
	LeftRec      map[string][]string
	Ordered      map[string]bool
	LookModes    []string
	LookSyms     []string
	SuffModes    []string
	SuffSyms     []string
}

func Gen(fname string, g *ast.GoGLL, ff *frstflw.FF) {
	tmpl, err := template.New("symbols").Parse(src)
	if err != nil {
		panic(err)
	}
	buf := new(bytes.Buffer)
	if err := tmpl.Execute(buf, getData(g, ff)); err != nil {
		panic(err)
	}
	if err := ioutil.WriteFile(fname, buf.Bytes()); err != nil {
		panic(err)
	}
}

func getData(g *ast.GoGLL, ff *frstflw.FF) *Data {
	// get slice of nonterminal strings
	nts := g.NonTerminals.ElementsSorted()
	// get slice of terminal strings
	ts := g.Terminals.ElementsSorted()
	// get slice of lookaheads
	lks := g.Lookaheads.ElementsSorted()
	// get slice of syntax rule operations
	suffs := g.SyntaxSuffs.ElementsSorted()

	lrs := make(map[string][]string)
	for _, nt := range nts {
		lrs[nt] = ff.LeftRec(nt).Elements()
	}

	nto := make(map[string]bool)
	for _, r := range g.SyntaxRules {
		if r.IsOrdered {
			nto[r.ID()] = true
		}
	}

	// reverse lookup for terminal identifiers
	tIds := make(map[string]string, len(ts))
	for i, t := range ts {
		tIds[t] = fmt.Sprint(i)
	}

	lkIdents := make([]string, len(lks))
	lkModes := make([]string, len(lks))
	lkSyms := make([]string, len(lks))
	for i, lk := range lks {
		lkSym := lk[1:]
		switch lk[0] {
		case '!':
			// negative
			if g.NonTerminals.Contain(lkSym) {
				lkIdents[i] = "LN_NT_" + lkSym
				lkModes[i] = "negNonterm"
				lkSyms[i] = "NT_" + lkSym
			} else {
				tSym := tIds[lkSym]
				lkIdents[i] = "LN_T_" + tSym
				lkModes[i] = "negTerm"
				lkSyms[i] = "T_" + tSym
			}
		case '&':
			// positive
			if g.NonTerminals.Contain(lkSym) {
				lkIdents[i] = "LP_NT_" + lkSym
				lkModes[i] = "posNonterm"
				lkSyms[i] = "NT_" + lkSym
			} else {
				tSym := tIds[lkSym]
				lkIdents[i] = "LP_T_" + tSym
				lkModes[i] = "posTerm"
				lkSyms[i] = "T_" + tSym
			}
		default:
			panic("invalid lookahead symbol " + lk)
		}
	}
	//////// ? isn't the first symbol it's the last
	// syntax suffix operators (only optional now)
	// TODO: add other operators
	suffIdents := make([]string, len(suffs))
	suffModes := make([]string, len(suffs))
	suffSyms := make([]string, len(suffs))
	for i, suff := range suffs {
		suffSym := suff[1:]
		switch suff[len(suffs)-1] {
		// optional operator
		case '?':
			// nonterminal
			if g.NonTerminals.Contain(suffSym) {
				suffIdents[i] = "OPT_" + suffSym
				suffModes[i] = "optNonterm"
				suffSyms[i] = "NT_" + suffSym

			}
		default:
			panic("invalid syntax suffix " + suff)
		}
	}

	return &Data{
		NonTerminals: nts,
		Terminals:    ts,
		Lookaheads:   lkIdents,
		SyntaxSuffs:  suffIdents,
		LeftRec:      lrs,
		Ordered:      nto,
		LookModes:    lkModes,
		LookSyms:     lkSyms,
		SuffModes:    suffModes,
		SuffSyms:     suffSyms,
	}
}

func (d Data) NumNTs() int {
	return len(d.NonTerminals)
}

const src = `
// Package symbols is generated by gogll. Do not edit.
package symbols

type Symbol interface{
	isSymbol()
	IsNonTerminal() bool
	IsLookahead() bool
	IsSyntaxSuff() bool
	String() string
}

func (NT) isSymbol() {}
func (T) isSymbol() {}
func (L) isSymbol() {}
func (S) isSymbol() {}

// NT is the type of non-terminals symbols
type NT int
const( {{range $i, $nt := .NonTerminals}}
	NT_{{$nt}} {{if not $i}}NT = iota{{end}}{{end}}
)

const NumNTs = {{.NumNTs}}

type NTs []NT

// T is the type of terminals symbols
type T int
const( {{range $i, $t := .Terminals}}
	T_{{$i}} {{if not $i}}T = iota{{end}} // {{$t}} {{end}}
)

// L is the type of lookahead symbols
type L int
const( {{range $i, $lk := .Lookaheads}}
	{{$lk}} {{if not $i}}L = iota{{end}}{{end}}
)

// S is the type of syntax suffix for syntax operators
type S int
const( {{range $i, $suff := .SyntaxSuffs}}
	{{$suff}} {{if not $i}}S = iota{{end}}{{end}}
)

// symbols slice
type Symbols []Symbol

// convert symbols to strings
func (ss Symbols) Strings() []string {
	strs := make([]string, len(ss))
	for i, s := range ss {
		strs[i] = s.String()
	}
	return strs
}

// functions to determine if nonterminal
func (NT) IsNonTerminal() bool {
	return true
}
func (T) IsNonTerminal() bool {
	return false
}
func (L) IsNonTerminal() bool {
	return false
}
func (S) IsNonTerminal() bool {
	return false
}

// functions to determine if lookahead
func (NT) IsLookahead() bool {
	return false
}
func (T) IsLookahead() bool {
	return false
}
func (L) IsLookahead() bool {
	return true
}
func (S) IsLookahead() bool {
	return false
}

// functions to determine if syntax suffix
func (NT) IsSyntaxSuff() bool {
	return false
}
func (T) IsSyntaxSuff() bool {
	return false
}
func (L) IsSyntaxSuff() bool {
	return false
}
func (S) IsSyntaxSuff() bool {
	return true
}

// convert NT to string
func (nt NT) String() string {
	return ntToString[nt]
}
// convert T to string
func (t T) String() string {
	return tToString[t]
}

// convert lookahead to string
func (lk L) String() string {
	if lk.IsNegative() {
		return "!" + lk.ArgSymbol().String()
	} else {
		return "&" + lk.ArgSymbol().String()
	}
}

// convert syntax suffix to string
func (lk L) String() string {
	return lk.ArgSymbol().String() + "?"
}

// list of NTs
func (nt NT) LeftRec() NTs {
	return leftRec[nt]
}

// determine if NT is ordered
func (nt NT) IsOrdered() bool {
	return ordered[nt]
}

// types of lookaheads
const(
	negTerm    = 0
	negNonterm = 1
	posTerm    = 2
	posNonterm = 3
	isNonterm  = 1
	isPos      = 2
)
// determine if lookahead negative or positive
func (lk L) IsNegative() bool {
	return lkMode[lk] & isPos == 0
}
func (lk L) IsPositive() bool {
	return lkMode[lk] & isPos != 0
}
// NT and T symbols from lookahead argument
func (lk L) ArgSymbol() Symbol {
	switch lkMode[lk] & isNonterm {
	case 0: // terminal
		return T(lkSym[lk])
	case 1: // nonterminal
		return NT(lkSym[lk])
	default:
		panic("Invalid lookahead")
	}
}

/* HOW DOES IT VERIFY THAT THIS IS AN OPTIONAL SYMBOL? */
// type of syntax suffix
const(
	isOpt	= 0
)
// determine if symbol is optional
func (suff S) IsOptional() bool {
	return suffMode[suff] & isOpt != 0
}

// NT symbols from syntax suffix argument
func (suff S) SynSuffSymbol() Symbol {
	 // nonterminal
		return NT(suffSym[suff])
	}
}

// NT string
var ntToString = []string { {{range $nt := .NonTerminals}}
	"{{$nt}}", /* NT_{{$nt}} */{{end}} 
}
// T string
var tToString = []string { {{range $i, $t := .Terminals}}
	"{{$t}}", /* T_{{$i}} */{{end}} 
}
// string of NT
var stringNT = map[string]NT{ {{range $i, $sym := .NonTerminals}}
	"{{$sym}}":NT_{{$sym}},{{end}}
}
// list of NTs
var leftRec = map[NT]NTs { {{range $sym, $lrs := .LeftRec}}
	NT_{{$sym}}: NTs { {{range $i, $l := $lrs}} NT_{{$l}}, {{end}} },{{end}}
}
// determine if NTs ordered
var ordered = map[NT]bool { {{range $sym, $ord := .Ordered}}
	NT_{{$sym}}:{{$ord}},{{end}}
}
// determine lookahead mode 
var lkMode = []int { {{range $i, $lkmd := .LookModes}}
	{{$lkmd}}, {{end}}
}
// determine lookahead symbols
var lkSym = []int { {{range $i, $sym := .LookSyms}}
	int({{$sym}}), {{end}}
}
// determine suffix mode 
var suffMode = []int { {{range $i, $suffmd := .SuffModes}}
	{{$suffmd}}, {{end}}
}
// determine suffix symbols
var suffSym = []int { {{range $i, $sym := .SuffSyms}}
	int({{$sym}}), {{end}}
}
`

//  Copyright 2021 Aaron Moss
//  Copyright 2019 Marius Ackerman
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

// Package symbols generates a Go parser symbols package
package symbols

import (
	"bytes"
	"fmt"
	"text/template"

	"github.com/bruceiv/pegll/ast"
	"github.com/bruceiv/pegll/frstflw"
	"github.com/goccmack/goutil/ioutil"
)

type Data struct {
	NonTerminals []string
	Terminals    []string
	Lookaheads   []string
	LeftRec      map[string][]string
	Ordered      map[string]bool
	LookModes    []string
	LookSyms     []string
}

func Gen(fname string, g *ast.GoGLL, ff *frstflw.FF) {
	tmpl, err := template.New("symbols").Parse(src)
	if err != nil {
		panic(err)
	}
	buf := new(bytes.Buffer)
	if err := tmpl.Execute(buf, getData(g, ff)); err != nil {
		panic(err)
	}
	if err := ioutil.WriteFile(fname, buf.Bytes()); err != nil {
		panic(err)
	}
}

func getData(g *ast.GoGLL, ff *frstflw.FF) *Data {
	nts := g.NonTerminals.ElementsSorted()
	ts := g.Terminals.ElementsSorted()
	lks := g.Lookaheads.ElementsSorted()

	lrs := make(map[string][]string)
	for _, nt := range nts {
		lrs[nt] = ff.LeftRec(nt).Elements()
	}

	nto := make(map[string]bool)
	for _, r := range g.SyntaxRules {
		if r.IsOrdered {
			nto[r.ID()] = true
		}
	}

	// reverse lookup for terminal identifiers
	tIds := make(map[string]string, len(ts))
	for i, t := range ts {
		tIds[t] = fmt.Sprint(i)
	}

	lkIdents := make([]string, len(lks))
	lkModes := make([]string, len(lks))
	lkSyms := make([]string, len(lks))
	for i, lk := range lks {
		lkSym := lk[1:]
		switch lk[0] {
		case '!':
			// negative
			if g.NonTerminals.Contain(lkSym) {
				lkIdents[i] = "LN_NT_" + lkSym
				lkModes[i] = "negNonterm"
				lkSyms[i] = "NT_" + lkSym
			} else {
				tSym := tIds[lkSym]
				lkIdents[i] = "LN_T_" + tSym
				lkModes[i] = "negTerm"
				lkSyms[i] = "T_" + tSym
			}
		case '&':
			// positive
			if g.NonTerminals.Contain(lkSym) {
				lkIdents[i] = "LP_NT_" + lkSym
				lkModes[i] = "posNonterm"
				lkSyms[i] = "NT_" + lkSym
			} else {
				tSym := tIds[lkSym]
				lkIdents[i] = "LP_T_" + tSym
				lkModes[i] = "posTerm"
				lkSyms[i] = "T_" + tSym
			}
		default:
			panic("invalid lookahead symbol " + lk)
		}
	}

	return &Data{
		NonTerminals: nts,
		Terminals:    ts,
		Lookaheads:   lkIdents,
		LeftRec:      lrs,
		Ordered:      nto,
		LookModes:    lkModes,
		LookSyms:     lkSyms,
	}
}

func (d Data) NumNTs() int {
	return len(d.NonTerminals)
}

const src = `
// Package symbols is generated by gogll. Do not edit.
package symbols

type Symbol interface{
	isSymbol()
	IsNonTerminal() bool
	IsLookahead() bool
	String() string
}

func (NT) isSymbol() {}
func (T) isSymbol() {}
func (L) isSymbol() {}

// NT is the type of non-terminals symbols
type NT int
const( {{range $i, $nt := .NonTerminals}}
	NT_{{$nt}} {{if not $i}}NT = iota{{end}}{{end}}
)

const NumNTs = {{.NumNTs}}

type NTs []NT

// T is the type of terminals symbols
type T int
const( {{range $i, $t := .Terminals}}
	T_{{$i}} {{if not $i}}T = iota{{end}} // {{$t}} {{end}}
)

// L is the type of lookahead symbols
type L int
const( {{range $i, $lk := .Lookaheads}}
	{{$lk}} {{if not $i}}L = iota{{end}}{{end}}
)

type Symbols []Symbol

func (ss Symbols) Strings() []string {
	strs := make([]string, len(ss))
	for i, s := range ss {
		strs[i] = s.String()
	}
	return strs
}

func (NT) IsNonTerminal() bool {
	return true
}

func (T) IsNonTerminal() bool {
	return false
}

func (L) IsNonTerminal() bool {
	return false
}

func (NT) IsLookahead() bool {
	return false
}

func (T) IsLookahead() bool {
	return false
}

func (L) IsLookahead() bool {
	return true
}

func (nt NT) String() string {
	return ntToString[nt]
}

func (t T) String() string {
	return tToString[t]
}

func (lk L) String() string {
	if lk.IsNegative() {
		return "!" + lk.ArgSymbol().String()
	} else {
		return "&" + lk.ArgSymbol().String()
	}
}

func (nt NT) LeftRec() NTs {
	return leftRec[nt]
}

func (nt NT) IsOrdered() bool {
	return ordered[nt]
}

const(
	negTerm    = 0
	negNonterm = 1
	posTerm    = 2
	posNonterm = 3
	isNonterm  = 1
	isPos      = 2
)

func (lk L) IsNegative() bool {
	return lkMode[lk] & isPos == 0
}

func (lk L) IsPositive() bool {
	return lkMode[lk] & isPos != 0
}

func (lk L) ArgSymbol() Symbol {
	switch lkMode[lk] & isNonterm {
	case 0: // terminal
		return T(lkSym[lk])
	case 1: // nonterminal
		return NT(lkSym[lk])
	default:
		panic("Invalid lookahead")
	}
}

var ntToString = []string { {{range $nt := .NonTerminals}}
	"{{$nt}}", /* NT_{{$nt}} */{{end}} 
}

var tToString = []string { {{range $i, $t := .Terminals}}
	"{{$t}}", /* T_{{$i}} */{{end}} 
}

var stringNT = map[string]NT{ {{range $i, $sym := .NonTerminals}}
	"{{$sym}}":NT_{{$sym}},{{end}}
}

var leftRec = map[NT]NTs { {{range $sym, $lrs := .LeftRec}}
	NT_{{$sym}}: NTs { {{range $i, $l := $lrs}} NT_{{$l}}, {{end}} },{{end}}
}

var ordered = map[NT]bool { {{range $sym, $ord := .Ordered}}
	NT_{{$sym}}:{{$ord}},{{end}}
}

var lkMode = []int { {{range $i, $lkmd := .LookModes}}
	{{$lkmd}}, {{end}}
}

var lkSym = []int { {{range $i, $sym := .LookSyms}}
	int({{$sym}}), {{end}}
}
`

\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphics}
\usepackage{listings}
\usepackage{url}

% Notational macros
\newcommand{\Rule}{\mathcal{R}}
\newcommand{\fail}{\mathsf{fail}}
\newcommand{\nl}{\mathord{!}}

% Consistent handling for Latin abbrevs.
\newcommand{\ie}{\textit{i.e.}\@}
\newcommand{\eg}{\textit{e.g.}\@}
\newcommand{\etc}{\textit{etc.}\@}
\newcommand{\etal}{\textit{et~al.}\@}

\title{Parsing Expression GLL}
\author{
    Moss, Aaron\\
    \texttt{mossa@up.edu}
    \and
    Harrington, Brynn\\
    \texttt{harringt23@up.edu}
    \and
    Hoppe, Emily\\
    \texttt{hoppe23@up.edu}
}

\begin{document}
\maketitle

\begin{abstract}
This paper presents an extension of the GLL parsing algorithm for context-free grammars which also supports parsing expression grammars with ordered choice and lookahead. 
The new PEGLL algorithm retains support for unordered choice, and thus parses a common superset of context-free grammars and parsing expression grammars. 
As part of this work, the authors have modified an existing GLL parser-generator to support parsing expression grammars, adding operators for common parsing expressions and modifying the lexer algorithm to better support ordered choice. 
Performance results of the generated parsers are compared to competing parser-generators.
\end{abstract}

\section{Introduction}
The inherently unambiguous nature of parsing expression grammars (PEGs) makes them an attractive choice for modelling structured text such as programming languages and computing data formats, but in practice the superior performance of parsers based on context-free grammars (CFGs) has led to CFGs being more-widely used, despite the difficulty of disambiguating them. 
This work is an initial effort toward a unified framework that provides the advantages of both grammar formalisms: it is an algorithm adopted from an efficient, general-purpose CFG parser that supports PEG semantics without discarding support for the unordered choice operator of CFGs in cases where that ambiguity may be desirable. 

More specifically, this paper presents a modification of the GLL parser-generator of Scott \& Johnstone\cite{SJ10,SJ16}. 
The key contribution is the \emph{FailCRF} data structure, which adds a failure path to Scott \& Johnstone's call-return forest; the addition of a failure path allows the lookahead and ordered choice operations of the PEG formalism to be supported.
The authors have extended Ackerman's GoGLL\cite{Ack19} parser-generator to implement this new algorithm, adding syntactic sugar for common PEG operators and modifying the lexer algorithm to allow the PEG parser to override the usual maximal-munch rule. 
This paper also presents benchmarking results from comparing our new \emph{PEGLL} parser-generator against existing algorithms.

\section{Parsing Expression Grammars}
The primary difference between parsing expression grammars and the more familiar context-free grammars is \emph{ordered choice}: PEGs, as a formalism of recursive-descent parsing, do not try subsequent alternatives of an alternation if an earlier alternative matches. 
The other significant difference between the PEG and CFG formalisms are the PEG \emph{lookahead} expressions, $\nl\alpha$ and $\&\alpha$, which match only if the subexpression $\alpha$ does not (resp. does) match, but consume no input regardless. 
These lookahead operators provide the infinite lookahead of the PEG formalism.
The other fundamental PEG operators act much like their CFG equivalents, and are described in Fig.~\ref{expr-fig} as functions over an input string $s$ drawn from some alphabet $\Sigma$ producing either a (matching) suffix of $s$ or the special value $\fail \not\in \Sigma^*$.
In summary, the \emph{string literal} $u$ matches and consumes the string $u$, the \emph{empty expression} $\varepsilon$ always matches without consuming anything, while the \emph{failure expression} $\varnothing$ never matches. 
A \emph{nonterminal} $A$ is replaced by the parsing expression $\Rule(A)$ it corresponds to.
The \emph{sequence} expression $\alpha\beta$ matches $\alpha$ followed by $\beta$, while the \emph{ordered choice} expression $\alpha/\beta$ only tries $\beta$ if $\alpha$ does not match. 
To differentiate CFG \emph{unordered choice}, it is represented in this paper as $\alpha|\beta$.

\begin{figure}
	\centering
	\begin{equation*}
	\begin{aligned}[c]
	u(s)            & = \begin{cases} v     & s = uv \\
	                                  \fail & \text{otherwise} \end{cases} \\
	\varepsilon(s)  & = s \\
	\varnothing(s)  & = \fail \\
	\nl\alpha(s)    & = \begin{cases} s     & \alpha(s) = \fail \\
	                                  \fail & \text{otherwise} \end{cases} \\
    \&\alpha(s)     & = \begin{cases} s     & \alpha(s) \neq \fail \\
                                      \fail & \text{otherwise} \end{cases}
	\end{aligned}
	~~~~
	\begin{aligned}[c]
	A(s)            & = (\Rule(A))(s) \\
	\alpha\beta(s)  & = \begin{cases} \beta(\alpha(s)) & \alpha(s) \neq \fail \\
	                                  \fail            & \text{otherwise} \end{cases} \\
	\alpha/\beta(s) & = \begin{cases} \alpha(s)  & \alpha(s) \neq \fail \\
	                                  \beta(s)   & \text{otherwise} \end{cases}
	\end{aligned}
	\end{equation*}
	\caption[Expression definitions]{Formal definitions of parsing expressions} \label{expr-fig}
\end{figure}

\section{GLL Parsing}
\emph{Generalized LL} (GLL) parsing, introduced by Scott \& Johnstone\cite{SJ10,SJvB19}, extends the power of LL parsing to all CFGs through use of a \emph{call-return forest} (CRF) to represent the recursive-descent call stack of the LL parsing algorithm. 
For efficiency, the CRF is implemented using the \emph{graph-structured stack} (GSS) data structure introduced by Tomita\cite{Tom85} for the GLR parsing algorithm. 
The gist of the GLL approach is that each CRF node represents a function call (equivalently, nonterminal invocation) in a recursive-descent parse, and includes an input position, a nonterminal to match, and a grammar slot to return to on completion. 
The graph structure of this stack comes from a dynamic de-duplication of CRF nodes which share a nonterminal and input position, changing a stack data structure into a directed acyclic graph (DAG). 
The GLL algorithm keeps a queue of CRF nodes which are pending parsing, and handles the nondeterminism of unordered choice by enqueuing a CRF node for each choice.

Scott \etal\cite{SJvB19} introduced \emph{binary subtree representation} (BSR) sets as an output format to represent nonterminal matches in GLL. 
The essential insight is that, while the traditional \emph{shared packed parse forest} (SPPF)\cite{Tom85} data structure representing possible parse trees requires significant complication in the parser algorithm to properly store and update edges between parse tree nodes, those edges can be efficiently reconstructed from an indexed set of edgeless parse-tree nodes (the BSR set) with minimal added information. 

A BSR element is a 4-tuple containing a \emph{grammar slot} $X ::= \alpha\theta\cdot\beta$, and three input indices $i$, $j$, and $k$, $i \leq j \leq k$. 
The BSR element represents a successful match of the nonterminal $X$ up to the end of $\theta$, the single terminal or nonterminal immediately before the dot of the grammar slot; $i$ is the input index where $X$ began to match, $j$ is the index where $\theta$ began to match, and $k$ is the index where $\theta$ finished matching. 
Note that if $\beta = \varepsilon$, the BSR node represents a complete match of $X$.
Parse trees can be straightforwardly reconstructed from BSR sets: a predecessor of a BSR element $(X ::= \alpha\theta\cdot\beta, i, j, k)$ is any element $(X ::= \alpha\cdot\theta\beta, i, \ell, j)$, while its child where $\theta$ is some nonterminal $A$ is any element $(A ::= \delta\cdot, j, m, k)$. Successor and parent elements can be defined analogously.

\section{Parsing Expression GLL}
The \emph{Parsing Expression GLL} (PEGLL) algorithm introduced in this paper uses similar data structures and abstractions as GLL for CFGs. 
The main loop is outlined in Figure~\ref{main-loop-algo}; it first initializes an empty queue $R$ of slot descriptors to parse and an empty set $T$ of BSR elements to report, queues the start rule of the grammar at input position 0 for parsing, parses each descriptor, and completes by returning whether or not the start rule matched at position 0. 
Note that (unlike CFGs), PEGs match prefixes of their input, so the start rule may only consume the input up to some index $k$; if this behavior is not desired, a match can be returned only if $k$ is the length of the input string.

\begin{figure}
\caption{PEGLL main loop} \label{main-loop-algo}
\begin{lstlisting}[language=C++,mathescape=true,escapeinside={@}{@}]
$R = \emptyset$; $T = \emptyset$;
ntAdd($S$, 0);
while $R \neq \emptyset$ {
    $(L, c_U, c_I) = R$.remove();
    $t = $tokens($c_I$); $t' = t$;
    while true {
        switch $L$ {
            $\langle$ @generate slot code for each rule $R$@ $\rangle$
        }
    nextSlot: }
}
if $\exists \alpha, j, k, (S ::= \alpha \cdot, 0, j, k) \in T$ {
    return match at maximal such $k$;
} else {
    return $\fail$;
}
\end{lstlisting}
\end{figure}

\bibliographystyle{ieeetr}
\bibliography{deriv_parsing}

\end{document}
// Package parser is generated by gogll. Do not edit.
package parser

import (
	"bytes"
	"fmt"
	"sort"
	"strings"

	"JSON/lexer"
	"JSON/parser/bsr"
	"JSON/parser/slot"
	"JSON/parser/symbols"
	"JSON/token"
)

type parser struct {
	cI int

	R *descriptors
	U *descriptors

	popped   map[poppedNode]bool
	crf_m    map[clusterNode][]*crfNode
	crf_f    map[clusterNode][]*crfNode
	crfNodes map[crfNode]*crfNode

	lex         *lexer.Lexer
	parseErrors []*Error

	bsrSet *bsr.Set
}

// index used for non-matches
const failInd = -1

func newParser(l *lexer.Lexer) *parser {
	return &parser{
		cI:     0,
		lex:    l,
		R:      &descriptors{},
		U:      &descriptors{},
		popped: make(map[poppedNode]bool),
		crf_m: map[clusterNode][]*crfNode{
			{symbols.NT_JSON, 0}: {},
		},
		crf_f:       map[clusterNode][]*crfNode{},
		crfNodes:    map[crfNode]*crfNode{},
		bsrSet:      bsr.New(symbols.NT_JSON, l),
		parseErrors: nil,
	}
}

// Parse returns the BSR set containing the parse forest.
// If the parse was successfull []*Error is nil
func Parse(l *lexer.Lexer) (*bsr.Set, []*Error) {
	return newParser(l).parse()
}

func (p *parser) parse() (*bsr.Set, []*Error) {
	var L slot.Label
	m, cU := len(p.lex.Tokens)-1, 0
	p.ntAdd(symbols.NT_JSON, 0)
	// p.DumpDescriptors()
	for !p.R.empty() {
		L, cU, p.cI = p.R.remove()

		// fmt.Println()
		// fmt.Printf("L:%s, cI:%d, I[p.cI]:%s, cU:%d\n", L, p.cI, p.lex.Tokens[p.cI], cU)
		// p.DumpDescriptors()

		for {
			switch L {
			case slot.Array0R0: // Array : ∙LBRACKET SuffElements RBRACKET

				if !p.testSelect(slot.Array0R0) {
					p.parseError(slot.Array0R0, p.cI, first[slot.Array0R0])
					L, p.cI = slot.Array1F0, cU
					goto nextSlot
				}
				p.call(slot.Array0R1, slot.Array1F0, symbols.NT_LBRACKET, cU, p.cI)
			case slot.Array0R1: // Array : LBRACKET ∙SuffElements RBRACKET

				if !p.testSelect(slot.Array0R1) {
					p.parseError(slot.Array0R1, p.cI, first[slot.Array0R1])
					L, p.cI = slot.Array1F0, cU
					goto nextSlot
				}
				p.call(slot.Array0R2, slot.Array1F0, symbols.NT_SuffElements, cU, p.cI)
			case slot.Array0R2: // Array : LBRACKET SuffElements ∙RBRACKET

				if !p.testSelect(slot.Array0R2) {
					p.parseError(slot.Array0R2, p.cI, first[slot.Array0R2])
					L, p.cI = slot.Array1F0, cU
					goto nextSlot
				}
				p.call(slot.Array0R3, slot.Array1F0, symbols.NT_RBRACKET, cU, p.cI)
			case slot.Array0R3: // Array : LBRACKET SuffElements RBRACKET ∙

				p.rtn(symbols.NT_Array, cU, p.cI)
			case slot.Array1F0: // Array failure case
				p.rtn(symbols.NT_Array, cU, failInd)
			case slot.CHAR0R0: // CHAR : ∙Suff1xchar Suffchar

				if !p.testSelect(slot.CHAR0R0) {
					p.parseError(slot.CHAR0R0, p.cI, first[slot.CHAR0R0])
					L, p.cI = slot.CHAR1R0, cU
					goto nextSlot
				}
				p.call(slot.CHAR0R1, slot.CHAR1R0, symbols.NT_Suff1xchar, cU, p.cI)
			case slot.CHAR0R1: // CHAR : Suff1xchar ∙Suffchar

				if !p.testSelect(slot.CHAR0R1) {
					p.parseError(slot.CHAR0R1, p.cI, first[slot.CHAR0R1])
					L, p.cI = slot.CHAR1R0, cU
					goto nextSlot
				}
				p.call(slot.CHAR0R2, slot.CHAR1R0, symbols.NT_Suffchar, cU, p.cI)
			case slot.CHAR0R2: // CHAR : Suff1xchar Suffchar ∙

				p.rtn(symbols.NT_CHAR, cU, p.cI)
			case slot.CHAR1R0: // CHAR : ∙bSlash CharCode

				if !p.testSelect(slot.CHAR1R0) {
					p.parseError(slot.CHAR1R0, p.cI, first[slot.CHAR1R0])
					L, p.cI = slot.CHAR2F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.CHAR1R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.CHAR1R1) {
					p.parseError(slot.CHAR1R1, p.cI, first[slot.CHAR1R1])
					L, p.cI = slot.CHAR2F0, cU
					goto nextSlot
				}
				p.call(slot.CHAR1R2, slot.CHAR2F0, symbols.NT_CharCode, cU, p.cI)
			case slot.CHAR1R2: // CHAR : bSlash CharCode ∙

				p.rtn(symbols.NT_CHAR, cU, p.cI)
			case slot.CHAR2F0: // CHAR failure case
				p.rtn(symbols.NT_CHAR, cU, failInd)
			case slot.COLON0R0: // COLON : ∙: WS

				if !p.testSelect(slot.COLON0R0) {
					p.parseError(slot.COLON0R0, p.cI, first[slot.COLON0R0])
					L, p.cI = slot.COLON1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.COLON0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.COLON0R1) {
					p.parseError(slot.COLON0R1, p.cI, first[slot.COLON0R1])
					L, p.cI = slot.COLON1F0, cU
					goto nextSlot
				}
				p.call(slot.COLON0R2, slot.COLON1F0, symbols.NT_WS, cU, p.cI)
			case slot.COLON0R2: // COLON : : WS ∙

				p.rtn(symbols.NT_COLON, cU, p.cI)
			case slot.COLON1F0: // COLON failure case
				p.rtn(symbols.NT_COLON, cU, failInd)
			case slot.COMMA0R0: // COMMA : ∙, WS

				if !p.testSelect(slot.COMMA0R0) {
					p.parseError(slot.COMMA0R0, p.cI, first[slot.COMMA0R0])
					L, p.cI = slot.COMMA1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.COMMA0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.COMMA0R1) {
					p.parseError(slot.COMMA0R1, p.cI, first[slot.COMMA0R1])
					L, p.cI = slot.COMMA1F0, cU
					goto nextSlot
				}
				p.call(slot.COMMA0R2, slot.COMMA1F0, symbols.NT_WS, cU, p.cI)
			case slot.COMMA0R2: // COMMA : , WS ∙

				p.rtn(symbols.NT_COMMA, cU, p.cI)
			case slot.COMMA1F0: // COMMA failure case
				p.rtn(symbols.NT_COMMA, cU, failInd)
			case slot.CharCode0R0: // CharCode : ∙esc

				if !p.testSelect(slot.CharCode0R0) {
					p.parseError(slot.CharCode0R0, p.cI, first[slot.CharCode0R0])
					L, p.cI = slot.CharCode1R0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.CharCode0R1, cU, p.cI, p.cI+1)
				p.cI++
				p.rtn(symbols.NT_CharCode, cU, p.cI)
			case slot.CharCode1R0: // CharCode : ∙u hex hex hex hex

				if !p.testSelect(slot.CharCode1R0) {
					p.parseError(slot.CharCode1R0, p.cI, first[slot.CharCode1R0])
					L, p.cI = slot.CharCode2F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.CharCode1R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.CharCode1R1) {
					p.parseError(slot.CharCode1R1, p.cI, first[slot.CharCode1R1])
					L, p.cI = slot.CharCode2F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.CharCode1R2, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.CharCode1R2) {
					p.parseError(slot.CharCode1R2, p.cI, first[slot.CharCode1R2])
					L, p.cI = slot.CharCode2F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.CharCode1R3, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.CharCode1R3) {
					p.parseError(slot.CharCode1R3, p.cI, first[slot.CharCode1R3])
					L, p.cI = slot.CharCode2F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.CharCode1R4, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.CharCode1R4) {
					p.parseError(slot.CharCode1R4, p.cI, first[slot.CharCode1R4])
					L, p.cI = slot.CharCode2F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.CharCode1R5, cU, p.cI, p.cI+1)
				p.cI++
				p.rtn(symbols.NT_CharCode, cU, p.cI)
			case slot.CharCode2F0: // CharCode failure case
				p.rtn(symbols.NT_CharCode, cU, failInd)
			case slot.ComPair0R0: // ComPair : ∙COMMA Pair

				if !p.testSelect(slot.ComPair0R0) {
					p.parseError(slot.ComPair0R0, p.cI, first[slot.ComPair0R0])
					L, p.cI = slot.ComPair1F0, cU
					goto nextSlot
				}
				p.call(slot.ComPair0R1, slot.ComPair1F0, symbols.NT_COMMA, cU, p.cI)
			case slot.ComPair0R1: // ComPair : COMMA ∙Pair

				if !p.testSelect(slot.ComPair0R1) {
					p.parseError(slot.ComPair0R1, p.cI, first[slot.ComPair0R1])
					L, p.cI = slot.ComPair1F0, cU
					goto nextSlot
				}
				p.call(slot.ComPair0R2, slot.ComPair1F0, symbols.NT_Pair, cU, p.cI)
			case slot.ComPair0R2: // ComPair : COMMA Pair ∙

				p.rtn(symbols.NT_ComPair, cU, p.cI)
			case slot.ComPair1F0: // ComPair failure case
				p.rtn(symbols.NT_ComPair, cU, failInd)
			case slot.ComVal0R0: // ComVal : ∙COMMA Value

				if !p.testSelect(slot.ComVal0R0) {
					p.parseError(slot.ComVal0R0, p.cI, first[slot.ComVal0R0])
					L, p.cI = slot.ComVal1F0, cU
					goto nextSlot
				}
				p.call(slot.ComVal0R1, slot.ComVal1F0, symbols.NT_COMMA, cU, p.cI)
			case slot.ComVal0R1: // ComVal : COMMA ∙Value

				if !p.testSelect(slot.ComVal0R1) {
					p.parseError(slot.ComVal0R1, p.cI, first[slot.ComVal0R1])
					L, p.cI = slot.ComVal1F0, cU
					goto nextSlot
				}
				p.call(slot.ComVal0R2, slot.ComVal1F0, symbols.NT_Value, cU, p.cI)
			case slot.ComVal0R2: // ComVal : COMMA Value ∙

				p.rtn(symbols.NT_ComVal, cU, p.cI)
			case slot.ComVal1F0: // ComVal failure case
				p.rtn(symbols.NT_ComVal, cU, failInd)
			case slot.EXP0R0: // EXP : ∙eE SuffPlusORMinus num

				if !p.testSelect(slot.EXP0R0) {
					p.parseError(slot.EXP0R0, p.cI, first[slot.EXP0R0])
					L, p.cI = slot.EXP1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.EXP0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.EXP0R1) {
					p.parseError(slot.EXP0R1, p.cI, first[slot.EXP0R1])
					L, p.cI = slot.EXP1F0, cU
					goto nextSlot
				}
				p.call(slot.EXP0R2, slot.EXP1F0, symbols.NT_SuffPlusORMinus, cU, p.cI)
			case slot.EXP0R2: // EXP : eE SuffPlusORMinus ∙num

				if !p.testSelect(slot.EXP0R2) {
					p.parseError(slot.EXP0R2, p.cI, first[slot.EXP0R2])
					L, p.cI = slot.EXP1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.EXP0R3, cU, p.cI, p.cI+1)
				p.cI++
				p.rtn(symbols.NT_EXP, cU, p.cI)
			case slot.EXP1F0: // EXP failure case
				p.rtn(symbols.NT_EXP, cU, failInd)
			case slot.Elements0R0: // Elements : ∙Value SuffComVal

				if !p.testSelect(slot.Elements0R0) {
					p.parseError(slot.Elements0R0, p.cI, first[slot.Elements0R0])
					L, p.cI = slot.Elements1F0, cU
					goto nextSlot
				}
				p.call(slot.Elements0R1, slot.Elements1F0, symbols.NT_Value, cU, p.cI)
			case slot.Elements0R1: // Elements : Value ∙SuffComVal

				if !p.testSelect(slot.Elements0R1) {
					p.parseError(slot.Elements0R1, p.cI, first[slot.Elements0R1])
					L, p.cI = slot.Elements1F0, cU
					goto nextSlot
				}
				p.call(slot.Elements0R2, slot.Elements1F0, symbols.NT_SuffComVal, cU, p.cI)
			case slot.Elements0R2: // Elements : Value SuffComVal ∙

				p.rtn(symbols.NT_Elements, cU, p.cI)
			case slot.Elements1F0: // Elements failure case
				p.rtn(symbols.NT_Elements, cU, failInd)
			case slot.EscOrComment0R0: // EscOrComment : ∙escCharSpace

				if !p.testSelect(slot.EscOrComment0R0) {
					p.parseError(slot.EscOrComment0R0, p.cI, first[slot.EscOrComment0R0])
					L, p.cI = slot.EscOrComment1R0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.EscOrComment0R1, cU, p.cI, p.cI+1)
				p.cI++
				p.rtn(symbols.NT_EscOrComment, cU, p.cI)
			case slot.EscOrComment1R0: // EscOrComment : ∙line_comment

				if !p.testSelect(slot.EscOrComment1R0) {
					p.parseError(slot.EscOrComment1R0, p.cI, first[slot.EscOrComment1R0])
					L, p.cI = slot.EscOrComment2R0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.EscOrComment1R1, cU, p.cI, p.cI+1)
				p.cI++
				p.rtn(symbols.NT_EscOrComment, cU, p.cI)
			case slot.EscOrComment2R0: // EscOrComment : ∙block_comment

				if !p.testSelect(slot.EscOrComment2R0) {
					p.parseError(slot.EscOrComment2R0, p.cI, first[slot.EscOrComment2R0])
					L, p.cI = slot.EscOrComment3R0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.EscOrComment2R1, cU, p.cI, p.cI+1)
				p.cI++
				p.rtn(symbols.NT_EscOrComment, cU, p.cI)
			case slot.EscOrComment3R0: // EscOrComment : ∙
				p.bsrSet.AddEmpty(slot.EscOrComment3R0, p.cI)
				p.rtn(symbols.NT_EscOrComment, cU, p.cI)
			case slot.FALSE0R0: // FALSE : ∙false WS

				if !p.testSelect(slot.FALSE0R0) {
					p.parseError(slot.FALSE0R0, p.cI, first[slot.FALSE0R0])
					L, p.cI = slot.FALSE1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.FALSE0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.FALSE0R1) {
					p.parseError(slot.FALSE0R1, p.cI, first[slot.FALSE0R1])
					L, p.cI = slot.FALSE1F0, cU
					goto nextSlot
				}
				p.call(slot.FALSE0R2, slot.FALSE1F0, symbols.NT_WS, cU, p.cI)
			case slot.FALSE0R2: // FALSE : false WS ∙

				p.rtn(symbols.NT_FALSE, cU, p.cI)
			case slot.FALSE1F0: // FALSE failure case
				p.rtn(symbols.NT_FALSE, cU, failInd)
			case slot.FRAC0R0: // FRAC : ∙. Suffnum

				if !p.testSelect(slot.FRAC0R0) {
					p.parseError(slot.FRAC0R0, p.cI, first[slot.FRAC0R0])
					L, p.cI = slot.FRAC1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.FRAC0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.FRAC0R1) {
					p.parseError(slot.FRAC0R1, p.cI, first[slot.FRAC0R1])
					L, p.cI = slot.FRAC1F0, cU
					goto nextSlot
				}
				p.call(slot.FRAC0R2, slot.FRAC1F0, symbols.NT_Suffnum, cU, p.cI)
			case slot.FRAC0R2: // FRAC : . Suffnum ∙

				p.rtn(symbols.NT_FRAC, cU, p.cI)
			case slot.FRAC1F0: // FRAC failure case
				p.rtn(symbols.NT_FRAC, cU, failInd)
			case slot.INT0R0: // INT : ∙SuffNeg Integers

				if !p.testSelect(slot.INT0R0) {
					p.parseError(slot.INT0R0, p.cI, first[slot.INT0R0])
					L, p.cI = slot.INT1F0, cU
					goto nextSlot
				}
				p.call(slot.INT0R1, slot.INT1F0, symbols.NT_SuffNeg, cU, p.cI)
			case slot.INT0R1: // INT : SuffNeg ∙Integers

				if !p.testSelect(slot.INT0R1) {
					p.parseError(slot.INT0R1, p.cI, first[slot.INT0R1])
					L, p.cI = slot.INT1F0, cU
					goto nextSlot
				}
				p.call(slot.INT0R2, slot.INT1F0, symbols.NT_Integers, cU, p.cI)
			case slot.INT0R2: // INT : SuffNeg Integers ∙

				p.rtn(symbols.NT_INT, cU, p.cI)
			case slot.INT1F0: // INT failure case
				p.rtn(symbols.NT_INT, cU, failInd)
			case slot.Integers0R0: // Integers : ∙NumSeq

				if !p.testSelect(slot.Integers0R0) {
					p.parseError(slot.Integers0R0, p.cI, first[slot.Integers0R0])
					L, p.cI = slot.Integers1R0, cU
					goto nextSlot
				}
				p.call(slot.Integers0R1, slot.Integers1R0, symbols.NT_NumSeq, cU, p.cI)
			case slot.Integers0R1: // Integers : NumSeq ∙

				p.rtn(symbols.NT_Integers, cU, p.cI)
			case slot.Integers1R0: // Integers : ∙0

				if !p.testSelect(slot.Integers1R0) {
					p.parseError(slot.Integers1R0, p.cI, first[slot.Integers1R0])
					L, p.cI = slot.Integers2F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.Integers1R1, cU, p.cI, p.cI+1)
				p.cI++
				p.rtn(symbols.NT_Integers, cU, p.cI)
			case slot.Integers2F0: // Integers failure case
				p.rtn(symbols.NT_Integers, cU, failInd)
			case slot.JSON0R0: // JSON : ∙WS Object

				if !p.testSelect(slot.JSON0R0) {
					p.parseError(slot.JSON0R0, p.cI, first[slot.JSON0R0])
					L, p.cI = slot.JSON1F0, cU
					goto nextSlot
				}
				p.call(slot.JSON0R1, slot.JSON1F0, symbols.NT_WS, cU, p.cI)
			case slot.JSON0R1: // JSON : WS ∙Object

				if !p.testSelect(slot.JSON0R1) {
					p.parseError(slot.JSON0R1, p.cI, first[slot.JSON0R1])
					L, p.cI = slot.JSON1F0, cU
					goto nextSlot
				}
				p.call(slot.JSON0R2, slot.JSON1F0, symbols.NT_Object, cU, p.cI)
			case slot.JSON0R2: // JSON : WS Object ∙

				p.rtn(symbols.NT_JSON, cU, p.cI)
			case slot.JSON1F0: // JSON failure case
				p.rtn(symbols.NT_JSON, cU, failInd)
			case slot.LBRACE0R0: // LBRACE : ∙{ WS

				if !p.testSelect(slot.LBRACE0R0) {
					p.parseError(slot.LBRACE0R0, p.cI, first[slot.LBRACE0R0])
					L, p.cI = slot.LBRACE1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.LBRACE0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.LBRACE0R1) {
					p.parseError(slot.LBRACE0R1, p.cI, first[slot.LBRACE0R1])
					L, p.cI = slot.LBRACE1F0, cU
					goto nextSlot
				}
				p.call(slot.LBRACE0R2, slot.LBRACE1F0, symbols.NT_WS, cU, p.cI)
			case slot.LBRACE0R2: // LBRACE : { WS ∙

				p.rtn(symbols.NT_LBRACE, cU, p.cI)
			case slot.LBRACE1F0: // LBRACE failure case
				p.rtn(symbols.NT_LBRACE, cU, failInd)
			case slot.LBRACKET0R0: // LBRACKET : ∙[ WS

				if !p.testSelect(slot.LBRACKET0R0) {
					p.parseError(slot.LBRACKET0R0, p.cI, first[slot.LBRACKET0R0])
					L, p.cI = slot.LBRACKET1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.LBRACKET0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.LBRACKET0R1) {
					p.parseError(slot.LBRACKET0R1, p.cI, first[slot.LBRACKET0R1])
					L, p.cI = slot.LBRACKET1F0, cU
					goto nextSlot
				}
				p.call(slot.LBRACKET0R2, slot.LBRACKET1F0, symbols.NT_WS, cU, p.cI)
			case slot.LBRACKET0R2: // LBRACKET : [ WS ∙

				p.rtn(symbols.NT_LBRACKET, cU, p.cI)
			case slot.LBRACKET1F0: // LBRACKET failure case
				p.rtn(symbols.NT_LBRACKET, cU, failInd)
			case slot.Members0R0: // Members : ∙Pair SuffComPair

				if !p.testSelect(slot.Members0R0) {
					p.parseError(slot.Members0R0, p.cI, first[slot.Members0R0])
					L, p.cI = slot.Members1F0, cU
					goto nextSlot
				}
				p.call(slot.Members0R1, slot.Members1F0, symbols.NT_Pair, cU, p.cI)
			case slot.Members0R1: // Members : Pair ∙SuffComPair

				if !p.testSelect(slot.Members0R1) {
					p.parseError(slot.Members0R1, p.cI, first[slot.Members0R1])
					L, p.cI = slot.Members1F0, cU
					goto nextSlot
				}
				p.call(slot.Members0R2, slot.Members1F0, symbols.NT_SuffComPair, cU, p.cI)
			case slot.Members0R2: // Members : Pair SuffComPair ∙

				p.rtn(symbols.NT_Members, cU, p.cI)
			case slot.Members1F0: // Members failure case
				p.rtn(symbols.NT_Members, cU, failInd)
			case slot.NUL0R0: // NUL : ∙null WS

				if !p.testSelect(slot.NUL0R0) {
					p.parseError(slot.NUL0R0, p.cI, first[slot.NUL0R0])
					L, p.cI = slot.NUL1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.NUL0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.NUL0R1) {
					p.parseError(slot.NUL0R1, p.cI, first[slot.NUL0R1])
					L, p.cI = slot.NUL1F0, cU
					goto nextSlot
				}
				p.call(slot.NUL0R2, slot.NUL1F0, symbols.NT_WS, cU, p.cI)
			case slot.NUL0R2: // NUL : null WS ∙

				p.rtn(symbols.NT_NUL, cU, p.cI)
			case slot.NUL1F0: // NUL failure case
				p.rtn(symbols.NT_NUL, cU, failInd)
			case slot.Neg0R0: // Neg : ∙-

				if !p.testSelect(slot.Neg0R0) {
					p.parseError(slot.Neg0R0, p.cI, first[slot.Neg0R0])
					L, p.cI = slot.Neg1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.Neg0R1, cU, p.cI, p.cI+1)
				p.cI++
				p.rtn(symbols.NT_Neg, cU, p.cI)
			case slot.Neg1F0: // Neg failure case
				p.rtn(symbols.NT_Neg, cU, failInd)
			case slot.NumSeq0R0: // NumSeq : ∙nonZero Suffnum

				if !p.testSelect(slot.NumSeq0R0) {
					p.parseError(slot.NumSeq0R0, p.cI, first[slot.NumSeq0R0])
					L, p.cI = slot.NumSeq1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.NumSeq0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.NumSeq0R1) {
					p.parseError(slot.NumSeq0R1, p.cI, first[slot.NumSeq0R1])
					L, p.cI = slot.NumSeq1F0, cU
					goto nextSlot
				}
				p.call(slot.NumSeq0R2, slot.NumSeq1F0, symbols.NT_Suffnum, cU, p.cI)
			case slot.NumSeq0R2: // NumSeq : nonZero Suffnum ∙

				p.rtn(symbols.NT_NumSeq, cU, p.cI)
			case slot.NumSeq1F0: // NumSeq failure case
				p.rtn(symbols.NT_NumSeq, cU, failInd)
			case slot.Number0R0: // Number : ∙INT SuffFRAC SuffEXP WS

				if !p.testSelect(slot.Number0R0) {
					p.parseError(slot.Number0R0, p.cI, first[slot.Number0R0])
					L, p.cI = slot.Number1F0, cU
					goto nextSlot
				}
				p.call(slot.Number0R1, slot.Number1F0, symbols.NT_INT, cU, p.cI)
			case slot.Number0R1: // Number : INT ∙SuffFRAC SuffEXP WS

				if !p.testSelect(slot.Number0R1) {
					p.parseError(slot.Number0R1, p.cI, first[slot.Number0R1])
					L, p.cI = slot.Number1F0, cU
					goto nextSlot
				}
				p.call(slot.Number0R2, slot.Number1F0, symbols.NT_SuffFRAC, cU, p.cI)
			case slot.Number0R2: // Number : INT SuffFRAC ∙SuffEXP WS

				if !p.testSelect(slot.Number0R2) {
					p.parseError(slot.Number0R2, p.cI, first[slot.Number0R2])
					L, p.cI = slot.Number1F0, cU
					goto nextSlot
				}
				p.call(slot.Number0R3, slot.Number1F0, symbols.NT_SuffEXP, cU, p.cI)
			case slot.Number0R3: // Number : INT SuffFRAC SuffEXP ∙WS

				if !p.testSelect(slot.Number0R3) {
					p.parseError(slot.Number0R3, p.cI, first[slot.Number0R3])
					L, p.cI = slot.Number1F0, cU
					goto nextSlot
				}
				p.call(slot.Number0R4, slot.Number1F0, symbols.NT_WS, cU, p.cI)
			case slot.Number0R4: // Number : INT SuffFRAC SuffEXP WS ∙

				p.rtn(symbols.NT_Number, cU, p.cI)
			case slot.Number1F0: // Number failure case
				p.rtn(symbols.NT_Number, cU, failInd)
			case slot.Object0R0: // Object : ∙LBRACE SuffMembers RBRACE

				if !p.testSelect(slot.Object0R0) {
					p.parseError(slot.Object0R0, p.cI, first[slot.Object0R0])
					L, p.cI = slot.Object1F0, cU
					goto nextSlot
				}
				p.call(slot.Object0R1, slot.Object1F0, symbols.NT_LBRACE, cU, p.cI)
			case slot.Object0R1: // Object : LBRACE ∙SuffMembers RBRACE

				if !p.testSelect(slot.Object0R1) {
					p.parseError(slot.Object0R1, p.cI, first[slot.Object0R1])
					L, p.cI = slot.Object1F0, cU
					goto nextSlot
				}
				p.call(slot.Object0R2, slot.Object1F0, symbols.NT_SuffMembers, cU, p.cI)
			case slot.Object0R2: // Object : LBRACE SuffMembers ∙RBRACE

				if !p.testSelect(slot.Object0R2) {
					p.parseError(slot.Object0R2, p.cI, first[slot.Object0R2])
					L, p.cI = slot.Object1F0, cU
					goto nextSlot
				}
				p.call(slot.Object0R3, slot.Object1F0, symbols.NT_RBRACE, cU, p.cI)
			case slot.Object0R3: // Object : LBRACE SuffMembers RBRACE ∙

				p.rtn(symbols.NT_Object, cU, p.cI)
			case slot.Object1F0: // Object failure case
				p.rtn(symbols.NT_Object, cU, failInd)
			case slot.Pair0R0: // Pair : ∙String COLON Value

				if !p.testSelect(slot.Pair0R0) {
					p.parseError(slot.Pair0R0, p.cI, first[slot.Pair0R0])
					L, p.cI = slot.Pair1F0, cU
					goto nextSlot
				}
				p.call(slot.Pair0R1, slot.Pair1F0, symbols.NT_String, cU, p.cI)
			case slot.Pair0R1: // Pair : String ∙COLON Value

				if !p.testSelect(slot.Pair0R1) {
					p.parseError(slot.Pair0R1, p.cI, first[slot.Pair0R1])
					L, p.cI = slot.Pair1F0, cU
					goto nextSlot
				}
				p.call(slot.Pair0R2, slot.Pair1F0, symbols.NT_COLON, cU, p.cI)
			case slot.Pair0R2: // Pair : String COLON ∙Value

				if !p.testSelect(slot.Pair0R2) {
					p.parseError(slot.Pair0R2, p.cI, first[slot.Pair0R2])
					L, p.cI = slot.Pair1F0, cU
					goto nextSlot
				}
				p.call(slot.Pair0R3, slot.Pair1F0, symbols.NT_Value, cU, p.cI)
			case slot.Pair0R3: // Pair : String COLON Value ∙

				p.rtn(symbols.NT_Pair, cU, p.cI)
			case slot.Pair1F0: // Pair failure case
				p.rtn(symbols.NT_Pair, cU, failInd)
			case slot.PlusORMinus0R0: // PlusORMinus : ∙+

				if !p.testSelect(slot.PlusORMinus0R0) {
					p.parseError(slot.PlusORMinus0R0, p.cI, first[slot.PlusORMinus0R0])
					L, p.cI = slot.PlusORMinus1R0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.PlusORMinus0R1, cU, p.cI, p.cI+1)
				p.cI++
				p.rtn(symbols.NT_PlusORMinus, cU, p.cI)
				L, p.cI = slot.PlusORMinus1M0, cU
				goto nextSlot

			case slot.PlusORMinus1R0: // PlusORMinus : ∙-

				if !p.testSelect(slot.PlusORMinus1R0) {
					p.parseError(slot.PlusORMinus1R0, p.cI, first[slot.PlusORMinus1R0])
					L, p.cI = slot.PlusORMinus2F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.PlusORMinus1R1, cU, p.cI, p.cI+1)
				p.cI++
				p.rtn(symbols.NT_PlusORMinus, cU, p.cI)

			case slot.PlusORMinus1M0: // PlusORMinus : ∙-  [with previous match]

				if !p.testSelect(slot.PlusORMinus1R0) {
					p.parseError(slot.PlusORMinus1R0, p.cI, first[slot.PlusORMinus1R0])

				}
				p.bsrSet.Add(slot.PlusORMinus1R1, cU, p.cI, p.cI+1)
				p.cI++
				p.rtn(symbols.NT_PlusORMinus, cU, p.cI)

			case slot.PlusORMinus2F0: // PlusORMinus failure case
				p.rtn(symbols.NT_PlusORMinus, cU, failInd)
			case slot.RBRACE0R0: // RBRACE : ∙} WS

				if !p.testSelect(slot.RBRACE0R0) {
					p.parseError(slot.RBRACE0R0, p.cI, first[slot.RBRACE0R0])
					L, p.cI = slot.RBRACE1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.RBRACE0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.RBRACE0R1) {
					p.parseError(slot.RBRACE0R1, p.cI, first[slot.RBRACE0R1])
					L, p.cI = slot.RBRACE1F0, cU
					goto nextSlot
				}
				p.call(slot.RBRACE0R2, slot.RBRACE1F0, symbols.NT_WS, cU, p.cI)
			case slot.RBRACE0R2: // RBRACE : } WS ∙

				p.rtn(symbols.NT_RBRACE, cU, p.cI)
			case slot.RBRACE1F0: // RBRACE failure case
				p.rtn(symbols.NT_RBRACE, cU, failInd)
			case slot.RBRACKET0R0: // RBRACKET : ∙] WS

				if !p.testSelect(slot.RBRACKET0R0) {
					p.parseError(slot.RBRACKET0R0, p.cI, first[slot.RBRACKET0R0])
					L, p.cI = slot.RBRACKET1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.RBRACKET0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.RBRACKET0R1) {
					p.parseError(slot.RBRACKET0R1, p.cI, first[slot.RBRACKET0R1])
					L, p.cI = slot.RBRACKET1F0, cU
					goto nextSlot
				}
				p.call(slot.RBRACKET0R2, slot.RBRACKET1F0, symbols.NT_WS, cU, p.cI)
			case slot.RBRACKET0R2: // RBRACKET : ] WS ∙

				p.rtn(symbols.NT_RBRACKET, cU, p.cI)
			case slot.RBRACKET1F0: // RBRACKET failure case
				p.rtn(symbols.NT_RBRACKET, cU, failInd)
			case slot.String0R0: // String : ∙dQuote SuffCHAR dQuote WS

				if !p.testSelect(slot.String0R0) {
					p.parseError(slot.String0R0, p.cI, first[slot.String0R0])
					L, p.cI = slot.String1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.String0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.String0R1) {
					p.parseError(slot.String0R1, p.cI, first[slot.String0R1])
					L, p.cI = slot.String1F0, cU
					goto nextSlot
				}
				p.call(slot.String0R2, slot.String1F0, symbols.NT_SuffCHAR, cU, p.cI)
			case slot.String0R2: // String : dQuote SuffCHAR ∙dQuote WS

				if !p.testSelect(slot.String0R2) {
					p.parseError(slot.String0R2, p.cI, first[slot.String0R2])
					L, p.cI = slot.String1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.String0R3, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.String0R3) {
					p.parseError(slot.String0R3, p.cI, first[slot.String0R3])
					L, p.cI = slot.String1F0, cU
					goto nextSlot
				}
				p.call(slot.String0R4, slot.String1F0, symbols.NT_WS, cU, p.cI)
			case slot.String0R4: // String : dQuote SuffCHAR dQuote WS ∙

				p.rtn(symbols.NT_String, cU, p.cI)
			case slot.String1F0: // String failure case
				p.rtn(symbols.NT_String, cU, failInd)
			case slot.Suff1xchar0R0: // Suff1xchar : ∙char Suffchar

				if !p.testSelect(slot.Suff1xchar0R0) {
					p.parseError(slot.Suff1xchar0R0, p.cI, first[slot.Suff1xchar0R0])
					L, p.cI = slot.Suff1xchar1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.Suff1xchar0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.Suff1xchar0R1) {
					p.parseError(slot.Suff1xchar0R1, p.cI, first[slot.Suff1xchar0R1])
					L, p.cI = slot.Suff1xchar1F0, cU
					goto nextSlot
				}
				p.call(slot.Suff1xchar0R2, slot.Suff1xchar1F0, symbols.NT_Suffchar, cU, p.cI)
			case slot.Suff1xchar0R2: // Suff1xchar : char Suffchar ∙

				p.rtn(symbols.NT_Suff1xchar, cU, p.cI)
			case slot.Suff1xchar1F0: // Suff1xchar failure case
				p.rtn(symbols.NT_Suff1xchar, cU, failInd)
			case slot.SuffCHAR0R0: // SuffCHAR : ∙CHAR SuffCHAR

				if !p.testSelect(slot.SuffCHAR0R0) {
					p.parseError(slot.SuffCHAR0R0, p.cI, first[slot.SuffCHAR0R0])
					L, p.cI = slot.SuffCHAR1R0, cU
					goto nextSlot
				}
				p.call(slot.SuffCHAR0R1, slot.SuffCHAR1R0, symbols.NT_CHAR, cU, p.cI)
			case slot.SuffCHAR0R1: // SuffCHAR : CHAR ∙SuffCHAR

				if !p.testSelect(slot.SuffCHAR0R1) {
					p.parseError(slot.SuffCHAR0R1, p.cI, first[slot.SuffCHAR0R1])
					L, p.cI = slot.SuffCHAR1R0, cU
					goto nextSlot
				}
				p.call(slot.SuffCHAR0R2, slot.SuffCHAR1R0, symbols.NT_SuffCHAR, cU, p.cI)
			case slot.SuffCHAR0R2: // SuffCHAR : CHAR SuffCHAR ∙

				p.rtn(symbols.NT_SuffCHAR, cU, p.cI)
			case slot.SuffCHAR1R0: // SuffCHAR : ∙
				p.bsrSet.AddEmpty(slot.SuffCHAR1R0, p.cI)
				p.rtn(symbols.NT_SuffCHAR, cU, p.cI)
			case slot.SuffComPair0R0: // SuffComPair : ∙ComPair SuffComPair

				if !p.testSelect(slot.SuffComPair0R0) {
					p.parseError(slot.SuffComPair0R0, p.cI, first[slot.SuffComPair0R0])
					L, p.cI = slot.SuffComPair1R0, cU
					goto nextSlot
				}
				p.call(slot.SuffComPair0R1, slot.SuffComPair1R0, symbols.NT_ComPair, cU, p.cI)
			case slot.SuffComPair0R1: // SuffComPair : ComPair ∙SuffComPair

				if !p.testSelect(slot.SuffComPair0R1) {
					p.parseError(slot.SuffComPair0R1, p.cI, first[slot.SuffComPair0R1])
					L, p.cI = slot.SuffComPair1R0, cU
					goto nextSlot
				}
				p.call(slot.SuffComPair0R2, slot.SuffComPair1R0, symbols.NT_SuffComPair, cU, p.cI)
			case slot.SuffComPair0R2: // SuffComPair : ComPair SuffComPair ∙

				p.rtn(symbols.NT_SuffComPair, cU, p.cI)
			case slot.SuffComPair1R0: // SuffComPair : ∙
				p.bsrSet.AddEmpty(slot.SuffComPair1R0, p.cI)
				p.rtn(symbols.NT_SuffComPair, cU, p.cI)
			case slot.SuffComVal0R0: // SuffComVal : ∙ComVal SuffComVal

				if !p.testSelect(slot.SuffComVal0R0) {
					p.parseError(slot.SuffComVal0R0, p.cI, first[slot.SuffComVal0R0])
					L, p.cI = slot.SuffComVal1R0, cU
					goto nextSlot
				}
				p.call(slot.SuffComVal0R1, slot.SuffComVal1R0, symbols.NT_ComVal, cU, p.cI)
			case slot.SuffComVal0R1: // SuffComVal : ComVal ∙SuffComVal

				if !p.testSelect(slot.SuffComVal0R1) {
					p.parseError(slot.SuffComVal0R1, p.cI, first[slot.SuffComVal0R1])
					L, p.cI = slot.SuffComVal1R0, cU
					goto nextSlot
				}
				p.call(slot.SuffComVal0R2, slot.SuffComVal1R0, symbols.NT_SuffComVal, cU, p.cI)
			case slot.SuffComVal0R2: // SuffComVal : ComVal SuffComVal ∙

				p.rtn(symbols.NT_SuffComVal, cU, p.cI)
			case slot.SuffComVal1R0: // SuffComVal : ∙
				p.bsrSet.AddEmpty(slot.SuffComVal1R0, p.cI)
				p.rtn(symbols.NT_SuffComVal, cU, p.cI)
			case slot.SuffEXP0R0: // SuffEXP : ∙EXP

				if !p.testSelect(slot.SuffEXP0R0) {
					p.parseError(slot.SuffEXP0R0, p.cI, first[slot.SuffEXP0R0])
					L, p.cI = slot.SuffEXP1R0, cU
					goto nextSlot
				}
				p.call(slot.SuffEXP0R1, slot.SuffEXP1R0, symbols.NT_EXP, cU, p.cI)
			case slot.SuffEXP0R1: // SuffEXP : EXP ∙

				p.rtn(symbols.NT_SuffEXP, cU, p.cI)
			case slot.SuffEXP1R0: // SuffEXP : ∙
				p.bsrSet.AddEmpty(slot.SuffEXP1R0, p.cI)
				p.rtn(symbols.NT_SuffEXP, cU, p.cI)
			case slot.SuffElements0R0: // SuffElements : ∙Elements

				if !p.testSelect(slot.SuffElements0R0) {
					p.parseError(slot.SuffElements0R0, p.cI, first[slot.SuffElements0R0])
					L, p.cI = slot.SuffElements1R0, cU
					goto nextSlot
				}
				p.call(slot.SuffElements0R1, slot.SuffElements1R0, symbols.NT_Elements, cU, p.cI)
			case slot.SuffElements0R1: // SuffElements : Elements ∙

				p.rtn(symbols.NT_SuffElements, cU, p.cI)
			case slot.SuffElements1R0: // SuffElements : ∙
				p.bsrSet.AddEmpty(slot.SuffElements1R0, p.cI)
				p.rtn(symbols.NT_SuffElements, cU, p.cI)
			case slot.SuffFRAC0R0: // SuffFRAC : ∙FRAC

				if !p.testSelect(slot.SuffFRAC0R0) {
					p.parseError(slot.SuffFRAC0R0, p.cI, first[slot.SuffFRAC0R0])
					L, p.cI = slot.SuffFRAC1R0, cU
					goto nextSlot
				}
				p.call(slot.SuffFRAC0R1, slot.SuffFRAC1R0, symbols.NT_FRAC, cU, p.cI)
			case slot.SuffFRAC0R1: // SuffFRAC : FRAC ∙

				p.rtn(symbols.NT_SuffFRAC, cU, p.cI)
			case slot.SuffFRAC1R0: // SuffFRAC : ∙
				p.bsrSet.AddEmpty(slot.SuffFRAC1R0, p.cI)
				p.rtn(symbols.NT_SuffFRAC, cU, p.cI)
			case slot.SuffMembers0R0: // SuffMembers : ∙Members

				if !p.testSelect(slot.SuffMembers0R0) {
					p.parseError(slot.SuffMembers0R0, p.cI, first[slot.SuffMembers0R0])
					L, p.cI = slot.SuffMembers1R0, cU
					goto nextSlot
				}
				p.call(slot.SuffMembers0R1, slot.SuffMembers1R0, symbols.NT_Members, cU, p.cI)
			case slot.SuffMembers0R1: // SuffMembers : Members ∙

				p.rtn(symbols.NT_SuffMembers, cU, p.cI)
			case slot.SuffMembers1R0: // SuffMembers : ∙
				p.bsrSet.AddEmpty(slot.SuffMembers1R0, p.cI)
				p.rtn(symbols.NT_SuffMembers, cU, p.cI)
			case slot.SuffNeg0R0: // SuffNeg : ∙Neg

				if !p.testSelect(slot.SuffNeg0R0) {
					p.parseError(slot.SuffNeg0R0, p.cI, first[slot.SuffNeg0R0])
					L, p.cI = slot.SuffNeg1R0, cU
					goto nextSlot
				}
				p.call(slot.SuffNeg0R1, slot.SuffNeg1R0, symbols.NT_Neg, cU, p.cI)
			case slot.SuffNeg0R1: // SuffNeg : Neg ∙

				p.rtn(symbols.NT_SuffNeg, cU, p.cI)
			case slot.SuffNeg1R0: // SuffNeg : ∙
				p.bsrSet.AddEmpty(slot.SuffNeg1R0, p.cI)
				p.rtn(symbols.NT_SuffNeg, cU, p.cI)
			case slot.SuffPlusORMinus0R0: // SuffPlusORMinus : ∙PlusORMinus

				if !p.testSelect(slot.SuffPlusORMinus0R0) {
					p.parseError(slot.SuffPlusORMinus0R0, p.cI, first[slot.SuffPlusORMinus0R0])
					L, p.cI = slot.SuffPlusORMinus1R0, cU
					goto nextSlot
				}
				p.call(slot.SuffPlusORMinus0R1, slot.SuffPlusORMinus1R0, symbols.NT_PlusORMinus, cU, p.cI)
			case slot.SuffPlusORMinus0R1: // SuffPlusORMinus : PlusORMinus ∙

				p.rtn(symbols.NT_SuffPlusORMinus, cU, p.cI)
			case slot.SuffPlusORMinus1R0: // SuffPlusORMinus : ∙
				p.bsrSet.AddEmpty(slot.SuffPlusORMinus1R0, p.cI)
				p.rtn(symbols.NT_SuffPlusORMinus, cU, p.cI)
			case slot.Suffchar0R0: // Suffchar : ∙char Suffchar

				if !p.testSelect(slot.Suffchar0R0) {
					p.parseError(slot.Suffchar0R0, p.cI, first[slot.Suffchar0R0])
					L, p.cI = slot.Suffchar1R0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.Suffchar0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.Suffchar0R1) {
					p.parseError(slot.Suffchar0R1, p.cI, first[slot.Suffchar0R1])
					L, p.cI = slot.Suffchar1R0, cU
					goto nextSlot
				}
				p.call(slot.Suffchar0R2, slot.Suffchar1R0, symbols.NT_Suffchar, cU, p.cI)
			case slot.Suffchar0R2: // Suffchar : char Suffchar ∙

				p.rtn(symbols.NT_Suffchar, cU, p.cI)
			case slot.Suffchar1R0: // Suffchar : ∙
				p.bsrSet.AddEmpty(slot.Suffchar1R0, p.cI)
				p.rtn(symbols.NT_Suffchar, cU, p.cI)
			case slot.Suffnum0R0: // Suffnum : ∙num Suffnum

				if !p.testSelect(slot.Suffnum0R0) {
					p.parseError(slot.Suffnum0R0, p.cI, first[slot.Suffnum0R0])
					L, p.cI = slot.Suffnum1R0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.Suffnum0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.Suffnum0R1) {
					p.parseError(slot.Suffnum0R1, p.cI, first[slot.Suffnum0R1])
					L, p.cI = slot.Suffnum1R0, cU
					goto nextSlot
				}
				p.call(slot.Suffnum0R2, slot.Suffnum1R0, symbols.NT_Suffnum, cU, p.cI)
			case slot.Suffnum0R2: // Suffnum : num Suffnum ∙

				p.rtn(symbols.NT_Suffnum, cU, p.cI)
			case slot.Suffnum1R0: // Suffnum : ∙
				p.bsrSet.AddEmpty(slot.Suffnum1R0, p.cI)
				p.rtn(symbols.NT_Suffnum, cU, p.cI)
			case slot.TRUE0R0: // TRUE : ∙true WS

				if !p.testSelect(slot.TRUE0R0) {
					p.parseError(slot.TRUE0R0, p.cI, first[slot.TRUE0R0])
					L, p.cI = slot.TRUE1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.TRUE0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.TRUE0R1) {
					p.parseError(slot.TRUE0R1, p.cI, first[slot.TRUE0R1])
					L, p.cI = slot.TRUE1F0, cU
					goto nextSlot
				}
				p.call(slot.TRUE0R2, slot.TRUE1F0, symbols.NT_WS, cU, p.cI)
			case slot.TRUE0R2: // TRUE : true WS ∙

				p.rtn(symbols.NT_TRUE, cU, p.cI)
			case slot.TRUE1F0: // TRUE failure case
				p.rtn(symbols.NT_TRUE, cU, failInd)
			case slot.Value0R0: // Value : ∙String

				if !p.testSelect(slot.Value0R0) {
					p.parseError(slot.Value0R0, p.cI, first[slot.Value0R0])
					L, p.cI = slot.Value1R0, cU
					goto nextSlot
				}
				p.call(slot.Value0R1, slot.Value1R0, symbols.NT_String, cU, p.cI)
			case slot.Value0R1: // Value : String ∙

				p.rtn(symbols.NT_Value, cU, p.cI)
			case slot.Value1R0: // Value : ∙Number

				if !p.testSelect(slot.Value1R0) {
					p.parseError(slot.Value1R0, p.cI, first[slot.Value1R0])
					L, p.cI = slot.Value2R0, cU
					goto nextSlot
				}
				p.call(slot.Value1R1, slot.Value2R0, symbols.NT_Number, cU, p.cI)
			case slot.Value1R1: // Value : Number ∙

				p.rtn(symbols.NT_Value, cU, p.cI)
			case slot.Value2R0: // Value : ∙Object

				if !p.testSelect(slot.Value2R0) {
					p.parseError(slot.Value2R0, p.cI, first[slot.Value2R0])
					L, p.cI = slot.Value3R0, cU
					goto nextSlot
				}
				p.call(slot.Value2R1, slot.Value3R0, symbols.NT_Object, cU, p.cI)
			case slot.Value2R1: // Value : Object ∙

				p.rtn(symbols.NT_Value, cU, p.cI)
			case slot.Value3R0: // Value : ∙Array

				if !p.testSelect(slot.Value3R0) {
					p.parseError(slot.Value3R0, p.cI, first[slot.Value3R0])
					L, p.cI = slot.Value4R0, cU
					goto nextSlot
				}
				p.call(slot.Value3R1, slot.Value4R0, symbols.NT_Array, cU, p.cI)
			case slot.Value3R1: // Value : Array ∙

				p.rtn(symbols.NT_Value, cU, p.cI)
			case slot.Value4R0: // Value : ∙TRUE

				if !p.testSelect(slot.Value4R0) {
					p.parseError(slot.Value4R0, p.cI, first[slot.Value4R0])
					L, p.cI = slot.Value5R0, cU
					goto nextSlot
				}
				p.call(slot.Value4R1, slot.Value5R0, symbols.NT_TRUE, cU, p.cI)
			case slot.Value4R1: // Value : TRUE ∙

				p.rtn(symbols.NT_Value, cU, p.cI)
			case slot.Value5R0: // Value : ∙FALSE

				if !p.testSelect(slot.Value5R0) {
					p.parseError(slot.Value5R0, p.cI, first[slot.Value5R0])
					L, p.cI = slot.Value6R0, cU
					goto nextSlot
				}
				p.call(slot.Value5R1, slot.Value6R0, symbols.NT_FALSE, cU, p.cI)
			case slot.Value5R1: // Value : FALSE ∙

				p.rtn(symbols.NT_Value, cU, p.cI)
			case slot.Value6R0: // Value : ∙NUL

				if !p.testSelect(slot.Value6R0) {
					p.parseError(slot.Value6R0, p.cI, first[slot.Value6R0])
					L, p.cI = slot.Value7F0, cU
					goto nextSlot
				}
				p.call(slot.Value6R1, slot.Value7F0, symbols.NT_NUL, cU, p.cI)
			case slot.Value6R1: // Value : NUL ∙

				p.rtn(symbols.NT_Value, cU, p.cI)
			case slot.Value7F0: // Value failure case
				p.rtn(symbols.NT_Value, cU, failInd)
			case slot.WS0R0: // WS : ∙EscOrComment WS

				if !p.testSelect(slot.WS0R0) {
					p.parseError(slot.WS0R0, p.cI, first[slot.WS0R0])
					L, p.cI = slot.WS1R0, cU
					goto nextSlot
				}
				p.call(slot.WS0R1, slot.WS1R0, symbols.NT_EscOrComment, cU, p.cI)
			case slot.WS0R1: // WS : EscOrComment ∙WS

				if !p.testSelect(slot.WS0R1) {
					p.parseError(slot.WS0R1, p.cI, first[slot.WS0R1])
					L, p.cI = slot.WS1R0, cU
					goto nextSlot
				}
				p.call(slot.WS0R2, slot.WS1R0, symbols.NT_WS, cU, p.cI)
			case slot.WS0R2: // WS : EscOrComment WS ∙

				p.rtn(symbols.NT_WS, cU, p.cI)
			case slot.WS1R0: // WS : ∙
				p.bsrSet.AddEmpty(slot.WS1R0, p.cI)
				p.rtn(symbols.NT_WS, cU, p.cI)

			default:
				panic("This must not happen")
			}
			// if exit switch normally, also exit loop and proceed to next
			// descriptor; if exit with goto nextSlot, repeat switch at next
			// slot
			break
		nextSlot:
		}
	}
	if !p.bsrSet.Contain(symbols.NT_JSON, 0, m) {
		p.sortParseErrors()
		return nil, p.parseErrors
	}
	return p.bsrSet, nil
}

func (p *parser) ntAdd(nt symbols.NT, j int) {
	l := slot.GetAlternates(nt)[0]
	p.dscAdd(l, j, j)
}

/*** Call Return Forest ***/

type poppedNode struct {
	X    symbols.NT
	k, j int
}

type clusterNode struct {
	X symbols.NT
	k int
}

type crfNode struct {
	L slot.Label
	i int
}

func (p *parser) call(Lm, Lf slot.Label, X symbols.NT, i, j int) {
	// fmt.Printf("p.call(%s,%d,%d)\n", L,i,j)
	um, exist := p.crfNodes[crfNode{Lm, i}]
	// fmt.Printf("  u exist=%t\n", exist)
	if !exist {
		um = &crfNode{Lm, i}
		p.crfNodes[*um] = um
	}
	uf, exist := p.crfNodes[crfNode{Lf, i}]
	if !exist {
		uf = &crfNode{Lf, i}
		p.crfNodes[*uf] = uf
	}

	ndV := clusterNode{X, j}
	vm, existm := p.crf_m[ndV]
	vf, existf := p.crf_f[ndV]
	if !existm && !existf {
		// fmt.Println("  v !exist")
		p.crf_m[ndV] = []*crfNode{um}
		p.crf_f[ndV] = []*crfNode{uf}
		p.ntAdd(X, j)
	} else {
		// fmt.Println("  v exist")
		if !existEdge(vm, um) {
			// fmt.Printf("  !existEdge(%v)\n", u)
			p.crf_m[ndV] = append(vm, um)
			// fmt.Printf("|popped|=%d\n", len(popped))
			for pnd := range p.popped {
				if pnd.X == X && pnd.k == j && pnd.j != failInd {
					p.addMatch(Lm, i, j, pnd.j)
				}
			}
		}
		if !existEdge(vf, uf) {
			p.crf_f[ndV] = append(vf, uf)
			for pnd := range p.popped {
				if pnd.X == X && pnd.k == j && pnd.j == failInd {
					p.addFail(Lf, i, j)
				}
			}
		}
	}
}

func existEdge(nds []*crfNode, nd *crfNode) bool {
	for _, nd1 := range nds {
		if nd1 == nd {
			return true
		}
	}
	return false
}

func (p *parser) rtn(X symbols.NT, k, j int) {
	// fmt.Printf("p.rtn(%s,%d,%d)\n", X,k,j)
	pn := poppedNode{X, k, j}
	if _, exist := p.popped[pn]; !exist {
		p.popped[pn] = true
		if j != failInd {
			for _, nd := range p.crf_m[clusterNode{X, k}] {
				p.addMatch(nd.L, nd.i, k, j)
			}
		} else {
			for _, nd := range p.crf_f[clusterNode{X, k}] {
				p.addFail(nd.L, nd.i, k)
			}
		}
	}
}

func (p *parser) addMatch(L slot.Label, i, k, j int) {
	p.bsrSet.Add(L, i, k, j)
	if L.IsLookahead() {
		p.dscAdd(L, i, k)
	} else {
		p.dscAdd(L, i, j)
	}
}

func (p *parser) addFail(L slot.Label, i, k int) {
	if L.IsLookahead() {
		p.dscAdd(L, i, k)
	} else {
		p.dscAdd(L, i, i)
	}
}

// func CRFString() string {
// 	buf := new(bytes.Buffer)
// 	buf.WriteString("CRF: {")
// 	for cn, nds := range crf{
// 		for _, nd := range nds {
// 			fmt.Fprintf(buf, "%s->%s, ", cn, nd)
// 		}
// 	}
// 	buf.WriteString("}")
// 	return buf.String()
// }

func (cn clusterNode) String() string {
	return fmt.Sprintf("(%s,%d)", cn.X, cn.k)
}

func (n crfNode) String() string {
	return fmt.Sprintf("(%s,%d)", n.L.String(), n.i)
}

// func PoppedString() string {
// 	buf := new(bytes.Buffer)
// 	buf.WriteString("Popped: {")
// 	for p, _ := range popped {
// 		fmt.Fprintf(buf, "(%s,%d,%d) ", p.X, p.k, p.j)
// 	}
// 	buf.WriteString("}")
// 	return buf.String()
// }

/*** descriptors ***/

type descriptors struct {
	set []*descriptor
}

func (ds *descriptors) contain(d *descriptor) bool {
	for _, d1 := range ds.set {
		if d1 == d {
			return true
		}
	}
	return false
}

func (ds *descriptors) empty() bool {
	return len(ds.set) == 0
}

func (ds *descriptors) String() string {
	buf := new(bytes.Buffer)
	buf.WriteString("{")
	for i, d := range ds.set {
		if i > 0 {
			buf.WriteString("; ")
		}
		fmt.Fprintf(buf, "%s", d)
	}
	buf.WriteString("}")
	return buf.String()
}

type descriptor struct {
	L slot.Label
	k int
	i int
}

func (d *descriptor) String() string {
	return fmt.Sprintf("%s,%d,%d", d.L, d.k, d.i)
}

func (p *parser) dscAdd(L slot.Label, k, i int) {
	// fmt.Printf("p.dscAdd(%s,%d,%d)\n", L, k, i)
	d := &descriptor{L, k, i}
	if !p.U.contain(d) {
		p.R.set = append(p.R.set, d)
		p.U.set = append(p.U.set, d)
	}
}

func (ds *descriptors) remove() (L slot.Label, k, i int) {
	d := ds.set[len(ds.set)-1]
	ds.set = ds.set[:len(ds.set)-1]
	// fmt.Printf("remove: %s,%d,%d\n", d.L, d.k, d.i)
	return d.L, d.k, d.i
}

func (p *parser) DumpDescriptors() {
	p.DumpR()
	p.DumpU()
}

func (p *parser) DumpR() {
	fmt.Println("R:")
	for _, d := range p.R.set {
		fmt.Printf(" %s\n", d)
	}
}

func (p *parser) DumpU() {
	fmt.Println("U:")
	for _, d := range p.U.set {
		fmt.Printf(" %s\n", d)
	}
}

/*** TestSelect ***/

func (p *parser) follow(nt symbols.NT) bool {
	_, exist := followSets[nt][p.lex.Tokens[p.cI].Type()]
	return exist
}

func (p *parser) testSelect(l slot.Label) bool {
	return l.IsNullable() || l.FirstContains(p.lex.Tokens[p.cI].Type())
	// _, exist := first[l][p.lex.Tokens[p.cI].Type()]
	// return exist
}

var first = []map[token.Type]string{
	// Array : ∙LBRACKET SuffElements RBRACKET
	{
		token.T_6: "[",
	},
	// Array : LBRACKET ∙SuffElements RBRACKET
	{
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_6:  "[",
		token.T_7:  "]",
		token.T_11: "dQuote",
		token.T_15: "false",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
	},
	// Array : LBRACKET SuffElements ∙RBRACKET
	{
		token.T_7: "]",
	},
	// Array : LBRACKET SuffElements RBRACKET ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// Array : ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// CHAR : ∙Suff1xchar Suffchar
	{
		token.T_10: "char",
	},
	// CHAR : Suff1xchar ∙Suffchar
	{
		token.T_8:  "bSlash",
		token.T_10: "char",
		token.T_11: "dQuote",
	},
	// CHAR : Suff1xchar Suffchar ∙
	{
		token.T_8:  "bSlash",
		token.T_10: "char",
		token.T_11: "dQuote",
	},
	// CHAR : ∙bSlash CharCode
	{
		token.T_8: "bSlash",
	},
	// CHAR : bSlash ∙CharCode
	{
		token.T_13: "esc",
		token.T_22: "u",
	},
	// CHAR : bSlash CharCode ∙
	{
		token.T_8:  "bSlash",
		token.T_10: "char",
		token.T_11: "dQuote",
	},
	// CHAR : ∙
	{
		token.T_8:  "bSlash",
		token.T_10: "char",
		token.T_11: "dQuote",
	},
	// COLON : ∙: WS
	{
		token.T_5: ":",
	},
	// COLON : : ∙WS
	{
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_6:  "[",
		token.T_9:  "block_comment",
		token.T_11: "dQuote",
		token.T_14: "escCharSpace",
		token.T_15: "false",
		token.T_17: "line_comment",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
	},
	// COLON : : WS ∙
	{
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_6:  "[",
		token.T_11: "dQuote",
		token.T_15: "false",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
	},
	// COLON : ∙
	{
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_6:  "[",
		token.T_11: "dQuote",
		token.T_15: "false",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
	},
	// COMMA : ∙, WS
	{
		token.T_1: ",",
	},
	// COMMA : , ∙WS
	{
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_6:  "[",
		token.T_9:  "block_comment",
		token.T_11: "dQuote",
		token.T_14: "escCharSpace",
		token.T_15: "false",
		token.T_17: "line_comment",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
	},
	// COMMA : , WS ∙
	{
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_6:  "[",
		token.T_11: "dQuote",
		token.T_15: "false",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
	},
	// COMMA : ∙
	{
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_6:  "[",
		token.T_11: "dQuote",
		token.T_15: "false",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
	},
	// CharCode : ∙esc
	{
		token.T_13: "esc",
	},
	// CharCode : esc ∙
	{
		token.T_8:  "bSlash",
		token.T_10: "char",
		token.T_11: "dQuote",
	},
	// CharCode : ∙u hex hex hex hex
	{
		token.T_22: "u",
	},
	// CharCode : u ∙hex hex hex hex
	{
		token.T_16: "hex",
	},
	// CharCode : u hex ∙hex hex hex
	{
		token.T_16: "hex",
	},
	// CharCode : u hex hex ∙hex hex
	{
		token.T_16: "hex",
	},
	// CharCode : u hex hex hex ∙hex
	{
		token.T_16: "hex",
	},
	// CharCode : u hex hex hex hex ∙
	{
		token.T_8:  "bSlash",
		token.T_10: "char",
		token.T_11: "dQuote",
	},
	// CharCode : ∙
	{
		token.T_8:  "bSlash",
		token.T_10: "char",
		token.T_11: "dQuote",
	},
	// ComPair : ∙COMMA Pair
	{
		token.T_1: ",",
	},
	// ComPair : COMMA ∙Pair
	{
		token.T_11: "dQuote",
	},
	// ComPair : COMMA Pair ∙
	{
		token.T_1:  ",",
		token.T_24: "}",
	},
	// ComPair : ∙
	{
		token.T_1:  ",",
		token.T_24: "}",
	},
	// ComVal : ∙COMMA Value
	{
		token.T_1: ",",
	},
	// ComVal : COMMA ∙Value
	{
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_6:  "[",
		token.T_11: "dQuote",
		token.T_15: "false",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
	},
	// ComVal : COMMA Value ∙
	{
		token.T_1: ",",
		token.T_7: "]",
	},
	// ComVal : ∙
	{
		token.T_1: ",",
		token.T_7: "]",
	},
	// EXP : ∙eE SuffPlusORMinus num
	{
		token.T_12: "eE",
	},
	// EXP : eE ∙SuffPlusORMinus num
	{
		token.T_0:  "+",
		token.T_2:  "-",
		token.T_20: "num",
	},
	// EXP : eE SuffPlusORMinus ∙num
	{
		token.T_20: "num",
	},
	// EXP : eE SuffPlusORMinus num ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// EXP : ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// Elements : ∙Value SuffComVal
	{
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_6:  "[",
		token.T_11: "dQuote",
		token.T_15: "false",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
	},
	// Elements : Value ∙SuffComVal
	{
		token.T_1: ",",
		token.T_7: "]",
	},
	// Elements : Value SuffComVal ∙
	{
		token.T_7: "]",
	},
	// Elements : ∙
	{
		token.T_7: "]",
	},
	// EscOrComment : ∙escCharSpace
	{
		token.T_14: "escCharSpace",
	},
	// EscOrComment : escCharSpace ∙
	{
		token.EOF:  "$",
		token.T_1:  ",",
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_5:  ":",
		token.T_6:  "[",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_11: "dQuote",
		token.T_14: "escCharSpace",
		token.T_15: "false",
		token.T_17: "line_comment",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
		token.T_24: "}",
	},
	// EscOrComment : ∙line_comment
	{
		token.T_17: "line_comment",
	},
	// EscOrComment : line_comment ∙
	{
		token.EOF:  "$",
		token.T_1:  ",",
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_5:  ":",
		token.T_6:  "[",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_11: "dQuote",
		token.T_14: "escCharSpace",
		token.T_15: "false",
		token.T_17: "line_comment",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
		token.T_24: "}",
	},
	// EscOrComment : ∙block_comment
	{
		token.T_9: "block_comment",
	},
	// EscOrComment : block_comment ∙
	{
		token.EOF:  "$",
		token.T_1:  ",",
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_5:  ":",
		token.T_6:  "[",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_11: "dQuote",
		token.T_14: "escCharSpace",
		token.T_15: "false",
		token.T_17: "line_comment",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
		token.T_24: "}",
	},
	// EscOrComment : ∙
	{
		token.EOF:  "$",
		token.T_1:  ",",
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_5:  ":",
		token.T_6:  "[",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_11: "dQuote",
		token.T_14: "escCharSpace",
		token.T_15: "false",
		token.T_17: "line_comment",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
		token.T_24: "}",
	},
	// FALSE : ∙false WS
	{
		token.T_15: "false",
	},
	// FALSE : false ∙WS
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// FALSE : false WS ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// FALSE : ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// FRAC : ∙. Suffnum
	{
		token.T_3: ".",
	},
	// FRAC : . ∙Suffnum
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_20: "num",
		token.T_24: "}",
	},
	// FRAC : . Suffnum ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// FRAC : ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// INT : ∙SuffNeg Integers
	{
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_18: "nonZero",
	},
	// INT : SuffNeg ∙Integers
	{
		token.T_4:  "0",
		token.T_18: "nonZero",
	},
	// INT : SuffNeg Integers ∙
	{
		token.T_1:  ",",
		token.T_3:  ".",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// INT : ∙
	{
		token.T_1:  ",",
		token.T_3:  ".",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// Integers : ∙NumSeq
	{
		token.T_18: "nonZero",
	},
	// Integers : NumSeq ∙
	{
		token.T_1:  ",",
		token.T_3:  ".",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// Integers : ∙0
	{
		token.T_4: "0",
	},
	// Integers : 0 ∙
	{
		token.T_1:  ",",
		token.T_3:  ".",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// Integers : ∙
	{
		token.T_1:  ",",
		token.T_3:  ".",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// JSON : ∙WS Object
	{
		token.T_9:  "block_comment",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_23: "{",
	},
	// JSON : WS ∙Object
	{
		token.T_23: "{",
	},
	// JSON : WS Object ∙
	{
		token.EOF: "$",
	},
	// JSON : ∙
	{
		token.EOF: "$",
	},
	// LBRACE : ∙{ WS
	{
		token.T_23: "{",
	},
	// LBRACE : { ∙WS
	{
		token.T_9:  "block_comment",
		token.T_11: "dQuote",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// LBRACE : { WS ∙
	{
		token.T_11: "dQuote",
		token.T_24: "}",
	},
	// LBRACE : ∙
	{
		token.T_11: "dQuote",
		token.T_24: "}",
	},
	// LBRACKET : ∙[ WS
	{
		token.T_6: "[",
	},
	// LBRACKET : [ ∙WS
	{
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_6:  "[",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_11: "dQuote",
		token.T_14: "escCharSpace",
		token.T_15: "false",
		token.T_17: "line_comment",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
	},
	// LBRACKET : [ WS ∙
	{
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_6:  "[",
		token.T_7:  "]",
		token.T_11: "dQuote",
		token.T_15: "false",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
	},
	// LBRACKET : ∙
	{
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_6:  "[",
		token.T_7:  "]",
		token.T_11: "dQuote",
		token.T_15: "false",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
	},
	// Members : ∙Pair SuffComPair
	{
		token.T_11: "dQuote",
	},
	// Members : Pair ∙SuffComPair
	{
		token.T_1:  ",",
		token.T_24: "}",
	},
	// Members : Pair SuffComPair ∙
	{
		token.T_24: "}",
	},
	// Members : ∙
	{
		token.T_24: "}",
	},
	// NUL : ∙null WS
	{
		token.T_19: "null",
	},
	// NUL : null ∙WS
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// NUL : null WS ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// NUL : ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// Neg : ∙-
	{
		token.T_2: "-",
	},
	// Neg : - ∙
	{
		token.T_4:  "0",
		token.T_18: "nonZero",
	},
	// Neg : ∙
	{
		token.T_4:  "0",
		token.T_18: "nonZero",
	},
	// NumSeq : ∙nonZero Suffnum
	{
		token.T_18: "nonZero",
	},
	// NumSeq : nonZero ∙Suffnum
	{
		token.T_1:  ",",
		token.T_3:  ".",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_20: "num",
		token.T_24: "}",
	},
	// NumSeq : nonZero Suffnum ∙
	{
		token.T_1:  ",",
		token.T_3:  ".",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// NumSeq : ∙
	{
		token.T_1:  ",",
		token.T_3:  ".",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// Number : ∙INT SuffFRAC SuffEXP WS
	{
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_18: "nonZero",
	},
	// Number : INT ∙SuffFRAC SuffEXP WS
	{
		token.T_1:  ",",
		token.T_3:  ".",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// Number : INT SuffFRAC ∙SuffEXP WS
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// Number : INT SuffFRAC SuffEXP ∙WS
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// Number : INT SuffFRAC SuffEXP WS ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// Number : ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// Object : ∙LBRACE SuffMembers RBRACE
	{
		token.T_23: "{",
	},
	// Object : LBRACE ∙SuffMembers RBRACE
	{
		token.T_11: "dQuote",
		token.T_24: "}",
	},
	// Object : LBRACE SuffMembers ∙RBRACE
	{
		token.T_24: "}",
	},
	// Object : LBRACE SuffMembers RBRACE ∙
	{
		token.EOF:  "$",
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// Object : ∙
	{
		token.EOF:  "$",
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// Pair : ∙String COLON Value
	{
		token.T_11: "dQuote",
	},
	// Pair : String ∙COLON Value
	{
		token.T_5: ":",
	},
	// Pair : String COLON ∙Value
	{
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_6:  "[",
		token.T_11: "dQuote",
		token.T_15: "false",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
	},
	// Pair : String COLON Value ∙
	{
		token.T_1:  ",",
		token.T_24: "}",
	},
	// Pair : ∙
	{
		token.T_1:  ",",
		token.T_24: "}",
	},
	// PlusORMinus : ∙+
	{
		token.T_0: "+",
	},
	// PlusORMinus : + ∙
	{
		token.T_20: "num",
	},
	// PlusORMinus : ∙-
	{
		token.T_2: "-",
	},
	// PlusORMinus : ∙-
	{
		token.T_2: "-",
	},
	// PlusORMinus : - ∙
	{
		token.T_20: "num",
	},
	// PlusORMinus : ∙
	{
		token.T_20: "num",
	},
	// RBRACE : ∙} WS
	{
		token.T_24: "}",
	},
	// RBRACE : } ∙WS
	{
		token.EOF:  "$",
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// RBRACE : } WS ∙
	{
		token.EOF:  "$",
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// RBRACE : ∙
	{
		token.EOF:  "$",
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// RBRACKET : ∙] WS
	{
		token.T_7: "]",
	},
	// RBRACKET : ] ∙WS
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// RBRACKET : ] WS ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// RBRACKET : ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// String : ∙dQuote SuffCHAR dQuote WS
	{
		token.T_11: "dQuote",
	},
	// String : dQuote ∙SuffCHAR dQuote WS
	{
		token.T_8:  "bSlash",
		token.T_10: "char",
		token.T_11: "dQuote",
	},
	// String : dQuote SuffCHAR ∙dQuote WS
	{
		token.T_11: "dQuote",
	},
	// String : dQuote SuffCHAR dQuote ∙WS
	{
		token.T_1:  ",",
		token.T_5:  ":",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// String : dQuote SuffCHAR dQuote WS ∙
	{
		token.T_1:  ",",
		token.T_5:  ":",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// String : ∙
	{
		token.T_1:  ",",
		token.T_5:  ":",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// Suff1xchar : ∙char Suffchar
	{
		token.T_10: "char",
	},
	// Suff1xchar : char ∙Suffchar
	{
		token.T_8:  "bSlash",
		token.T_10: "char",
		token.T_11: "dQuote",
	},
	// Suff1xchar : char Suffchar ∙
	{
		token.T_8:  "bSlash",
		token.T_10: "char",
		token.T_11: "dQuote",
	},
	// Suff1xchar : ∙
	{
		token.T_8:  "bSlash",
		token.T_10: "char",
		token.T_11: "dQuote",
	},
	// SuffCHAR : ∙CHAR SuffCHAR
	{
		token.T_8:  "bSlash",
		token.T_10: "char",
	},
	// SuffCHAR : CHAR ∙SuffCHAR
	{
		token.T_8:  "bSlash",
		token.T_10: "char",
		token.T_11: "dQuote",
	},
	// SuffCHAR : CHAR SuffCHAR ∙
	{
		token.T_11: "dQuote",
	},
	// SuffCHAR : ∙
	{
		token.T_11: "dQuote",
	},
	// SuffComPair : ∙ComPair SuffComPair
	{
		token.T_1: ",",
	},
	// SuffComPair : ComPair ∙SuffComPair
	{
		token.T_1:  ",",
		token.T_24: "}",
	},
	// SuffComPair : ComPair SuffComPair ∙
	{
		token.T_24: "}",
	},
	// SuffComPair : ∙
	{
		token.T_24: "}",
	},
	// SuffComVal : ∙ComVal SuffComVal
	{
		token.T_1: ",",
	},
	// SuffComVal : ComVal ∙SuffComVal
	{
		token.T_1: ",",
		token.T_7: "]",
	},
	// SuffComVal : ComVal SuffComVal ∙
	{
		token.T_7: "]",
	},
	// SuffComVal : ∙
	{
		token.T_7: "]",
	},
	// SuffEXP : ∙EXP
	{
		token.T_12: "eE",
	},
	// SuffEXP : EXP ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// SuffEXP : ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// SuffElements : ∙Elements
	{
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_6:  "[",
		token.T_11: "dQuote",
		token.T_15: "false",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
	},
	// SuffElements : Elements ∙
	{
		token.T_7: "]",
	},
	// SuffElements : ∙
	{
		token.T_7: "]",
	},
	// SuffFRAC : ∙FRAC
	{
		token.T_3: ".",
	},
	// SuffFRAC : FRAC ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// SuffFRAC : ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// SuffMembers : ∙Members
	{
		token.T_11: "dQuote",
	},
	// SuffMembers : Members ∙
	{
		token.T_24: "}",
	},
	// SuffMembers : ∙
	{
		token.T_24: "}",
	},
	// SuffNeg : ∙Neg
	{
		token.T_2: "-",
	},
	// SuffNeg : Neg ∙
	{
		token.T_4:  "0",
		token.T_18: "nonZero",
	},
	// SuffNeg : ∙
	{
		token.T_4:  "0",
		token.T_18: "nonZero",
	},
	// SuffPlusORMinus : ∙PlusORMinus
	{
		token.T_0: "+",
		token.T_2: "-",
	},
	// SuffPlusORMinus : PlusORMinus ∙
	{
		token.T_20: "num",
	},
	// SuffPlusORMinus : ∙
	{
		token.T_20: "num",
	},
	// Suffchar : ∙char Suffchar
	{
		token.T_10: "char",
	},
	// Suffchar : char ∙Suffchar
	{
		token.T_8:  "bSlash",
		token.T_10: "char",
		token.T_11: "dQuote",
	},
	// Suffchar : char Suffchar ∙
	{
		token.T_8:  "bSlash",
		token.T_10: "char",
		token.T_11: "dQuote",
	},
	// Suffchar : ∙
	{
		token.T_8:  "bSlash",
		token.T_10: "char",
		token.T_11: "dQuote",
	},
	// Suffnum : ∙num Suffnum
	{
		token.T_20: "num",
	},
	// Suffnum : num ∙Suffnum
	{
		token.T_1:  ",",
		token.T_3:  ".",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_20: "num",
		token.T_24: "}",
	},
	// Suffnum : num Suffnum ∙
	{
		token.T_1:  ",",
		token.T_3:  ".",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// Suffnum : ∙
	{
		token.T_1:  ",",
		token.T_3:  ".",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// TRUE : ∙true WS
	{
		token.T_21: "true",
	},
	// TRUE : true ∙WS
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// TRUE : true WS ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// TRUE : ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// Value : ∙String
	{
		token.T_11: "dQuote",
	},
	// Value : String ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// Value : ∙Number
	{
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_18: "nonZero",
	},
	// Value : Number ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// Value : ∙Object
	{
		token.T_23: "{",
	},
	// Value : Object ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// Value : ∙Array
	{
		token.T_6: "[",
	},
	// Value : Array ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// Value : ∙TRUE
	{
		token.T_21: "true",
	},
	// Value : TRUE ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// Value : ∙FALSE
	{
		token.T_15: "false",
	},
	// Value : FALSE ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// Value : ∙NUL
	{
		token.T_19: "null",
	},
	// Value : NUL ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// Value : ∙
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// WS : ∙EscOrComment WS
	{
		token.EOF:  "$",
		token.T_1:  ",",
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_5:  ":",
		token.T_6:  "[",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_11: "dQuote",
		token.T_14: "escCharSpace",
		token.T_15: "false",
		token.T_17: "line_comment",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
		token.T_24: "}",
	},
	// WS : EscOrComment ∙WS
	{
		token.EOF:  "$",
		token.T_1:  ",",
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_5:  ":",
		token.T_6:  "[",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_11: "dQuote",
		token.T_14: "escCharSpace",
		token.T_15: "false",
		token.T_17: "line_comment",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
		token.T_24: "}",
	},
	// WS : EscOrComment WS ∙
	{
		token.EOF:  "$",
		token.T_1:  ",",
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_5:  ":",
		token.T_6:  "[",
		token.T_7:  "]",
		token.T_11: "dQuote",
		token.T_15: "false",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
		token.T_24: "}",
	},
	// WS : ∙
	{
		token.EOF:  "$",
		token.T_1:  ",",
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_5:  ":",
		token.T_6:  "[",
		token.T_7:  "]",
		token.T_11: "dQuote",
		token.T_15: "false",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
		token.T_24: "}",
	},
}

var followSets = []map[token.Type]string{
	// Array
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// CHAR
	{
		token.T_8:  "bSlash",
		token.T_10: "char",
		token.T_11: "dQuote",
	},
	// COLON
	{
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_6:  "[",
		token.T_11: "dQuote",
		token.T_15: "false",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
	},
	// COMMA
	{
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_6:  "[",
		token.T_11: "dQuote",
		token.T_15: "false",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
	},
	// CharCode
	{
		token.T_8:  "bSlash",
		token.T_10: "char",
		token.T_11: "dQuote",
	},
	// ComPair
	{
		token.T_1:  ",",
		token.T_24: "}",
	},
	// ComVal
	{
		token.T_1: ",",
		token.T_7: "]",
	},
	// EXP
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// Elements
	{
		token.T_7: "]",
	},
	// EscOrComment
	{
		token.EOF:  "$",
		token.T_1:  ",",
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_5:  ":",
		token.T_6:  "[",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_11: "dQuote",
		token.T_14: "escCharSpace",
		token.T_15: "false",
		token.T_17: "line_comment",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
		token.T_24: "}",
	},
	// FALSE
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// FRAC
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// INT
	{
		token.T_1:  ",",
		token.T_3:  ".",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// Integers
	{
		token.T_1:  ",",
		token.T_3:  ".",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// JSON
	{
		token.EOF: "$",
	},
	// LBRACE
	{
		token.T_11: "dQuote",
		token.T_24: "}",
	},
	// LBRACKET
	{
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_6:  "[",
		token.T_7:  "]",
		token.T_11: "dQuote",
		token.T_15: "false",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
	},
	// Members
	{
		token.T_24: "}",
	},
	// NUL
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// Neg
	{
		token.T_4:  "0",
		token.T_18: "nonZero",
	},
	// NumSeq
	{
		token.T_1:  ",",
		token.T_3:  ".",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// Number
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// Object
	{
		token.EOF:  "$",
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// Pair
	{
		token.T_1:  ",",
		token.T_24: "}",
	},
	// PlusORMinus
	{
		token.T_20: "num",
	},
	// RBRACE
	{
		token.EOF:  "$",
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// RBRACKET
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// String
	{
		token.T_1:  ",",
		token.T_5:  ":",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// Suff1xchar
	{
		token.T_8:  "bSlash",
		token.T_10: "char",
		token.T_11: "dQuote",
	},
	// SuffCHAR
	{
		token.T_11: "dQuote",
	},
	// SuffComPair
	{
		token.T_24: "}",
	},
	// SuffComVal
	{
		token.T_7: "]",
	},
	// SuffEXP
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// SuffElements
	{
		token.T_7: "]",
	},
	// SuffFRAC
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// SuffMembers
	{
		token.T_24: "}",
	},
	// SuffNeg
	{
		token.T_4:  "0",
		token.T_18: "nonZero",
	},
	// SuffPlusORMinus
	{
		token.T_20: "num",
	},
	// Suffchar
	{
		token.T_8:  "bSlash",
		token.T_10: "char",
		token.T_11: "dQuote",
	},
	// Suffnum
	{
		token.T_1:  ",",
		token.T_3:  ".",
		token.T_7:  "]",
		token.T_9:  "block_comment",
		token.T_12: "eE",
		token.T_14: "escCharSpace",
		token.T_17: "line_comment",
		token.T_24: "}",
	},
	// TRUE
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// Value
	{
		token.T_1:  ",",
		token.T_7:  "]",
		token.T_24: "}",
	},
	// WS
	{
		token.EOF:  "$",
		token.T_1:  ",",
		token.T_2:  "-",
		token.T_4:  "0",
		token.T_5:  ":",
		token.T_6:  "[",
		token.T_7:  "]",
		token.T_11: "dQuote",
		token.T_15: "false",
		token.T_18: "nonZero",
		token.T_19: "null",
		token.T_21: "true",
		token.T_23: "{",
		token.T_24: "}",
	},
}

/*** Errors ***/

/*
Error is returned by Parse at every point at which the parser fails to parse
a grammar production. For non-LL-1 grammars there will be an error for each
alternate attempted by the parser.

The errors are sorted in descending order of input position (index of token in
the stream of tokens).

Normally the error of interest is the one that has parsed the largest number of
tokens.
*/
type Error struct {
	// Index of token that caused the error.
	cI int

	// Grammar slot at which the error occured.
	Slot slot.Label

	// The token at which the error occurred.
	Token *token.Token

	// The line and column in the input text at which the error occurred
	Line, Column int

	// The tokens expected at the point where the error occurred
	Expected map[token.Type]string
}

func (pe *Error) String() string {
	w := new(bytes.Buffer)
	fmt.Fprintf(w, "Parse Error: %s I[%d]=%s at line %d col %d\n",
		pe.Slot, pe.cI, pe.Token, pe.Line, pe.Column)
	exp := []string{}
	for _, e := range pe.Expected {
		exp = append(exp, e)
	}
	fmt.Fprintf(w, "Expected one of: [%s]", strings.Join(exp, ","))
	return w.String()
}

func (p *parser) parseError(slot slot.Label, i int, expected map[token.Type]string) {
	pe := &Error{cI: i, Slot: slot, Token: p.lex.Tokens[i], Expected: expected}
	p.parseErrors = append(p.parseErrors, pe)
}

func (p *parser) sortParseErrors() {
	sort.Slice(p.parseErrors,
		func(i, j int) bool {
			return p.parseErrors[j].Token.Lext() < p.parseErrors[i].Token.Lext()
		})
	for _, pe := range p.parseErrors {
		pe.Line, pe.Column = p.lex.GetLineColumn(pe.Token.Lext())
	}
}

// Package parser is generated by gogll. Do not edit.
package parser

import (
	"bytes"
	"fmt"
	"sort"
	"strings"

	"JSON/lexer"
	"JSON/parser/bsr"
	"JSON/parser/slot"
	"JSON/parser/symbols"
	"JSON/token"
)

type parser struct {
	cI int

	R *descriptors
	U *descriptors

	popped   map[poppedNode]bool
	crf      map[clusterNode][]*crfNode
	crfNodes map[crfNode]*crfNode

	lex         *lexer.Lexer
	parseErrors []*Error

	bsrSet *bsr.Set
}

func newParser(l *lexer.Lexer) *parser {
	return &parser{
		cI:     0,
		lex:    l,
		R:      &descriptors{},
		U:      &descriptors{},
		popped: make(map[poppedNode]bool),
		crf: map[clusterNode][]*crfNode{
			{symbols.NT_JSON, 0}: {},
		},
		crfNodes:    map[crfNode]*crfNode{},
		bsrSet:      bsr.New(symbols.NT_JSON, l),
		parseErrors: nil,
	}
}

// Parse returns the BSR set containing the parse forest.
// If the parse was successfull []*Error is nil
func Parse(l *lexer.Lexer) (*bsr.Set, []*Error) {
	return newParser(l).parse()
}

func (p *parser) parse() (*bsr.Set, []*Error) {
	var L slot.Label
	m, cU := len(p.lex.Tokens)-1, 0
	p.ntAdd(symbols.NT_JSON, 0)
	// p.DumpDescriptors()
	for !p.R.empty() {
		L, cU, p.cI = p.R.remove()

		// fmt.Println()
		// fmt.Printf("L:%s, cI:%d, I[p.cI]:%s, cU:%d\n", L, p.cI, p.lex.Tokens[p.cI], cU)
		// p.DumpDescriptors()

		switch L {
		case slot.Array0R0: // Array : ∙LBRACKET OptElem RBRACKET

			p.call(slot.Array0R1, cU, p.cI)
		case slot.Array0R1: // Array : LBRACKET ∙OptElem RBRACKET

			if !p.testSelect(slot.Array0R1) {
				p.parseError(slot.Array0R1, p.cI, first[slot.Array0R1])
				break
			}

			p.call(slot.Array0R2, cU, p.cI)
		case slot.Array0R2: // Array : LBRACKET OptElem ∙RBRACKET

			if !p.testSelect(slot.Array0R2) {
				p.parseError(slot.Array0R2, p.cI, first[slot.Array0R2])
				break
			}

			p.call(slot.Array0R3, cU, p.cI)
		case slot.Array0R3: // Array : LBRACKET OptElem RBRACKET ∙

			p.rtn(symbols.NT_Array, cU, p.cI)
		case slot.CHAR0R0: // CHAR : ∙char

			p.bsrSet.Add(slot.CHAR0R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_CHAR, cU, p.cI)
		case slot.CHAR1R0: // CHAR : ∙bSlash CharCode

			p.bsrSet.Add(slot.CHAR1R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.CHAR1R1) {
				p.parseError(slot.CHAR1R1, p.cI, first[slot.CHAR1R1])
				break
			}

			p.call(slot.CHAR1R2, cU, p.cI)
		case slot.CHAR1R2: // CHAR : bSlash CharCode ∙

			p.rtn(symbols.NT_CHAR, cU, p.cI)
		case slot.COLON0R0: // COLON : ∙: WS

			p.bsrSet.Add(slot.COLON0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.COLON0R1) {
				p.parseError(slot.COLON0R1, p.cI, first[slot.COLON0R1])
				break
			}

			p.call(slot.COLON0R2, cU, p.cI)
		case slot.COLON0R2: // COLON : : WS ∙

			p.rtn(symbols.NT_COLON, cU, p.cI)
		case slot.COMMA0R0: // COMMA : ∙, WS

			p.bsrSet.Add(slot.COMMA0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.COMMA0R1) {
				p.parseError(slot.COMMA0R1, p.cI, first[slot.COMMA0R1])
				break
			}

			p.call(slot.COMMA0R2, cU, p.cI)
		case slot.COMMA0R2: // COMMA : , WS ∙

			p.rtn(symbols.NT_COMMA, cU, p.cI)
		case slot.CharCode0R0: // CharCode : ∙esc

			p.bsrSet.Add(slot.CharCode0R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_CharCode, cU, p.cI)
		case slot.CharCode1R0: // CharCode : ∙u HEX HEX HEX HEX

			p.bsrSet.Add(slot.CharCode1R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.CharCode1R1) {
				p.parseError(slot.CharCode1R1, p.cI, first[slot.CharCode1R1])
				break
			}

			p.call(slot.CharCode1R2, cU, p.cI)
		case slot.CharCode1R2: // CharCode : u HEX ∙HEX HEX HEX

			if !p.testSelect(slot.CharCode1R2) {
				p.parseError(slot.CharCode1R2, p.cI, first[slot.CharCode1R2])
				break
			}

			p.call(slot.CharCode1R3, cU, p.cI)
		case slot.CharCode1R3: // CharCode : u HEX HEX ∙HEX HEX

			if !p.testSelect(slot.CharCode1R3) {
				p.parseError(slot.CharCode1R3, p.cI, first[slot.CharCode1R3])
				break
			}

			p.call(slot.CharCode1R4, cU, p.cI)
		case slot.CharCode1R4: // CharCode : u HEX HEX HEX ∙HEX

			if !p.testSelect(slot.CharCode1R4) {
				p.parseError(slot.CharCode1R4, p.cI, first[slot.CharCode1R4])
				break
			}

			p.call(slot.CharCode1R5, cU, p.cI)
		case slot.CharCode1R5: // CharCode : u HEX HEX HEX HEX ∙

			p.rtn(symbols.NT_CharCode, cU, p.cI)
		case slot.Elements0R0: // Elements : ∙Value RepComVal0x

			p.call(slot.Elements0R1, cU, p.cI)
		case slot.Elements0R1: // Elements : Value ∙RepComVal0x

			if !p.testSelect(slot.Elements0R1) {
				p.parseError(slot.Elements0R1, p.cI, first[slot.Elements0R1])
				break
			}

			p.call(slot.Elements0R2, cU, p.cI)
		case slot.Elements0R2: // Elements : Value RepComVal0x ∙

			p.rtn(symbols.NT_Elements, cU, p.cI)
		case slot.EscOrComment0R0: // EscOrComment : ∙escChar

			p.bsrSet.Add(slot.EscOrComment0R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_EscOrComment, cU, p.cI)
		case slot.EscOrComment1R0: // EscOrComment : ∙LineOrBlock

			p.call(slot.EscOrComment1R1, cU, p.cI)
		case slot.EscOrComment1R1: // EscOrComment : LineOrBlock ∙

			p.rtn(symbols.NT_EscOrComment, cU, p.cI)
		case slot.FALSE0R0: // FALSE : ∙false WS

			p.bsrSet.Add(slot.FALSE0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.FALSE0R1) {
				p.parseError(slot.FALSE0R1, p.cI, first[slot.FALSE0R1])
				break
			}

			p.call(slot.FALSE0R2, cU, p.cI)
		case slot.FALSE0R2: // FALSE : false WS ∙

			p.rtn(symbols.NT_FALSE, cU, p.cI)
		case slot.HEX0R0: // HEX : ∙Number

			p.call(slot.HEX0R1, cU, p.cI)
		case slot.HEX0R1: // HEX : Number ∙

			p.rtn(symbols.NT_HEX, cU, p.cI)
		case slot.HEX1R0: // HEX : ∙aA_fF

			p.bsrSet.Add(slot.HEX1R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_HEX, cU, p.cI)
		case slot.INT0R0: // INT : ∙optNeg Integers

			p.bsrSet.Add(slot.INT0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.INT0R1) {
				p.parseError(slot.INT0R1, p.cI, first[slot.INT0R1])
				break
			}

			p.call(slot.INT0R2, cU, p.cI)
		case slot.INT0R2: // INT : optNeg Integers ∙

			p.rtn(symbols.NT_INT, cU, p.cI)
		case slot.Integers0R0: // Integers : ∙integer

			p.bsrSet.Add(slot.Integers0R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_Integers, cU, p.cI)
		case slot.Integers1R0: // Integers : ∙zero

			p.bsrSet.Add(slot.Integers1R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_Integers, cU, p.cI)
		case slot.JSON0R0: // JSON : ∙WS Object

			p.call(slot.JSON0R1, cU, p.cI)
		case slot.JSON0R1: // JSON : WS ∙Object

			if !p.testSelect(slot.JSON0R1) {
				p.parseError(slot.JSON0R1, p.cI, first[slot.JSON0R1])
				break
			}

			p.call(slot.JSON0R2, cU, p.cI)
		case slot.JSON0R2: // JSON : WS Object ∙

			p.rtn(symbols.NT_JSON, cU, p.cI)
		case slot.LBRACE0R0: // LBRACE : ∙{ WS

			p.bsrSet.Add(slot.LBRACE0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.LBRACE0R1) {
				p.parseError(slot.LBRACE0R1, p.cI, first[slot.LBRACE0R1])
				break
			}

			p.call(slot.LBRACE0R2, cU, p.cI)
		case slot.LBRACE0R2: // LBRACE : { WS ∙

			p.rtn(symbols.NT_LBRACE, cU, p.cI)
		case slot.LBRACKET0R0: // LBRACKET : ∙[ WS

			p.bsrSet.Add(slot.LBRACKET0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.LBRACKET0R1) {
				p.parseError(slot.LBRACKET0R1, p.cI, first[slot.LBRACKET0R1])
				break
			}

			p.call(slot.LBRACKET0R2, cU, p.cI)
		case slot.LBRACKET0R2: // LBRACKET : [ WS ∙

			p.rtn(symbols.NT_LBRACKET, cU, p.cI)
		case slot.LineOrBlock0R0: // LineOrBlock : ∙line_comment

			p.bsrSet.Add(slot.LineOrBlock0R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_LineOrBlock, cU, p.cI)
		case slot.LineOrBlock1R0: // LineOrBlock : ∙block_comment

			p.bsrSet.Add(slot.LineOrBlock1R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_LineOrBlock, cU, p.cI)
		case slot.Members0R0: // Members : ∙Pair RepComPair0x

			p.call(slot.Members0R1, cU, p.cI)
		case slot.Members0R1: // Members : Pair ∙RepComPair0x

			if !p.testSelect(slot.Members0R1) {
				p.parseError(slot.Members0R1, p.cI, first[slot.Members0R1])
				break
			}

			p.call(slot.Members0R2, cU, p.cI)
		case slot.Members0R2: // Members : Pair RepComPair0x ∙

			p.rtn(symbols.NT_Members, cU, p.cI)
		case slot.NUL0R0: // NUL : ∙null WS

			p.bsrSet.Add(slot.NUL0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.NUL0R1) {
				p.parseError(slot.NUL0R1, p.cI, first[slot.NUL0R1])
				break
			}

			p.call(slot.NUL0R2, cU, p.cI)
		case slot.NUL0R2: // NUL : null WS ∙

			p.rtn(symbols.NT_NUL, cU, p.cI)
		case slot.Number0R0: // Number : ∙INT OptFrac OptExp WS

			p.call(slot.Number0R1, cU, p.cI)
		case slot.Number0R1: // Number : INT ∙OptFrac OptExp WS

			if !p.testSelect(slot.Number0R1) {
				p.parseError(slot.Number0R1, p.cI, first[slot.Number0R1])
				break
			}

			p.call(slot.Number0R2, cU, p.cI)
		case slot.Number0R2: // Number : INT OptFrac ∙OptExp WS

			if !p.testSelect(slot.Number0R2) {
				p.parseError(slot.Number0R2, p.cI, first[slot.Number0R2])
				break
			}

			p.call(slot.Number0R3, cU, p.cI)
		case slot.Number0R3: // Number : INT OptFrac OptExp ∙WS

			if !p.testSelect(slot.Number0R3) {
				p.parseError(slot.Number0R3, p.cI, first[slot.Number0R3])
				break
			}

			p.call(slot.Number0R4, cU, p.cI)
		case slot.Number0R4: // Number : INT OptFrac OptExp WS ∙

			p.rtn(symbols.NT_Number, cU, p.cI)
		case slot.Object0R0: // Object : ∙LBRACE OptMems RBRACE

			p.call(slot.Object0R1, cU, p.cI)
		case slot.Object0R1: // Object : LBRACE ∙OptMems RBRACE

			if !p.testSelect(slot.Object0R1) {
				p.parseError(slot.Object0R1, p.cI, first[slot.Object0R1])
				break
			}

			p.call(slot.Object0R2, cU, p.cI)
		case slot.Object0R2: // Object : LBRACE OptMems ∙RBRACE

			if !p.testSelect(slot.Object0R2) {
				p.parseError(slot.Object0R2, p.cI, first[slot.Object0R2])
				break
			}

			p.call(slot.Object0R3, cU, p.cI)
		case slot.Object0R3: // Object : LBRACE OptMems RBRACE ∙

			p.rtn(symbols.NT_Object, cU, p.cI)
		case slot.OptElem0R0: // OptElem : ∙Elements

			p.call(slot.OptElem0R1, cU, p.cI)
		case slot.OptElem0R1: // OptElem : Elements ∙

			p.rtn(symbols.NT_OptElem, cU, p.cI)
		case slot.OptElem1R0: // OptElem : ∙
			p.bsrSet.AddEmpty(slot.OptElem1R0, p.cI)

			p.rtn(symbols.NT_OptElem, cU, p.cI)
		case slot.OptExp0R0: // OptExp : ∙exp

			p.bsrSet.Add(slot.OptExp0R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_OptExp, cU, p.cI)
		case slot.OptExp1R0: // OptExp : ∙
			p.bsrSet.AddEmpty(slot.OptExp1R0, p.cI)

			p.rtn(symbols.NT_OptExp, cU, p.cI)
		case slot.OptFrac0R0: // OptFrac : ∙frac

			p.bsrSet.Add(slot.OptFrac0R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_OptFrac, cU, p.cI)
		case slot.OptFrac1R0: // OptFrac : ∙
			p.bsrSet.AddEmpty(slot.OptFrac1R0, p.cI)

			p.rtn(symbols.NT_OptFrac, cU, p.cI)
		case slot.OptMems0R0: // OptMems : ∙Members

			p.call(slot.OptMems0R1, cU, p.cI)
		case slot.OptMems0R1: // OptMems : Members ∙

			p.rtn(symbols.NT_OptMems, cU, p.cI)
		case slot.OptMems1R0: // OptMems : ∙
			p.bsrSet.AddEmpty(slot.OptMems1R0, p.cI)

			p.rtn(symbols.NT_OptMems, cU, p.cI)
		case slot.Pair0R0: // Pair : ∙String COLON Value

			p.call(slot.Pair0R1, cU, p.cI)
		case slot.Pair0R1: // Pair : String ∙COLON Value

			if !p.testSelect(slot.Pair0R1) {
				p.parseError(slot.Pair0R1, p.cI, first[slot.Pair0R1])
				break
			}

			p.call(slot.Pair0R2, cU, p.cI)
		case slot.Pair0R2: // Pair : String COLON ∙Value

			if !p.testSelect(slot.Pair0R2) {
				p.parseError(slot.Pair0R2, p.cI, first[slot.Pair0R2])
				break
			}

			p.call(slot.Pair0R3, cU, p.cI)
		case slot.Pair0R3: // Pair : String COLON Value ∙

			p.rtn(symbols.NT_Pair, cU, p.cI)
		case slot.RBRACE0R0: // RBRACE : ∙} WS

			p.bsrSet.Add(slot.RBRACE0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.RBRACE0R1) {
				p.parseError(slot.RBRACE0R1, p.cI, first[slot.RBRACE0R1])
				break
			}

			p.call(slot.RBRACE0R2, cU, p.cI)
		case slot.RBRACE0R2: // RBRACE : } WS ∙

			p.rtn(symbols.NT_RBRACE, cU, p.cI)
		case slot.RBRACKET0R0: // RBRACKET : ∙] WS

			p.bsrSet.Add(slot.RBRACKET0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.RBRACKET0R1) {
				p.parseError(slot.RBRACKET0R1, p.cI, first[slot.RBRACKET0R1])
				break
			}

			p.call(slot.RBRACKET0R2, cU, p.cI)
		case slot.RBRACKET0R2: // RBRACKET : ] WS ∙

			p.rtn(symbols.NT_RBRACKET, cU, p.cI)
		case slot.RepChar0x0R0: // RepChar0x : ∙CHAR RepChar0x

			p.call(slot.RepChar0x0R1, cU, p.cI)
		case slot.RepChar0x0R1: // RepChar0x : CHAR ∙RepChar0x

			if !p.testSelect(slot.RepChar0x0R1) {
				p.parseError(slot.RepChar0x0R1, p.cI, first[slot.RepChar0x0R1])
				break
			}

			p.call(slot.RepChar0x0R2, cU, p.cI)
		case slot.RepChar0x0R2: // RepChar0x : CHAR RepChar0x ∙

			p.rtn(symbols.NT_RepChar0x, cU, p.cI)
		case slot.RepChar0x1R0: // RepChar0x : ∙
			p.bsrSet.AddEmpty(slot.RepChar0x1R0, p.cI)

			p.rtn(symbols.NT_RepChar0x, cU, p.cI)
		case slot.RepComPair0x0R0: // RepComPair0x : ∙COMMA Pair RepComPair0x

			p.call(slot.RepComPair0x0R1, cU, p.cI)
		case slot.RepComPair0x0R1: // RepComPair0x : COMMA ∙Pair RepComPair0x

			if !p.testSelect(slot.RepComPair0x0R1) {
				p.parseError(slot.RepComPair0x0R1, p.cI, first[slot.RepComPair0x0R1])
				break
			}

			p.call(slot.RepComPair0x0R2, cU, p.cI)
		case slot.RepComPair0x0R2: // RepComPair0x : COMMA Pair ∙RepComPair0x

			if !p.testSelect(slot.RepComPair0x0R2) {
				p.parseError(slot.RepComPair0x0R2, p.cI, first[slot.RepComPair0x0R2])
				break
			}

			p.call(slot.RepComPair0x0R3, cU, p.cI)
		case slot.RepComPair0x0R3: // RepComPair0x : COMMA Pair RepComPair0x ∙

			p.rtn(symbols.NT_RepComPair0x, cU, p.cI)
		case slot.RepComPair0x1R0: // RepComPair0x : ∙
			p.bsrSet.AddEmpty(slot.RepComPair0x1R0, p.cI)

			p.rtn(symbols.NT_RepComPair0x, cU, p.cI)
		case slot.RepComVal0x0R0: // RepComVal0x : ∙COMMA Value RepComVal0x

			p.call(slot.RepComVal0x0R1, cU, p.cI)
		case slot.RepComVal0x0R1: // RepComVal0x : COMMA ∙Value RepComVal0x

			if !p.testSelect(slot.RepComVal0x0R1) {
				p.parseError(slot.RepComVal0x0R1, p.cI, first[slot.RepComVal0x0R1])
				break
			}

			p.call(slot.RepComVal0x0R2, cU, p.cI)
		case slot.RepComVal0x0R2: // RepComVal0x : COMMA Value ∙RepComVal0x

			if !p.testSelect(slot.RepComVal0x0R2) {
				p.parseError(slot.RepComVal0x0R2, p.cI, first[slot.RepComVal0x0R2])
				break
			}

			p.call(slot.RepComVal0x0R3, cU, p.cI)
		case slot.RepComVal0x0R3: // RepComVal0x : COMMA Value RepComVal0x ∙

			p.rtn(symbols.NT_RepComVal0x, cU, p.cI)
		case slot.RepComVal0x1R0: // RepComVal0x : ∙
			p.bsrSet.AddEmpty(slot.RepComVal0x1R0, p.cI)

			p.rtn(symbols.NT_RepComVal0x, cU, p.cI)
		case slot.String0R0: // String : ∙dQuote RepChar0x dQuote WS

			p.bsrSet.Add(slot.String0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.String0R1) {
				p.parseError(slot.String0R1, p.cI, first[slot.String0R1])
				break
			}

			p.call(slot.String0R2, cU, p.cI)
		case slot.String0R2: // String : dQuote RepChar0x ∙dQuote WS

			if !p.testSelect(slot.String0R2) {
				p.parseError(slot.String0R2, p.cI, first[slot.String0R2])
				break
			}

			p.bsrSet.Add(slot.String0R3, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.String0R3) {
				p.parseError(slot.String0R3, p.cI, first[slot.String0R3])
				break
			}

			p.call(slot.String0R4, cU, p.cI)
		case slot.String0R4: // String : dQuote RepChar0x dQuote WS ∙

			p.rtn(symbols.NT_String, cU, p.cI)
		case slot.TRUE0R0: // TRUE : ∙true WS

			p.bsrSet.Add(slot.TRUE0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.TRUE0R1) {
				p.parseError(slot.TRUE0R1, p.cI, first[slot.TRUE0R1])
				break
			}

			p.call(slot.TRUE0R2, cU, p.cI)
		case slot.TRUE0R2: // TRUE : true WS ∙

			p.rtn(symbols.NT_TRUE, cU, p.cI)
		case slot.Value0R0: // Value : ∙String

			p.call(slot.Value0R1, cU, p.cI)
		case slot.Value0R1: // Value : String ∙

			p.rtn(symbols.NT_Value, cU, p.cI)
		case slot.Value1R0: // Value : ∙Number

			p.call(slot.Value1R1, cU, p.cI)
		case slot.Value1R1: // Value : Number ∙

			p.rtn(symbols.NT_Value, cU, p.cI)
		case slot.Value2R0: // Value : ∙Object

			p.call(slot.Value2R1, cU, p.cI)
		case slot.Value2R1: // Value : Object ∙

			p.rtn(symbols.NT_Value, cU, p.cI)
		case slot.Value3R0: // Value : ∙Array

			p.call(slot.Value3R1, cU, p.cI)
		case slot.Value3R1: // Value : Array ∙

			p.rtn(symbols.NT_Value, cU, p.cI)
		case slot.Value4R0: // Value : ∙TRUE

			p.call(slot.Value4R1, cU, p.cI)
		case slot.Value4R1: // Value : TRUE ∙

			p.rtn(symbols.NT_Value, cU, p.cI)
		case slot.Value5R0: // Value : ∙FALSE

			p.call(slot.Value5R1, cU, p.cI)
		case slot.Value5R1: // Value : FALSE ∙

			p.rtn(symbols.NT_Value, cU, p.cI)
		case slot.Value6R0: // Value : ∙NUL

			p.call(slot.Value6R1, cU, p.cI)
		case slot.Value6R1: // Value : NUL ∙

			p.rtn(symbols.NT_Value, cU, p.cI)
		case slot.WS0R0: // WS : ∙EscOrComment WS

			p.call(slot.WS0R1, cU, p.cI)
		case slot.WS0R1: // WS : EscOrComment ∙WS

			if !p.testSelect(slot.WS0R1) {
				p.parseError(slot.WS0R1, p.cI, first[slot.WS0R1])
				break
			}

			p.call(slot.WS0R2, cU, p.cI)
		case slot.WS0R2: // WS : EscOrComment WS ∙

			p.rtn(symbols.NT_WS, cU, p.cI)
		case slot.WS1R0: // WS : ∙
			p.bsrSet.AddEmpty(slot.WS1R0, p.cI)

			p.rtn(symbols.NT_WS, cU, p.cI)

		default:
			panic("This must not happen")
		}
	}
	if !p.bsrSet.Contain(symbols.NT_JSON, 0, m) {
		p.sortParseErrors()
		return nil, p.parseErrors
	}
	return p.bsrSet, nil
}

func (p *parser) ntAdd(nt symbols.NT, j int) {
	// fmt.Printf("p.ntAdd(%s, %d)\n", nt, j)
	failed := true
	expected := map[token.Type]string{}
	for _, l := range slot.GetAlternates(nt) {
		if p.testSelect(l) {
			p.dscAdd(l, j, j)
			failed = false
		} else {
			for k, v := range first[l] {
				expected[k] = v
			}
		}
	}
	if failed {
		for _, l := range slot.GetAlternates(nt) {
			p.parseError(l, j, expected)
		}
	}
}

/*** Call Return Forest ***/

type poppedNode struct {
	X    symbols.NT
	k, j int
}

type clusterNode struct {
	X symbols.NT
	k int
}

type crfNode struct {
	L slot.Label
	i int
}

/*
suppose that L is Y ::=αX ·β
if there is no CRF node labelled (L,i)
	create one let u be the CRF node labelled (L,i)
if there is no CRF node labelled (X, j) {
	create a CRF node v labelled (X, j)
	create an edge from v to u
	ntAdd(X, j)
} else {
	let v be the CRF node labelled (X, j)
	if there is not an edge from v to u {
		create an edge from v to u
		for all ((X, j,h)∈P) {
			dscAdd(L, i, h);
			bsrAdd(L, i, j, h)
		}
	}
}
*/
func (p *parser) call(L slot.Label, i, j int) {
	// fmt.Printf("p.call(%s,%d,%d)\n", L,i,j)
	u, exist := p.crfNodes[crfNode{L, i}]
	// fmt.Printf("  u exist=%t\n", exist)
	if !exist {
		u = &crfNode{L, i}
		p.crfNodes[*u] = u
	}
	X := L.Symbols()[L.Pos()-1].(symbols.NT)
	ndV := clusterNode{X, j}
	v, exist := p.crf[ndV]
	if !exist {
		// fmt.Println("  v !exist")
		p.crf[ndV] = []*crfNode{u}
		p.ntAdd(X, j)
	} else {
		// fmt.Println("  v exist")
		if !existEdge(v, u) {
			// fmt.Printf("  !existEdge(%v)\n", u)
			p.crf[ndV] = append(v, u)
			// fmt.Printf("|popped|=%d\n", len(popped))
			for pnd := range p.popped {
				if pnd.X == X && pnd.k == j {
					p.dscAdd(L, i, pnd.j)
					p.bsrSet.Add(L, i, j, pnd.j)
				}
			}
		}
	}
}

func existEdge(nds []*crfNode, nd *crfNode) bool {
	for _, nd1 := range nds {
		if nd1 == nd {
			return true
		}
	}
	return false
}

func (p *parser) rtn(X symbols.NT, k, j int) {
	// fmt.Printf("p.rtn(%s,%d,%d)\n", X,k,j)
	pn := poppedNode{X, k, j}
	if _, exist := p.popped[pn]; !exist {
		p.popped[pn] = true
		for _, nd := range p.crf[clusterNode{X, k}] {
			p.dscAdd(nd.L, nd.i, j)
			p.bsrSet.Add(nd.L, nd.i, k, j)
		}
	}
}

// func CRFString() string {
// 	buf := new(bytes.Buffer)
// 	buf.WriteString("CRF: {")
// 	for cn, nds := range crf{
// 		for _, nd := range nds {
// 			fmt.Fprintf(buf, "%s->%s, ", cn, nd)
// 		}
// 	}
// 	buf.WriteString("}")
// 	return buf.String()
// }

func (cn clusterNode) String() string {
	return fmt.Sprintf("(%s,%d)", cn.X, cn.k)
}

func (n crfNode) String() string {
	return fmt.Sprintf("(%s,%d)", n.L.String(), n.i)
}

// func PoppedString() string {
// 	buf := new(bytes.Buffer)
// 	buf.WriteString("Popped: {")
// 	for p, _ := range popped {
// 		fmt.Fprintf(buf, "(%s,%d,%d) ", p.X, p.k, p.j)
// 	}
// 	buf.WriteString("}")
// 	return buf.String()
// }

/*** descriptors ***/

type descriptors struct {
	set []*descriptor
}

func (ds *descriptors) contain(d *descriptor) bool {
	for _, d1 := range ds.set {
		if d1 == d {
			return true
		}
	}
	return false
}

func (ds *descriptors) empty() bool {
	return len(ds.set) == 0
}

func (ds *descriptors) String() string {
	buf := new(bytes.Buffer)
	buf.WriteString("{")
	for i, d := range ds.set {
		if i > 0 {
			buf.WriteString("; ")
		}
		fmt.Fprintf(buf, "%s", d)
	}
	buf.WriteString("}")
	return buf.String()
}

type descriptor struct {
	L slot.Label
	k int
	i int
}

func (d *descriptor) String() string {
	return fmt.Sprintf("%s,%d,%d", d.L, d.k, d.i)
}

func (p *parser) dscAdd(L slot.Label, k, i int) {
	// fmt.Printf("p.dscAdd(%s,%d,%d)\n", L, k, i)
	d := &descriptor{L, k, i}
	if !p.U.contain(d) {
		p.R.set = append(p.R.set, d)
		p.U.set = append(p.U.set, d)
	}
}

func (ds *descriptors) remove() (L slot.Label, k, i int) {
	d := ds.set[len(ds.set)-1]
	ds.set = ds.set[:len(ds.set)-1]
	// fmt.Printf("remove: %s,%d,%d\n", d.L, d.k, d.i)
	return d.L, d.k, d.i
}

func (p *parser) DumpDescriptors() {
	p.DumpR()
	p.DumpU()
}

func (p *parser) DumpR() {
	fmt.Println("R:")
	for _, d := range p.R.set {
		fmt.Printf(" %s\n", d)
	}
}

func (p *parser) DumpU() {
	fmt.Println("U:")
	for _, d := range p.U.set {
		fmt.Printf(" %s\n", d)
	}
}

/*** TestSelect ***/

func (p *parser) follow(nt symbols.NT) bool {
	_, exist := followSets[nt][p.lex.Tokens[p.cI].Type()]
	return exist
}

func (p *parser) testSelect(l slot.Label) bool {
	return l.IsNullable() || l.FirstContains(p.lex.Tokens[p.cI].Type())
	// _, exist := first[l][p.lex.Tokens[p.cI].Type()]
	// return exist
}

var first = []map[token.Type]string{
	// Array : ∙LBRACKET OptElem RBRACKET
	{
		token.T_2: "[",
	},
	// Array : LBRACKET ∙OptElem RBRACKET
	{
		token.T_2:  "[",
		token.T_3:  "]",
		token.T_8:  "dQuote",
		token.T_13: "false",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
	},
	// Array : LBRACKET OptElem ∙RBRACKET
	{
		token.T_3: "]",
	},
	// Array : LBRACKET OptElem RBRACKET ∙
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// CHAR : ∙char
	{
		token.T_7: "char",
	},
	// CHAR : char ∙
	{
		token.T_5: "bSlash",
		token.T_7: "char",
		token.T_8: "dQuote",
	},
	// CHAR : ∙bSlash CharCode
	{
		token.T_5: "bSlash",
	},
	// CHAR : bSlash ∙CharCode
	{
		token.T_9:  "esc",
		token.T_21: "u",
	},
	// CHAR : bSlash CharCode ∙
	{
		token.T_5: "bSlash",
		token.T_7: "char",
		token.T_8: "dQuote",
	},
	// COLON : ∙: WS
	{
		token.T_1: ":",
	},
	// COLON : : ∙WS
	{
		token.T_2:  "[",
		token.T_6:  "block_comment",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_13: "false",
		token.T_16: "line_comment",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
	},
	// COLON : : WS ∙
	{
		token.T_2:  "[",
		token.T_8:  "dQuote",
		token.T_13: "false",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
	},
	// COMMA : ∙, WS
	{
		token.T_0: ",",
	},
	// COMMA : , ∙WS
	{
		token.T_2:  "[",
		token.T_6:  "block_comment",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_13: "false",
		token.T_16: "line_comment",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
	},
	// COMMA : , WS ∙
	{
		token.T_2:  "[",
		token.T_8:  "dQuote",
		token.T_13: "false",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
	},
	// CharCode : ∙esc
	{
		token.T_9: "esc",
	},
	// CharCode : esc ∙
	{
		token.T_5: "bSlash",
		token.T_7: "char",
		token.T_8: "dQuote",
	},
	// CharCode : ∙u HEX HEX HEX HEX
	{
		token.T_21: "u",
	},
	// CharCode : u ∙HEX HEX HEX HEX
	{
		token.T_4:  "aA_fF",
		token.T_19: "optNeg",
	},
	// CharCode : u HEX ∙HEX HEX HEX
	{
		token.T_4:  "aA_fF",
		token.T_19: "optNeg",
	},
	// CharCode : u HEX HEX ∙HEX HEX
	{
		token.T_4:  "aA_fF",
		token.T_19: "optNeg",
	},
	// CharCode : u HEX HEX HEX ∙HEX
	{
		token.T_4:  "aA_fF",
		token.T_19: "optNeg",
	},
	// CharCode : u HEX HEX HEX HEX ∙
	{
		token.T_5: "bSlash",
		token.T_7: "char",
		token.T_8: "dQuote",
	},
	// Elements : ∙Value RepComVal0x
	{
		token.T_2:  "[",
		token.T_8:  "dQuote",
		token.T_13: "false",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
	},
	// Elements : Value ∙RepComVal0x
	{
		token.T_0: ",",
		token.T_3: "]",
	},
	// Elements : Value RepComVal0x ∙
	{
		token.T_3: "]",
	},
	// EscOrComment : ∙escChar
	{
		token.T_10: "escChar",
	},
	// EscOrComment : escChar ∙
	{
		token.EOF:  "$",
		token.T_0:  ",",
		token.T_1:  ":",
		token.T_2:  "[",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_6:  "block_comment",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_13: "false",
		token.T_16: "line_comment",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
		token.T_24: "}",
	},
	// EscOrComment : ∙LineOrBlock
	{
		token.T_6:  "block_comment",
		token.T_16: "line_comment",
	},
	// EscOrComment : LineOrBlock ∙
	{
		token.EOF:  "$",
		token.T_0:  ",",
		token.T_1:  ":",
		token.T_2:  "[",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_6:  "block_comment",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_13: "false",
		token.T_16: "line_comment",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
		token.T_24: "}",
	},
	// FALSE : ∙false WS
	{
		token.T_13: "false",
	},
	// FALSE : false ∙WS
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_6:  "block_comment",
		token.T_10: "escChar",
		token.T_16: "line_comment",
		token.T_24: "}",
	},
	// FALSE : false WS ∙
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// HEX : ∙Number
	{
		token.T_19: "optNeg",
	},
	// HEX : Number ∙
	{
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_19: "optNeg",
	},
	// HEX : ∙aA_fF
	{
		token.T_4: "aA_fF",
	},
	// HEX : aA_fF ∙
	{
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_19: "optNeg",
	},
	// INT : ∙optNeg Integers
	{
		token.T_19: "optNeg",
	},
	// INT : optNeg ∙Integers
	{
		token.T_15: "integer",
		token.T_22: "zero",
	},
	// INT : optNeg Integers ∙
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_6:  "block_comment",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_12: "exp",
		token.T_14: "frac",
		token.T_16: "line_comment",
		token.T_19: "optNeg",
		token.T_24: "}",
	},
	// Integers : ∙integer
	{
		token.T_15: "integer",
	},
	// Integers : integer ∙
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_6:  "block_comment",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_12: "exp",
		token.T_14: "frac",
		token.T_16: "line_comment",
		token.T_19: "optNeg",
		token.T_24: "}",
	},
	// Integers : ∙zero
	{
		token.T_22: "zero",
	},
	// Integers : zero ∙
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_6:  "block_comment",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_12: "exp",
		token.T_14: "frac",
		token.T_16: "line_comment",
		token.T_19: "optNeg",
		token.T_24: "}",
	},
	// JSON : ∙WS Object
	{
		token.T_6:  "block_comment",
		token.T_10: "escChar",
		token.T_16: "line_comment",
		token.T_23: "{",
	},
	// JSON : WS ∙Object
	{
		token.T_23: "{",
	},
	// JSON : WS Object ∙
	{
		token.EOF: "$",
	},
	// LBRACE : ∙{ WS
	{
		token.T_23: "{",
	},
	// LBRACE : { ∙WS
	{
		token.T_6:  "block_comment",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_16: "line_comment",
		token.T_24: "}",
	},
	// LBRACE : { WS ∙
	{
		token.T_8:  "dQuote",
		token.T_24: "}",
	},
	// LBRACKET : ∙[ WS
	{
		token.T_2: "[",
	},
	// LBRACKET : [ ∙WS
	{
		token.T_2:  "[",
		token.T_3:  "]",
		token.T_6:  "block_comment",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_13: "false",
		token.T_16: "line_comment",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
	},
	// LBRACKET : [ WS ∙
	{
		token.T_2:  "[",
		token.T_3:  "]",
		token.T_8:  "dQuote",
		token.T_13: "false",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
	},
	// LineOrBlock : ∙line_comment
	{
		token.T_16: "line_comment",
	},
	// LineOrBlock : line_comment ∙
	{
		token.EOF:  "$",
		token.T_0:  ",",
		token.T_1:  ":",
		token.T_2:  "[",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_6:  "block_comment",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_13: "false",
		token.T_16: "line_comment",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
		token.T_24: "}",
	},
	// LineOrBlock : ∙block_comment
	{
		token.T_6: "block_comment",
	},
	// LineOrBlock : block_comment ∙
	{
		token.EOF:  "$",
		token.T_0:  ",",
		token.T_1:  ":",
		token.T_2:  "[",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_6:  "block_comment",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_13: "false",
		token.T_16: "line_comment",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
		token.T_24: "}",
	},
	// Members : ∙Pair RepComPair0x
	{
		token.T_8: "dQuote",
	},
	// Members : Pair ∙RepComPair0x
	{
		token.T_0:  ",",
		token.T_24: "}",
	},
	// Members : Pair RepComPair0x ∙
	{
		token.T_24: "}",
	},
	// NUL : ∙null WS
	{
		token.T_18: "null",
	},
	// NUL : null ∙WS
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_6:  "block_comment",
		token.T_10: "escChar",
		token.T_16: "line_comment",
		token.T_24: "}",
	},
	// NUL : null WS ∙
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// Number : ∙INT OptFrac OptExp WS
	{
		token.T_19: "optNeg",
	},
	// Number : INT ∙OptFrac OptExp WS
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_6:  "block_comment",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_12: "exp",
		token.T_14: "frac",
		token.T_16: "line_comment",
		token.T_19: "optNeg",
		token.T_24: "}",
	},
	// Number : INT OptFrac ∙OptExp WS
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_6:  "block_comment",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_12: "exp",
		token.T_16: "line_comment",
		token.T_19: "optNeg",
		token.T_24: "}",
	},
	// Number : INT OptFrac OptExp ∙WS
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_6:  "block_comment",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_16: "line_comment",
		token.T_19: "optNeg",
		token.T_24: "}",
	},
	// Number : INT OptFrac OptExp WS ∙
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_19: "optNeg",
		token.T_24: "}",
	},
	// Object : ∙LBRACE OptMems RBRACE
	{
		token.T_23: "{",
	},
	// Object : LBRACE ∙OptMems RBRACE
	{
		token.T_8:  "dQuote",
		token.T_24: "}",
	},
	// Object : LBRACE OptMems ∙RBRACE
	{
		token.T_24: "}",
	},
	// Object : LBRACE OptMems RBRACE ∙
	{
		token.EOF:  "$",
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// OptElem : ∙Elements
	{
		token.T_2:  "[",
		token.T_8:  "dQuote",
		token.T_13: "false",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
	},
	// OptElem : Elements ∙
	{
		token.T_3: "]",
	},
	// OptElem : ∙
	{
		token.T_3: "]",
	},
	// OptExp : ∙exp
	{
		token.T_12: "exp",
	},
	// OptExp : exp ∙
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_6:  "block_comment",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_16: "line_comment",
		token.T_19: "optNeg",
		token.T_24: "}",
	},
	// OptExp : ∙
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_6:  "block_comment",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_16: "line_comment",
		token.T_19: "optNeg",
		token.T_24: "}",
	},
	// OptFrac : ∙frac
	{
		token.T_14: "frac",
	},
	// OptFrac : frac ∙
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_6:  "block_comment",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_12: "exp",
		token.T_16: "line_comment",
		token.T_19: "optNeg",
		token.T_24: "}",
	},
	// OptFrac : ∙
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_6:  "block_comment",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_12: "exp",
		token.T_16: "line_comment",
		token.T_19: "optNeg",
		token.T_24: "}",
	},
	// OptMems : ∙Members
	{
		token.T_8: "dQuote",
	},
	// OptMems : Members ∙
	{
		token.T_24: "}",
	},
	// OptMems : ∙
	{
		token.T_24: "}",
	},
	// Pair : ∙String COLON Value
	{
		token.T_8: "dQuote",
	},
	// Pair : String ∙COLON Value
	{
		token.T_1: ":",
	},
	// Pair : String COLON ∙Value
	{
		token.T_2:  "[",
		token.T_8:  "dQuote",
		token.T_13: "false",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
	},
	// Pair : String COLON Value ∙
	{
		token.T_0:  ",",
		token.T_24: "}",
	},
	// RBRACE : ∙} WS
	{
		token.T_24: "}",
	},
	// RBRACE : } ∙WS
	{
		token.EOF:  "$",
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_6:  "block_comment",
		token.T_10: "escChar",
		token.T_16: "line_comment",
		token.T_24: "}",
	},
	// RBRACE : } WS ∙
	{
		token.EOF:  "$",
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// RBRACKET : ∙] WS
	{
		token.T_3: "]",
	},
	// RBRACKET : ] ∙WS
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_6:  "block_comment",
		token.T_10: "escChar",
		token.T_16: "line_comment",
		token.T_24: "}",
	},
	// RBRACKET : ] WS ∙
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// RepChar0x : ∙CHAR RepChar0x
	{
		token.T_5: "bSlash",
		token.T_7: "char",
	},
	// RepChar0x : CHAR ∙RepChar0x
	{
		token.T_5: "bSlash",
		token.T_7: "char",
		token.T_8: "dQuote",
	},
	// RepChar0x : CHAR RepChar0x ∙
	{
		token.T_8: "dQuote",
	},
	// RepChar0x : ∙
	{
		token.T_8: "dQuote",
	},
	// RepComPair0x : ∙COMMA Pair RepComPair0x
	{
		token.T_0: ",",
	},
	// RepComPair0x : COMMA ∙Pair RepComPair0x
	{
		token.T_8: "dQuote",
	},
	// RepComPair0x : COMMA Pair ∙RepComPair0x
	{
		token.T_0:  ",",
		token.T_24: "}",
	},
	// RepComPair0x : COMMA Pair RepComPair0x ∙
	{
		token.T_24: "}",
	},
	// RepComPair0x : ∙
	{
		token.T_24: "}",
	},
	// RepComVal0x : ∙COMMA Value RepComVal0x
	{
		token.T_0: ",",
	},
	// RepComVal0x : COMMA ∙Value RepComVal0x
	{
		token.T_2:  "[",
		token.T_8:  "dQuote",
		token.T_13: "false",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
	},
	// RepComVal0x : COMMA Value ∙RepComVal0x
	{
		token.T_0: ",",
		token.T_3: "]",
	},
	// RepComVal0x : COMMA Value RepComVal0x ∙
	{
		token.T_3: "]",
	},
	// RepComVal0x : ∙
	{
		token.T_3: "]",
	},
	// String : ∙dQuote RepChar0x dQuote WS
	{
		token.T_8: "dQuote",
	},
	// String : dQuote ∙RepChar0x dQuote WS
	{
		token.T_5: "bSlash",
		token.T_7: "char",
		token.T_8: "dQuote",
	},
	// String : dQuote RepChar0x ∙dQuote WS
	{
		token.T_8: "dQuote",
	},
	// String : dQuote RepChar0x dQuote ∙WS
	{
		token.T_0:  ",",
		token.T_1:  ":",
		token.T_3:  "]",
		token.T_6:  "block_comment",
		token.T_10: "escChar",
		token.T_16: "line_comment",
		token.T_24: "}",
	},
	// String : dQuote RepChar0x dQuote WS ∙
	{
		token.T_0:  ",",
		token.T_1:  ":",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// TRUE : ∙true WS
	{
		token.T_20: "true",
	},
	// TRUE : true ∙WS
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_6:  "block_comment",
		token.T_10: "escChar",
		token.T_16: "line_comment",
		token.T_24: "}",
	},
	// TRUE : true WS ∙
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// Value : ∙String
	{
		token.T_8: "dQuote",
	},
	// Value : String ∙
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// Value : ∙Number
	{
		token.T_19: "optNeg",
	},
	// Value : Number ∙
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// Value : ∙Object
	{
		token.T_23: "{",
	},
	// Value : Object ∙
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// Value : ∙Array
	{
		token.T_2: "[",
	},
	// Value : Array ∙
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// Value : ∙TRUE
	{
		token.T_20: "true",
	},
	// Value : TRUE ∙
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// Value : ∙FALSE
	{
		token.T_13: "false",
	},
	// Value : FALSE ∙
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// Value : ∙NUL
	{
		token.T_18: "null",
	},
	// Value : NUL ∙
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// WS : ∙EscOrComment WS
	{
		token.T_6:  "block_comment",
		token.T_10: "escChar",
		token.T_16: "line_comment",
	},
	// WS : EscOrComment ∙WS
	{
		token.EOF:  "$",
		token.T_0:  ",",
		token.T_1:  ":",
		token.T_2:  "[",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_6:  "block_comment",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_13: "false",
		token.T_16: "line_comment",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
		token.T_24: "}",
	},
	// WS : EscOrComment WS ∙
	{
		token.EOF:  "$",
		token.T_0:  ",",
		token.T_1:  ":",
		token.T_2:  "[",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_13: "false",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
		token.T_24: "}",
	},
	// WS : ∙
	{
		token.EOF:  "$",
		token.T_0:  ",",
		token.T_1:  ":",
		token.T_2:  "[",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_13: "false",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
		token.T_24: "}",
	},
}

var followSets = []map[token.Type]string{
	// Array
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// CHAR
	{
		token.T_5: "bSlash",
		token.T_7: "char",
		token.T_8: "dQuote",
	},
	// COLON
	{
		token.T_2:  "[",
		token.T_8:  "dQuote",
		token.T_13: "false",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
	},
	// COMMA
	{
		token.T_2:  "[",
		token.T_8:  "dQuote",
		token.T_13: "false",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
	},
	// CharCode
	{
		token.T_5: "bSlash",
		token.T_7: "char",
		token.T_8: "dQuote",
	},
	// Elements
	{
		token.T_3: "]",
	},
	// EscOrComment
	{
		token.EOF:  "$",
		token.T_0:  ",",
		token.T_1:  ":",
		token.T_2:  "[",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_6:  "block_comment",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_13: "false",
		token.T_16: "line_comment",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
		token.T_24: "}",
	},
	// FALSE
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// HEX
	{
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_19: "optNeg",
	},
	// INT
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_6:  "block_comment",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_12: "exp",
		token.T_14: "frac",
		token.T_16: "line_comment",
		token.T_19: "optNeg",
		token.T_24: "}",
	},
	// Integers
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_6:  "block_comment",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_12: "exp",
		token.T_14: "frac",
		token.T_16: "line_comment",
		token.T_19: "optNeg",
		token.T_24: "}",
	},
	// JSON
	{
		token.EOF: "$",
	},
	// LBRACE
	{
		token.T_8:  "dQuote",
		token.T_24: "}",
	},
	// LBRACKET
	{
		token.T_2:  "[",
		token.T_3:  "]",
		token.T_8:  "dQuote",
		token.T_13: "false",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
	},
	// LineOrBlock
	{
		token.EOF:  "$",
		token.T_0:  ",",
		token.T_1:  ":",
		token.T_2:  "[",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_6:  "block_comment",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_13: "false",
		token.T_16: "line_comment",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
		token.T_24: "}",
	},
	// Members
	{
		token.T_24: "}",
	},
	// NUL
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// Number
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_19: "optNeg",
		token.T_24: "}",
	},
	// Object
	{
		token.EOF:  "$",
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// OptElem
	{
		token.T_3: "]",
	},
	// OptExp
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_6:  "block_comment",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_16: "line_comment",
		token.T_19: "optNeg",
		token.T_24: "}",
	},
	// OptFrac
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_6:  "block_comment",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_10: "escChar",
		token.T_12: "exp",
		token.T_16: "line_comment",
		token.T_19: "optNeg",
		token.T_24: "}",
	},
	// OptMems
	{
		token.T_24: "}",
	},
	// Pair
	{
		token.T_0:  ",",
		token.T_24: "}",
	},
	// RBRACE
	{
		token.EOF:  "$",
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// RBRACKET
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// RepChar0x
	{
		token.T_8: "dQuote",
	},
	// RepComPair0x
	{
		token.T_24: "}",
	},
	// RepComVal0x
	{
		token.T_3: "]",
	},
	// String
	{
		token.T_0:  ",",
		token.T_1:  ":",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// TRUE
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// Value
	{
		token.T_0:  ",",
		token.T_3:  "]",
		token.T_24: "}",
	},
	// WS
	{
		token.EOF:  "$",
		token.T_0:  ",",
		token.T_1:  ":",
		token.T_2:  "[",
		token.T_3:  "]",
		token.T_4:  "aA_fF",
		token.T_5:  "bSlash",
		token.T_7:  "char",
		token.T_8:  "dQuote",
		token.T_13: "false",
		token.T_18: "null",
		token.T_19: "optNeg",
		token.T_20: "true",
		token.T_23: "{",
		token.T_24: "}",
	},
}

/*** Errors ***/

/*
Error is returned by Parse at every point at which the parser fails to parse
a grammar production. For non-LL-1 grammars there will be an error for each
alternate attempted by the parser.

The errors are sorted in descending order of input position (index of token in
the stream of tokens).

Normally the error of interest is the one that has parsed the largest number of
tokens.
*/
type Error struct {
	// Index of token that caused the error.
	cI int

	// Grammar slot at which the error occured.
	Slot slot.Label

	// The token at which the error occurred.
	Token *token.Token

	// The line and column in the input text at which the error occurred
	Line, Column int

	// The tokens expected at the point where the error occurred
	Expected map[token.Type]string
}

func (pe *Error) String() string {
	w := new(bytes.Buffer)
	fmt.Fprintf(w, "Parse Error: %s I[%d]=%s at line %d col %d\n",
		pe.Slot, pe.cI, pe.Token, pe.Line, pe.Column)
	exp := []string{}
	for _, e := range pe.Expected {
		exp = append(exp, e)
	}
	fmt.Fprintf(w, "Expected one of: [%s]", strings.Join(exp, ","))
	return w.String()
}

func (p *parser) parseError(slot slot.Label, i int, expected map[token.Type]string) {
	pe := &Error{cI: i, Slot: slot, Token: p.lex.Tokens[i], Expected: expected}
	p.parseErrors = append(p.parseErrors, pe)
}

func (p *parser) sortParseErrors() {
	sort.Slice(p.parseErrors,
		func(i, j int) bool {
			return p.parseErrors[j].Token.Lext() < p.parseErrors[i].Token.Lext()
		})
	for _, pe := range p.parseErrors {
		pe.Line, pe.Column = p.lex.GetLineColumn(pe.Token.Lext())
	}
}

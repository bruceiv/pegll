// Package parser is generated by gogll. Do not edit.
package parser

import (
	"bytes"
	"fmt"
	"sort"
	"strings"

	"XML/lexer"
	"XML/parser/bsr"
	"XML/parser/slot"
	"XML/parser/symbols"
	"XML/token"
)

type parser struct {
	cI int

	R *descriptors
	U *descriptors

	popped   map[poppedNode]bool
	crf      map[clusterNode][]*crfNode
	crfNodes map[crfNode]*crfNode

	lex         *lexer.Lexer
	parseErrors []*Error

	bsrSet *bsr.Set
}

func newParser(l *lexer.Lexer) *parser {
	return &parser{
		cI:     0,
		lex:    l,
		R:      &descriptors{},
		U:      &descriptors{},
		popped: make(map[poppedNode]bool),
		crf: map[clusterNode][]*crfNode{
			{symbols.NT_Document, 0}: {},
		},
		crfNodes:    map[crfNode]*crfNode{},
		bsrSet:      bsr.New(symbols.NT_Document, l),
		parseErrors: nil,
	}
}

// Parse returns the BSR set containing the parse forest.
// If the parse was successfull []*Error is nil
func Parse(l *lexer.Lexer) (*bsr.Set, []*Error) {
	return newParser(l).parse()
}

func (p *parser) parse() (*bsr.Set, []*Error) {
	var L slot.Label
	m, cU := len(p.lex.Tokens)-1, 0
	p.ntAdd(symbols.NT_Document, 0)
	// p.DumpDescriptors()
	for !p.R.empty() {
		L, cU, p.cI = p.R.remove()

		// fmt.Println()
		// fmt.Printf("L:%s, cI:%d, I[p.cI]:%s, cU:%d\n", L, p.cI, p.lex.Tokens[p.cI], cU)
		// p.DumpDescriptors()

		switch L {
		case slot.ATT_VALUE0R0: // ATT_VALUE : ∙dubQu DubCondClose

			p.bsrSet.Add(slot.ATT_VALUE0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.ATT_VALUE0R1) {
				p.parseError(slot.ATT_VALUE0R1, p.cI, first[slot.ATT_VALUE0R1])
				break
			}

			p.call(slot.ATT_VALUE0R2, cU, p.cI)
		case slot.ATT_VALUE0R2: // ATT_VALUE : dubQu DubCondClose ∙

			p.rtn(symbols.NT_ATT_VALUE, cU, p.cI)
		case slot.ATT_VALUE1R0: // ATT_VALUE : ∙sinQu SinCondClose

			p.bsrSet.Add(slot.ATT_VALUE1R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.ATT_VALUE1R1) {
				p.parseError(slot.ATT_VALUE1R1, p.cI, first[slot.ATT_VALUE1R1])
				break
			}

			p.call(slot.ATT_VALUE1R2, cU, p.cI)
		case slot.ATT_VALUE1R2: // ATT_VALUE : sinQu SinCondClose ∙

			p.rtn(symbols.NT_ATT_VALUE, cU, p.cI)
		case slot.Attribute0R0: // Attribute : ∙NAME optSpaceEsc eq optSpaceEsc ATT_VALUE

			p.call(slot.Attribute0R1, cU, p.cI)
		case slot.Attribute0R1: // Attribute : NAME ∙optSpaceEsc eq optSpaceEsc ATT_VALUE

			if !p.testSelect(slot.Attribute0R1) {
				p.parseError(slot.Attribute0R1, p.cI, first[slot.Attribute0R1])
				break
			}

			p.bsrSet.Add(slot.Attribute0R2, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Attribute0R2) {
				p.parseError(slot.Attribute0R2, p.cI, first[slot.Attribute0R2])
				break
			}

			p.bsrSet.Add(slot.Attribute0R3, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Attribute0R3) {
				p.parseError(slot.Attribute0R3, p.cI, first[slot.Attribute0R3])
				break
			}

			p.bsrSet.Add(slot.Attribute0R4, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Attribute0R4) {
				p.parseError(slot.Attribute0R4, p.cI, first[slot.Attribute0R4])
				break
			}

			p.call(slot.Attribute0R5, cU, p.cI)
		case slot.Attribute0R5: // Attribute : NAME optSpaceEsc eq optSpaceEsc ATT_VALUE ∙

			p.rtn(symbols.NT_Attribute, cU, p.cI)
		case slot.CHAR_REF0R0: // CHAR_REF : ∙&#x Hex ;

			p.bsrSet.Add(slot.CHAR_REF0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.CHAR_REF0R1) {
				p.parseError(slot.CHAR_REF0R1, p.cI, first[slot.CHAR_REF0R1])
				break
			}

			p.call(slot.CHAR_REF0R2, cU, p.cI)
		case slot.CHAR_REF0R2: // CHAR_REF : &#x Hex ∙;

			if !p.testSelect(slot.CHAR_REF0R2) {
				p.parseError(slot.CHAR_REF0R2, p.cI, first[slot.CHAR_REF0R2])
				break
			}

			p.bsrSet.Add(slot.CHAR_REF0R3, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_CHAR_REF, cU, p.cI)
		case slot.CHAR_REF1R0: // CHAR_REF : ∙&# repNum1x ;

			p.bsrSet.Add(slot.CHAR_REF1R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.CHAR_REF1R1) {
				p.parseError(slot.CHAR_REF1R1, p.cI, first[slot.CHAR_REF1R1])
				break
			}

			p.bsrSet.Add(slot.CHAR_REF1R2, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.CHAR_REF1R2) {
				p.parseError(slot.CHAR_REF1R2, p.cI, first[slot.CHAR_REF1R2])
				break
			}

			p.bsrSet.Add(slot.CHAR_REF1R3, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_CHAR_REF, cU, p.cI)
		case slot.COMMENT0R0: // COMMENT : ∙ComStart ComEnterior angRBrk

			p.call(slot.COMMENT0R1, cU, p.cI)
		case slot.COMMENT0R1: // COMMENT : ComStart ∙ComEnterior angRBrk

			if !p.testSelect(slot.COMMENT0R1) {
				p.parseError(slot.COMMENT0R1, p.cI, first[slot.COMMENT0R1])
				break
			}

			p.call(slot.COMMENT0R2, cU, p.cI)
		case slot.COMMENT0R2: // COMMENT : ComStart ComEnterior ∙angRBrk

			if !p.testSelect(slot.COMMENT0R2) {
				p.parseError(slot.COMMENT0R2, p.cI, first[slot.COMMENT0R2])
				break
			}

			p.bsrSet.Add(slot.COMMENT0R3, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_COMMENT, cU, p.cI)
		case slot.ComEnterior0R0: // ComEnterior : ∙DubDash

			p.call(slot.ComEnterior0R1, cU, p.cI)
		case slot.ComEnterior0R1: // ComEnterior : DubDash ∙

			p.rtn(symbols.NT_ComEnterior, cU, p.cI)
		case slot.ComEnterior1R0: // ComEnterior : ∙let ComEnterior

			p.bsrSet.Add(slot.ComEnterior1R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.ComEnterior1R1) {
				p.parseError(slot.ComEnterior1R1, p.cI, first[slot.ComEnterior1R1])
				break
			}

			p.call(slot.ComEnterior1R2, cU, p.cI)
		case slot.ComEnterior1R2: // ComEnterior : let ComEnterior ∙

			p.rtn(symbols.NT_ComEnterior, cU, p.cI)
		case slot.ComStart0R0: // ComStart : ∙angLBrk exclamation DubDash

			p.bsrSet.Add(slot.ComStart0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.ComStart0R1) {
				p.parseError(slot.ComStart0R1, p.cI, first[slot.ComStart0R1])
				break
			}

			p.bsrSet.Add(slot.ComStart0R2, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.ComStart0R2) {
				p.parseError(slot.ComStart0R2, p.cI, first[slot.ComStart0R2])
				break
			}

			p.call(slot.ComStart0R3, cU, p.cI)
		case slot.ComStart0R3: // ComStart : angLBrk exclamation DubDash ∙

			p.rtn(symbols.NT_ComStart, cU, p.cI)
		case slot.Content0R0: // Content : ∙ContentAlts Content

			p.call(slot.Content0R1, cU, p.cI)
		case slot.Content0R1: // Content : ContentAlts ∙Content

			if !p.testSelect(slot.Content0R1) {
				p.parseError(slot.Content0R1, p.cI, first[slot.Content0R1])
				break
			}

			p.call(slot.Content0R2, cU, p.cI)
		case slot.Content0R2: // Content : ContentAlts Content ∙

			p.rtn(symbols.NT_Content, cU, p.cI)
		case slot.Content1R0: // Content : ∙
			p.bsrSet.AddEmpty(slot.Content1R0, p.cI)

			p.rtn(symbols.NT_Content, cU, p.cI)
		case slot.ContentAlts0R0: // ContentAlts : ∙COMMENT

			p.call(slot.ContentAlts0R1, cU, p.cI)
		case slot.ContentAlts0R1: // ContentAlts : COMMENT ∙

			p.rtn(symbols.NT_ContentAlts, cU, p.cI)
		case slot.ContentAlts1R0: // ContentAlts : ∙Element

			p.call(slot.ContentAlts1R1, cU, p.cI)
		case slot.ContentAlts1R1: // ContentAlts : Element ∙

			p.rtn(symbols.NT_ContentAlts, cU, p.cI)
		case slot.ContentAlts2R0: // ContentAlts : ∙REFERENCE

			p.call(slot.ContentAlts2R1, cU, p.cI)
		case slot.ContentAlts2R1: // ContentAlts : REFERENCE ∙

			p.rtn(symbols.NT_ContentAlts, cU, p.cI)
		case slot.ContentAlts3R0: // ContentAlts : ∙charData

			p.bsrSet.Add(slot.ContentAlts3R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_ContentAlts, cU, p.cI)
		case slot.Document0R0: // Document : ∙Prolog Element RepMisc0x

			p.call(slot.Document0R1, cU, p.cI)
		case slot.Document0R1: // Document : Prolog ∙Element RepMisc0x

			if !p.testSelect(slot.Document0R1) {
				p.parseError(slot.Document0R1, p.cI, first[slot.Document0R1])
				break
			}

			p.call(slot.Document0R2, cU, p.cI)
		case slot.Document0R2: // Document : Prolog Element ∙RepMisc0x

			if !p.testSelect(slot.Document0R2) {
				p.parseError(slot.Document0R2, p.cI, first[slot.Document0R2])
				break
			}

			p.call(slot.Document0R3, cU, p.cI)
		case slot.Document0R3: // Document : Prolog Element RepMisc0x ∙

			p.rtn(symbols.NT_Document, cU, p.cI)
		case slot.DubCondClose0R0: // DubCondClose : ∙dubQu

			p.bsrSet.Add(slot.DubCondClose0R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_DubCondClose, cU, p.cI)
		case slot.DubCondClose1R0: // DubCondClose : ∙SymRefAlts DubCondClose

			p.call(slot.DubCondClose1R1, cU, p.cI)
		case slot.DubCondClose1R1: // DubCondClose : SymRefAlts ∙DubCondClose

			if !p.testSelect(slot.DubCondClose1R1) {
				p.parseError(slot.DubCondClose1R1, p.cI, first[slot.DubCondClose1R1])
				break
			}

			p.call(slot.DubCondClose1R2, cU, p.cI)
		case slot.DubCondClose1R2: // DubCondClose : SymRefAlts DubCondClose ∙

			p.rtn(symbols.NT_DubCondClose, cU, p.cI)
		case slot.DubDash0R0: // DubDash : ∙--

			p.bsrSet.Add(slot.DubDash0R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_DubDash, cU, p.cI)
		case slot.ENTITY_REF0R0: // ENTITY_REF : ∙& NAME ;

			p.bsrSet.Add(slot.ENTITY_REF0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.ENTITY_REF0R1) {
				p.parseError(slot.ENTITY_REF0R1, p.cI, first[slot.ENTITY_REF0R1])
				break
			}

			p.call(slot.ENTITY_REF0R2, cU, p.cI)
		case slot.ENTITY_REF0R2: // ENTITY_REF : & NAME ∙;

			if !p.testSelect(slot.ENTITY_REF0R2) {
				p.parseError(slot.ENTITY_REF0R2, p.cI, first[slot.ENTITY_REF0R2])
				break
			}

			p.bsrSet.Add(slot.ENTITY_REF0R3, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_ENTITY_REF, cU, p.cI)
		case slot.ElemCloseAlts0R0: // ElemCloseAlts : ∙angRBrk Content slashAngLBrk NAME optSpaceEsc angRBrk

			p.bsrSet.Add(slot.ElemCloseAlts0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.ElemCloseAlts0R1) {
				p.parseError(slot.ElemCloseAlts0R1, p.cI, first[slot.ElemCloseAlts0R1])
				break
			}

			p.call(slot.ElemCloseAlts0R2, cU, p.cI)
		case slot.ElemCloseAlts0R2: // ElemCloseAlts : angRBrk Content ∙slashAngLBrk NAME optSpaceEsc angRBrk

			if !p.testSelect(slot.ElemCloseAlts0R2) {
				p.parseError(slot.ElemCloseAlts0R2, p.cI, first[slot.ElemCloseAlts0R2])
				break
			}

			p.bsrSet.Add(slot.ElemCloseAlts0R3, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.ElemCloseAlts0R3) {
				p.parseError(slot.ElemCloseAlts0R3, p.cI, first[slot.ElemCloseAlts0R3])
				break
			}

			p.call(slot.ElemCloseAlts0R4, cU, p.cI)
		case slot.ElemCloseAlts0R4: // ElemCloseAlts : angRBrk Content slashAngLBrk NAME ∙optSpaceEsc angRBrk

			if !p.testSelect(slot.ElemCloseAlts0R4) {
				p.parseError(slot.ElemCloseAlts0R4, p.cI, first[slot.ElemCloseAlts0R4])
				break
			}

			p.bsrSet.Add(slot.ElemCloseAlts0R5, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.ElemCloseAlts0R5) {
				p.parseError(slot.ElemCloseAlts0R5, p.cI, first[slot.ElemCloseAlts0R5])
				break
			}

			p.bsrSet.Add(slot.ElemCloseAlts0R6, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_ElemCloseAlts, cU, p.cI)
		case slot.ElemCloseAlts1R0: // ElemCloseAlts : ∙slashAngRBrk

			p.bsrSet.Add(slot.ElemCloseAlts1R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_ElemCloseAlts, cU, p.cI)
		case slot.Element0R0: // Element : ∙angLBrk NAME RepSAttx0x optSpaceEsc ElemCloseAlts

			p.bsrSet.Add(slot.Element0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Element0R1) {
				p.parseError(slot.Element0R1, p.cI, first[slot.Element0R1])
				break
			}

			p.call(slot.Element0R2, cU, p.cI)
		case slot.Element0R2: // Element : angLBrk NAME ∙RepSAttx0x optSpaceEsc ElemCloseAlts

			if !p.testSelect(slot.Element0R2) {
				p.parseError(slot.Element0R2, p.cI, first[slot.Element0R2])
				break
			}

			p.call(slot.Element0R3, cU, p.cI)
		case slot.Element0R3: // Element : angLBrk NAME RepSAttx0x ∙optSpaceEsc ElemCloseAlts

			if !p.testSelect(slot.Element0R3) {
				p.parseError(slot.Element0R3, p.cI, first[slot.Element0R3])
				break
			}

			p.bsrSet.Add(slot.Element0R4, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Element0R4) {
				p.parseError(slot.Element0R4, p.cI, first[slot.Element0R4])
				break
			}

			p.call(slot.Element0R5, cU, p.cI)
		case slot.Element0R5: // Element : angLBrk NAME RepSAttx0x optSpaceEsc ElemCloseAlts ∙

			p.rtn(symbols.NT_Element, cU, p.cI)
		case slot.EncName0R0: // EncName : ∙let RepLDSAlts0x

			p.bsrSet.Add(slot.EncName0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.EncName0R1) {
				p.parseError(slot.EncName0R1, p.cI, first[slot.EncName0R1])
				break
			}

			p.call(slot.EncName0R2, cU, p.cI)
		case slot.EncName0R2: // EncName : let RepLDSAlts0x ∙

			p.rtn(symbols.NT_EncName, cU, p.cI)
		case slot.EncodingDecl0R0: // EncodingDecl : ∙spaceEsc encoding Eq QuoEncNam

			p.bsrSet.Add(slot.EncodingDecl0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.EncodingDecl0R1) {
				p.parseError(slot.EncodingDecl0R1, p.cI, first[slot.EncodingDecl0R1])
				break
			}

			p.bsrSet.Add(slot.EncodingDecl0R2, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.EncodingDecl0R2) {
				p.parseError(slot.EncodingDecl0R2, p.cI, first[slot.EncodingDecl0R2])
				break
			}

			p.call(slot.EncodingDecl0R3, cU, p.cI)
		case slot.EncodingDecl0R3: // EncodingDecl : spaceEsc encoding Eq ∙QuoEncNam

			if !p.testSelect(slot.EncodingDecl0R3) {
				p.parseError(slot.EncodingDecl0R3, p.cI, first[slot.EncodingDecl0R3])
				break
			}

			p.call(slot.EncodingDecl0R4, cU, p.cI)
		case slot.EncodingDecl0R4: // EncodingDecl : spaceEsc encoding Eq QuoEncNam ∙

			p.rtn(symbols.NT_EncodingDecl, cU, p.cI)
		case slot.Eq0R0: // Eq : ∙optSpaceEsc eq optSpaceEsc

			p.bsrSet.Add(slot.Eq0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Eq0R1) {
				p.parseError(slot.Eq0R1, p.cI, first[slot.Eq0R1])
				break
			}

			p.bsrSet.Add(slot.Eq0R2, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Eq0R2) {
				p.parseError(slot.Eq0R2, p.cI, first[slot.Eq0R2])
				break
			}

			p.bsrSet.Add(slot.Eq0R3, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_Eq, cU, p.cI)
		case slot.Hex0R0: // Hex : ∙HexAlts RepHexAlts0x

			p.call(slot.Hex0R1, cU, p.cI)
		case slot.Hex0R1: // Hex : HexAlts ∙RepHexAlts0x

			if !p.testSelect(slot.Hex0R1) {
				p.parseError(slot.Hex0R1, p.cI, first[slot.Hex0R1])
				break
			}

			p.call(slot.Hex0R2, cU, p.cI)
		case slot.Hex0R2: // Hex : HexAlts RepHexAlts0x ∙

			p.rtn(symbols.NT_Hex, cU, p.cI)
		case slot.HexAlts0R0: // HexAlts : ∙num

			p.bsrSet.Add(slot.HexAlts0R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_HexAlts, cU, p.cI)
		case slot.HexAlts1R0: // HexAlts : ∙aA_fF

			p.bsrSet.Add(slot.HexAlts1R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_HexAlts, cU, p.cI)
		case slot.LetColonAlts0R0: // LetColonAlts : ∙let

			p.bsrSet.Add(slot.LetColonAlts0R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_LetColonAlts, cU, p.cI)
		case slot.LetColonAlts1R0: // LetColonAlts : ∙col_

			p.bsrSet.Add(slot.LetColonAlts1R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_LetColonAlts, cU, p.cI)
		case slot.LetDigSymAlts0R0: // LetDigSymAlts : ∙let

			p.bsrSet.Add(slot.LetDigSymAlts0R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_LetDigSymAlts, cU, p.cI)
		case slot.LetDigSymAlts1R0: // LetDigSymAlts : ∙num

			p.bsrSet.Add(slot.LetDigSymAlts1R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_LetDigSymAlts, cU, p.cI)
		case slot.LetDigSymAlts2R0: // LetDigSymAlts : ∙dot_BSlashDash

			p.bsrSet.Add(slot.LetDigSymAlts2R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_LetDigSymAlts, cU, p.cI)
		case slot.Misc0R0: // Misc : ∙COMMENT

			p.call(slot.Misc0R1, cU, p.cI)
		case slot.Misc0R1: // Misc : COMMENT ∙

			p.rtn(symbols.NT_Misc, cU, p.cI)
		case slot.Misc1R0: // Misc : ∙spaceEsc

			p.bsrSet.Add(slot.Misc1R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_Misc, cU, p.cI)
		case slot.NAME0R0: // NAME : ∙LetColonAlts RepNameChar0x

			p.call(slot.NAME0R1, cU, p.cI)
		case slot.NAME0R1: // NAME : LetColonAlts ∙RepNameChar0x

			if !p.testSelect(slot.NAME0R1) {
				p.parseError(slot.NAME0R1, p.cI, first[slot.NAME0R1])
				break
			}

			p.call(slot.NAME0R2, cU, p.cI)
		case slot.NAME0R2: // NAME : LetColonAlts RepNameChar0x ∙

			p.rtn(symbols.NT_NAME, cU, p.cI)
		case slot.NAME_CHAR0R0: // NAME_CHAR : ∙let

			p.bsrSet.Add(slot.NAME_CHAR0R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_NAME_CHAR, cU, p.cI)
		case slot.NAME_CHAR1R0: // NAME_CHAR : ∙num

			p.bsrSet.Add(slot.NAME_CHAR1R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_NAME_CHAR, cU, p.cI)
		case slot.NAME_CHAR2R0: // NAME_CHAR : ∙dot_BSlashDashCol

			p.bsrSet.Add(slot.NAME_CHAR2R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_NAME_CHAR, cU, p.cI)
		case slot.NameCharRep0R0: // NameCharRep : ∙NAME_CHAR NameCharRep

			p.call(slot.NameCharRep0R1, cU, p.cI)
		case slot.NameCharRep0R1: // NameCharRep : NAME_CHAR ∙NameCharRep

			if !p.testSelect(slot.NameCharRep0R1) {
				p.parseError(slot.NameCharRep0R1, p.cI, first[slot.NameCharRep0R1])
				break
			}

			p.call(slot.NameCharRep0R2, cU, p.cI)
		case slot.NameCharRep0R2: // NameCharRep : NAME_CHAR NameCharRep ∙

			p.rtn(symbols.NT_NameCharRep, cU, p.cI)
		case slot.NameCharRep1R0: // NameCharRep : ∙
			p.bsrSet.AddEmpty(slot.NameCharRep1R0, p.cI)

			p.rtn(symbols.NT_NameCharRep, cU, p.cI)
		case slot.OptEncodDecl0R0: // OptEncodDecl : ∙EncodingDecl

			p.call(slot.OptEncodDecl0R1, cU, p.cI)
		case slot.OptEncodDecl0R1: // OptEncodDecl : EncodingDecl ∙

			p.rtn(symbols.NT_OptEncodDecl, cU, p.cI)
		case slot.OptEncodDecl1R0: // OptEncodDecl : ∙
			p.bsrSet.AddEmpty(slot.OptEncodDecl1R0, p.cI)

			p.rtn(symbols.NT_OptEncodDecl, cU, p.cI)
		case slot.OptXMLDecl0R0: // OptXMLDecl : ∙XMLDecl

			p.call(slot.OptXMLDecl0R1, cU, p.cI)
		case slot.OptXMLDecl0R1: // OptXMLDecl : XMLDecl ∙

			p.rtn(symbols.NT_OptXMLDecl, cU, p.cI)
		case slot.OptXMLDecl1R0: // OptXMLDecl : ∙
			p.bsrSet.AddEmpty(slot.OptXMLDecl1R0, p.cI)

			p.rtn(symbols.NT_OptXMLDecl, cU, p.cI)
		case slot.Prolog0R0: // Prolog : ∙OptXMLDecl RepMisc0x

			p.call(slot.Prolog0R1, cU, p.cI)
		case slot.Prolog0R1: // Prolog : OptXMLDecl ∙RepMisc0x

			if !p.testSelect(slot.Prolog0R1) {
				p.parseError(slot.Prolog0R1, p.cI, first[slot.Prolog0R1])
				break
			}

			p.call(slot.Prolog0R2, cU, p.cI)
		case slot.Prolog0R2: // Prolog : OptXMLDecl RepMisc0x ∙

			p.rtn(symbols.NT_Prolog, cU, p.cI)
		case slot.QuoEncNam0R0: // QuoEncNam : ∙sinQu EncName sinQu

			p.bsrSet.Add(slot.QuoEncNam0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.QuoEncNam0R1) {
				p.parseError(slot.QuoEncNam0R1, p.cI, first[slot.QuoEncNam0R1])
				break
			}

			p.call(slot.QuoEncNam0R2, cU, p.cI)
		case slot.QuoEncNam0R2: // QuoEncNam : sinQu EncName ∙sinQu

			if !p.testSelect(slot.QuoEncNam0R2) {
				p.parseError(slot.QuoEncNam0R2, p.cI, first[slot.QuoEncNam0R2])
				break
			}

			p.bsrSet.Add(slot.QuoEncNam0R3, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_QuoEncNam, cU, p.cI)
		case slot.QuoEncNam1R0: // QuoEncNam : ∙dubQu EncName dubQu

			p.bsrSet.Add(slot.QuoEncNam1R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.QuoEncNam1R1) {
				p.parseError(slot.QuoEncNam1R1, p.cI, first[slot.QuoEncNam1R1])
				break
			}

			p.call(slot.QuoEncNam1R2, cU, p.cI)
		case slot.QuoEncNam1R2: // QuoEncNam : dubQu EncName ∙dubQu

			if !p.testSelect(slot.QuoEncNam1R2) {
				p.parseError(slot.QuoEncNam1R2, p.cI, first[slot.QuoEncNam1R2])
				break
			}

			p.bsrSet.Add(slot.QuoEncNam1R3, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_QuoEncNam, cU, p.cI)
		case slot.QuoVerNum0R0: // QuoVerNum : ∙sinQu VersionNum sinQu

			p.bsrSet.Add(slot.QuoVerNum0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.QuoVerNum0R1) {
				p.parseError(slot.QuoVerNum0R1, p.cI, first[slot.QuoVerNum0R1])
				break
			}

			p.call(slot.QuoVerNum0R2, cU, p.cI)
		case slot.QuoVerNum0R2: // QuoVerNum : sinQu VersionNum ∙sinQu

			if !p.testSelect(slot.QuoVerNum0R2) {
				p.parseError(slot.QuoVerNum0R2, p.cI, first[slot.QuoVerNum0R2])
				break
			}

			p.bsrSet.Add(slot.QuoVerNum0R3, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_QuoVerNum, cU, p.cI)
		case slot.QuoVerNum1R0: // QuoVerNum : ∙dubQu VersionNum dubQu

			p.bsrSet.Add(slot.QuoVerNum1R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.QuoVerNum1R1) {
				p.parseError(slot.QuoVerNum1R1, p.cI, first[slot.QuoVerNum1R1])
				break
			}

			p.call(slot.QuoVerNum1R2, cU, p.cI)
		case slot.QuoVerNum1R2: // QuoVerNum : dubQu VersionNum ∙dubQu

			if !p.testSelect(slot.QuoVerNum1R2) {
				p.parseError(slot.QuoVerNum1R2, p.cI, first[slot.QuoVerNum1R2])
				break
			}

			p.bsrSet.Add(slot.QuoVerNum1R3, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_QuoVerNum, cU, p.cI)
		case slot.REFERENCE0R0: // REFERENCE : ∙ENTITY_REF

			p.call(slot.REFERENCE0R1, cU, p.cI)
		case slot.REFERENCE0R1: // REFERENCE : ENTITY_REF ∙

			p.rtn(symbols.NT_REFERENCE, cU, p.cI)
		case slot.REFERENCE1R0: // REFERENCE : ∙CHAR_REF

			p.call(slot.REFERENCE1R1, cU, p.cI)
		case slot.REFERENCE1R1: // REFERENCE : CHAR_REF ∙

			p.rtn(symbols.NT_REFERENCE, cU, p.cI)
		case slot.RepHexAlts0x0R0: // RepHexAlts0x : ∙HexAlts Hex

			p.call(slot.RepHexAlts0x0R1, cU, p.cI)
		case slot.RepHexAlts0x0R1: // RepHexAlts0x : HexAlts ∙Hex

			if !p.testSelect(slot.RepHexAlts0x0R1) {
				p.parseError(slot.RepHexAlts0x0R1, p.cI, first[slot.RepHexAlts0x0R1])
				break
			}

			p.call(slot.RepHexAlts0x0R2, cU, p.cI)
		case slot.RepHexAlts0x0R2: // RepHexAlts0x : HexAlts Hex ∙

			p.rtn(symbols.NT_RepHexAlts0x, cU, p.cI)
		case slot.RepHexAlts0x1R0: // RepHexAlts0x : ∙
			p.bsrSet.AddEmpty(slot.RepHexAlts0x1R0, p.cI)

			p.rtn(symbols.NT_RepHexAlts0x, cU, p.cI)
		case slot.RepLDSAlts0x0R0: // RepLDSAlts0x : ∙LetDigSymAlts RepLDSAlts0x

			p.call(slot.RepLDSAlts0x0R1, cU, p.cI)
		case slot.RepLDSAlts0x0R1: // RepLDSAlts0x : LetDigSymAlts ∙RepLDSAlts0x

			if !p.testSelect(slot.RepLDSAlts0x0R1) {
				p.parseError(slot.RepLDSAlts0x0R1, p.cI, first[slot.RepLDSAlts0x0R1])
				break
			}

			p.call(slot.RepLDSAlts0x0R2, cU, p.cI)
		case slot.RepLDSAlts0x0R2: // RepLDSAlts0x : LetDigSymAlts RepLDSAlts0x ∙

			p.rtn(symbols.NT_RepLDSAlts0x, cU, p.cI)
		case slot.RepLDSAlts0x1R0: // RepLDSAlts0x : ∙
			p.bsrSet.AddEmpty(slot.RepLDSAlts0x1R0, p.cI)

			p.rtn(symbols.NT_RepLDSAlts0x, cU, p.cI)
		case slot.RepMisc0x0R0: // RepMisc0x : ∙Misc RepMisc0x

			p.call(slot.RepMisc0x0R1, cU, p.cI)
		case slot.RepMisc0x0R1: // RepMisc0x : Misc ∙RepMisc0x

			if !p.testSelect(slot.RepMisc0x0R1) {
				p.parseError(slot.RepMisc0x0R1, p.cI, first[slot.RepMisc0x0R1])
				break
			}

			p.call(slot.RepMisc0x0R2, cU, p.cI)
		case slot.RepMisc0x0R2: // RepMisc0x : Misc RepMisc0x ∙

			p.rtn(symbols.NT_RepMisc0x, cU, p.cI)
		case slot.RepMisc0x1R0: // RepMisc0x : ∙
			p.bsrSet.AddEmpty(slot.RepMisc0x1R0, p.cI)

			p.rtn(symbols.NT_RepMisc0x, cU, p.cI)
		case slot.RepNameChar0x0R0: // RepNameChar0x : ∙NAME_CHAR RepNameChar0x

			p.call(slot.RepNameChar0x0R1, cU, p.cI)
		case slot.RepNameChar0x0R1: // RepNameChar0x : NAME_CHAR ∙RepNameChar0x

			if !p.testSelect(slot.RepNameChar0x0R1) {
				p.parseError(slot.RepNameChar0x0R1, p.cI, first[slot.RepNameChar0x0R1])
				break
			}

			p.call(slot.RepNameChar0x0R2, cU, p.cI)
		case slot.RepNameChar0x0R2: // RepNameChar0x : NAME_CHAR RepNameChar0x ∙

			p.rtn(symbols.NT_RepNameChar0x, cU, p.cI)
		case slot.RepNameChar0x1R0: // RepNameChar0x : ∙
			p.bsrSet.AddEmpty(slot.RepNameChar0x1R0, p.cI)

			p.rtn(symbols.NT_RepNameChar0x, cU, p.cI)
		case slot.RepSAttx0x0R0: // RepSAttx0x : ∙SAtt RepSAttx0x

			p.call(slot.RepSAttx0x0R1, cU, p.cI)
		case slot.RepSAttx0x0R1: // RepSAttx0x : SAtt ∙RepSAttx0x

			if !p.testSelect(slot.RepSAttx0x0R1) {
				p.parseError(slot.RepSAttx0x0R1, p.cI, first[slot.RepSAttx0x0R1])
				break
			}

			p.call(slot.RepSAttx0x0R2, cU, p.cI)
		case slot.RepSAttx0x0R2: // RepSAttx0x : SAtt RepSAttx0x ∙

			p.rtn(symbols.NT_RepSAttx0x, cU, p.cI)
		case slot.RepSAttx0x1R0: // RepSAttx0x : ∙
			p.bsrSet.AddEmpty(slot.RepSAttx0x1R0, p.cI)

			p.rtn(symbols.NT_RepSAttx0x, cU, p.cI)
		case slot.SAtt0R0: // SAtt : ∙spaceEsc Attribute

			p.bsrSet.Add(slot.SAtt0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.SAtt0R1) {
				p.parseError(slot.SAtt0R1, p.cI, first[slot.SAtt0R1])
				break
			}

			p.call(slot.SAtt0R2, cU, p.cI)
		case slot.SAtt0R2: // SAtt : spaceEsc Attribute ∙

			p.rtn(symbols.NT_SAtt, cU, p.cI)
		case slot.SinCondClose0R0: // SinCondClose : ∙sinQu

			p.bsrSet.Add(slot.SinCondClose0R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_SinCondClose, cU, p.cI)
		case slot.SinCondClose1R0: // SinCondClose : ∙SymRefAlts SinCondClose

			p.call(slot.SinCondClose1R1, cU, p.cI)
		case slot.SinCondClose1R1: // SinCondClose : SymRefAlts ∙SinCondClose

			if !p.testSelect(slot.SinCondClose1R1) {
				p.parseError(slot.SinCondClose1R1, p.cI, first[slot.SinCondClose1R1])
				break
			}

			p.call(slot.SinCondClose1R2, cU, p.cI)
		case slot.SinCondClose1R2: // SinCondClose : SymRefAlts SinCondClose ∙

			p.rtn(symbols.NT_SinCondClose, cU, p.cI)
		case slot.SymRefAlts0R0: // SymRefAlts : ∙andCarrs

			p.bsrSet.Add(slot.SymRefAlts0R1, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_SymRefAlts, cU, p.cI)
		case slot.SymRefAlts1R0: // SymRefAlts : ∙REFERENCE

			p.call(slot.SymRefAlts1R1, cU, p.cI)
		case slot.SymRefAlts1R1: // SymRefAlts : REFERENCE ∙

			p.rtn(symbols.NT_SymRefAlts, cU, p.cI)
		case slot.VersionInfo0R0: // VersionInfo : ∙spaceEsc version Eq QuoVerNum

			p.bsrSet.Add(slot.VersionInfo0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.VersionInfo0R1) {
				p.parseError(slot.VersionInfo0R1, p.cI, first[slot.VersionInfo0R1])
				break
			}

			p.bsrSet.Add(slot.VersionInfo0R2, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.VersionInfo0R2) {
				p.parseError(slot.VersionInfo0R2, p.cI, first[slot.VersionInfo0R2])
				break
			}

			p.call(slot.VersionInfo0R3, cU, p.cI)
		case slot.VersionInfo0R3: // VersionInfo : spaceEsc version Eq ∙QuoVerNum

			if !p.testSelect(slot.VersionInfo0R3) {
				p.parseError(slot.VersionInfo0R3, p.cI, first[slot.VersionInfo0R3])
				break
			}

			p.call(slot.VersionInfo0R4, cU, p.cI)
		case slot.VersionInfo0R4: // VersionInfo : spaceEsc version Eq QuoVerNum ∙

			p.rtn(symbols.NT_VersionInfo, cU, p.cI)
		case slot.VersionNum0R0: // VersionNum : ∙NAME_CHAR NameCharRep

			p.call(slot.VersionNum0R1, cU, p.cI)
		case slot.VersionNum0R1: // VersionNum : NAME_CHAR ∙NameCharRep

			if !p.testSelect(slot.VersionNum0R1) {
				p.parseError(slot.VersionNum0R1, p.cI, first[slot.VersionNum0R1])
				break
			}

			p.call(slot.VersionNum0R2, cU, p.cI)
		case slot.VersionNum0R2: // VersionNum : NAME_CHAR NameCharRep ∙

			p.rtn(symbols.NT_VersionNum, cU, p.cI)
		case slot.XMLDecl0R0: // XMLDecl : ∙xmlDeclStart VersionInfo OptEncodDecl optSpaceEsc xmlDeclEnd

			p.bsrSet.Add(slot.XMLDecl0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.XMLDecl0R1) {
				p.parseError(slot.XMLDecl0R1, p.cI, first[slot.XMLDecl0R1])
				break
			}

			p.call(slot.XMLDecl0R2, cU, p.cI)
		case slot.XMLDecl0R2: // XMLDecl : xmlDeclStart VersionInfo ∙OptEncodDecl optSpaceEsc xmlDeclEnd

			if !p.testSelect(slot.XMLDecl0R2) {
				p.parseError(slot.XMLDecl0R2, p.cI, first[slot.XMLDecl0R2])
				break
			}

			p.call(slot.XMLDecl0R3, cU, p.cI)
		case slot.XMLDecl0R3: // XMLDecl : xmlDeclStart VersionInfo OptEncodDecl ∙optSpaceEsc xmlDeclEnd

			if !p.testSelect(slot.XMLDecl0R3) {
				p.parseError(slot.XMLDecl0R3, p.cI, first[slot.XMLDecl0R3])
				break
			}

			p.bsrSet.Add(slot.XMLDecl0R4, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.XMLDecl0R4) {
				p.parseError(slot.XMLDecl0R4, p.cI, first[slot.XMLDecl0R4])
				break
			}

			p.bsrSet.Add(slot.XMLDecl0R5, cU, p.cI, p.cI+1)
			p.cI++
			p.rtn(symbols.NT_XMLDecl, cU, p.cI)

		default:
			panic("This must not happen")
		}
	}
	if !p.bsrSet.Contain(symbols.NT_Document, 0, m) {
		p.sortParseErrors()
		return nil, p.parseErrors
	}
	return p.bsrSet, nil
}

func (p *parser) ntAdd(nt symbols.NT, j int) {
	// fmt.Printf("p.ntAdd(%s, %d)\n", nt, j)
	failed := true
	expected := map[token.Type]string{}
	for _, l := range slot.GetAlternates(nt) {
		if p.testSelect(l) {
			p.dscAdd(l, j, j)
			failed = false
		} else {
			for k, v := range first[l] {
				expected[k] = v
			}
		}
	}
	if failed {
		for _, l := range slot.GetAlternates(nt) {
			p.parseError(l, j, expected)
		}
	}
}

/*** Call Return Forest ***/

type poppedNode struct {
	X    symbols.NT
	k, j int
}

type clusterNode struct {
	X symbols.NT
	k int
}

type crfNode struct {
	L slot.Label
	i int
}

/*
suppose that L is Y ::=αX ·β
if there is no CRF node labelled (L,i)
	create one let u be the CRF node labelled (L,i)
if there is no CRF node labelled (X, j) {
	create a CRF node v labelled (X, j)
	create an edge from v to u
	ntAdd(X, j)
} else {
	let v be the CRF node labelled (X, j)
	if there is not an edge from v to u {
		create an edge from v to u
		for all ((X, j,h)∈P) {
			dscAdd(L, i, h);
			bsrAdd(L, i, j, h)
		}
	}
}
*/
func (p *parser) call(L slot.Label, i, j int) {
	// fmt.Printf("p.call(%s,%d,%d)\n", L,i,j)
	u, exist := p.crfNodes[crfNode{L, i}]
	// fmt.Printf("  u exist=%t\n", exist)
	if !exist {
		u = &crfNode{L, i}
		p.crfNodes[*u] = u
	}
	X := L.Symbols()[L.Pos()-1].(symbols.NT)
	ndV := clusterNode{X, j}
	v, exist := p.crf[ndV]
	if !exist {
		// fmt.Println("  v !exist")
		p.crf[ndV] = []*crfNode{u}
		p.ntAdd(X, j)
	} else {
		// fmt.Println("  v exist")
		if !existEdge(v, u) {
			// fmt.Printf("  !existEdge(%v)\n", u)
			p.crf[ndV] = append(v, u)
			// fmt.Printf("|popped|=%d\n", len(popped))
			for pnd := range p.popped {
				if pnd.X == X && pnd.k == j {
					p.dscAdd(L, i, pnd.j)
					p.bsrSet.Add(L, i, j, pnd.j)
				}
			}
		}
	}
}

func existEdge(nds []*crfNode, nd *crfNode) bool {
	for _, nd1 := range nds {
		if nd1 == nd {
			return true
		}
	}
	return false
}

func (p *parser) rtn(X symbols.NT, k, j int) {
	// fmt.Printf("p.rtn(%s,%d,%d)\n", X,k,j)
	pn := poppedNode{X, k, j}
	if _, exist := p.popped[pn]; !exist {
		p.popped[pn] = true
		for _, nd := range p.crf[clusterNode{X, k}] {
			p.dscAdd(nd.L, nd.i, j)
			p.bsrSet.Add(nd.L, nd.i, k, j)
		}
	}
}

// func CRFString() string {
// 	buf := new(bytes.Buffer)
// 	buf.WriteString("CRF: {")
// 	for cn, nds := range crf{
// 		for _, nd := range nds {
// 			fmt.Fprintf(buf, "%s->%s, ", cn, nd)
// 		}
// 	}
// 	buf.WriteString("}")
// 	return buf.String()
// }

func (cn clusterNode) String() string {
	return fmt.Sprintf("(%s,%d)", cn.X, cn.k)
}

func (n crfNode) String() string {
	return fmt.Sprintf("(%s,%d)", n.L.String(), n.i)
}

// func PoppedString() string {
// 	buf := new(bytes.Buffer)
// 	buf.WriteString("Popped: {")
// 	for p, _ := range popped {
// 		fmt.Fprintf(buf, "(%s,%d,%d) ", p.X, p.k, p.j)
// 	}
// 	buf.WriteString("}")
// 	return buf.String()
// }

/*** descriptors ***/

type descriptors struct {
	set []*descriptor
}

func (ds *descriptors) contain(d *descriptor) bool {
	for _, d1 := range ds.set {
		if d1 == d {
			return true
		}
	}
	return false
}

func (ds *descriptors) empty() bool {
	return len(ds.set) == 0
}

func (ds *descriptors) String() string {
	buf := new(bytes.Buffer)
	buf.WriteString("{")
	for i, d := range ds.set {
		if i > 0 {
			buf.WriteString("; ")
		}
		fmt.Fprintf(buf, "%s", d)
	}
	buf.WriteString("}")
	return buf.String()
}

type descriptor struct {
	L slot.Label
	k int
	i int
}

func (d *descriptor) String() string {
	return fmt.Sprintf("%s,%d,%d", d.L, d.k, d.i)
}

func (p *parser) dscAdd(L slot.Label, k, i int) {
	// fmt.Printf("p.dscAdd(%s,%d,%d)\n", L, k, i)
	d := &descriptor{L, k, i}
	if !p.U.contain(d) {
		p.R.set = append(p.R.set, d)
		p.U.set = append(p.U.set, d)
	}
}

func (ds *descriptors) remove() (L slot.Label, k, i int) {
	d := ds.set[len(ds.set)-1]
	ds.set = ds.set[:len(ds.set)-1]
	// fmt.Printf("remove: %s,%d,%d\n", d.L, d.k, d.i)
	return d.L, d.k, d.i
}

func (p *parser) DumpDescriptors() {
	p.DumpR()
	p.DumpU()
}

func (p *parser) DumpR() {
	fmt.Println("R:")
	for _, d := range p.R.set {
		fmt.Printf(" %s\n", d)
	}
}

func (p *parser) DumpU() {
	fmt.Println("U:")
	for _, d := range p.U.set {
		fmt.Printf(" %s\n", d)
	}
}

/*** TestSelect ***/

func (p *parser) follow(nt symbols.NT) bool {
	_, exist := followSets[nt][p.lex.Tokens[p.cI].Type()]
	return exist
}

func (p *parser) testSelect(l slot.Label) bool {
	return l.IsNullable() || l.FirstContains(p.lex.Tokens[p.cI].Type())
	// _, exist := first[l][p.lex.Tokens[p.cI].Type()]
	// return exist
}

var first = []map[token.Type]string{
	// ATT_VALUE : ∙dubQu DubCondClose
	{
		token.T_13: "dubQu",
	},
	// ATT_VALUE : dubQu ∙DubCondClose
	{
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_6:  "andCarrs",
		token.T_13: "dubQu",
	},
	// ATT_VALUE : dubQu DubCondClose ∙
	{
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// ATT_VALUE : ∙sinQu SinCondClose
	{
		token.T_21: "sinQu",
	},
	// ATT_VALUE : sinQu ∙SinCondClose
	{
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_6:  "andCarrs",
		token.T_21: "sinQu",
	},
	// ATT_VALUE : sinQu SinCondClose ∙
	{
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// Attribute : ∙NAME optSpaceEsc eq optSpaceEsc ATT_VALUE
	{
		token.T_10: "col_",
		token.T_17: "let",
	},
	// Attribute : NAME ∙optSpaceEsc eq optSpaceEsc ATT_VALUE
	{
		token.T_19: "optSpaceEsc",
	},
	// Attribute : NAME optSpaceEsc ∙eq optSpaceEsc ATT_VALUE
	{
		token.T_15: "eq",
	},
	// Attribute : NAME optSpaceEsc eq ∙optSpaceEsc ATT_VALUE
	{
		token.T_19: "optSpaceEsc",
	},
	// Attribute : NAME optSpaceEsc eq optSpaceEsc ∙ATT_VALUE
	{
		token.T_13: "dubQu",
		token.T_21: "sinQu",
	},
	// Attribute : NAME optSpaceEsc eq optSpaceEsc ATT_VALUE ∙
	{
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// CHAR_REF : ∙&#x Hex ;
	{
		token.T_2: "&#x",
	},
	// CHAR_REF : &#x ∙Hex ;
	{
		token.T_5:  "aA_fF",
		token.T_18: "num",
	},
	// CHAR_REF : &#x Hex ∙;
	{
		token.T_4: ";",
	},
	// CHAR_REF : &#x Hex ; ∙
	{
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_6:  "andCarrs",
		token.T_7:  "angLBrk",
		token.T_9:  "charData",
		token.T_13: "dubQu",
		token.T_21: "sinQu",
		token.T_22: "slashAngLBrk",
	},
	// CHAR_REF : ∙&# repNum1x ;
	{
		token.T_1: "&#",
	},
	// CHAR_REF : &# ∙repNum1x ;
	{
		token.T_20: "repNum1x",
	},
	// CHAR_REF : &# repNum1x ∙;
	{
		token.T_4: ";",
	},
	// CHAR_REF : &# repNum1x ; ∙
	{
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_6:  "andCarrs",
		token.T_7:  "angLBrk",
		token.T_9:  "charData",
		token.T_13: "dubQu",
		token.T_21: "sinQu",
		token.T_22: "slashAngLBrk",
	},
	// COMMENT : ∙ComStart ComEnterior angRBrk
	{
		token.T_7: "angLBrk",
	},
	// COMMENT : ComStart ∙ComEnterior angRBrk
	{
		token.T_3:  "--",
		token.T_17: "let",
	},
	// COMMENT : ComStart ComEnterior ∙angRBrk
	{
		token.T_8: "angRBrk",
	},
	// COMMENT : ComStart ComEnterior angRBrk ∙
	{
		token.EOF:  "$",
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_7:  "angLBrk",
		token.T_9:  "charData",
		token.T_22: "slashAngLBrk",
		token.T_24: "spaceEsc",
	},
	// ComEnterior : ∙DubDash
	{
		token.T_3: "--",
	},
	// ComEnterior : DubDash ∙
	{
		token.T_8: "angRBrk",
	},
	// ComEnterior : ∙let ComEnterior
	{
		token.T_17: "let",
	},
	// ComEnterior : let ∙ComEnterior
	{
		token.T_3:  "--",
		token.T_17: "let",
	},
	// ComEnterior : let ComEnterior ∙
	{
		token.T_8: "angRBrk",
	},
	// ComStart : ∙angLBrk exclamation DubDash
	{
		token.T_7: "angLBrk",
	},
	// ComStart : angLBrk ∙exclamation DubDash
	{
		token.T_16: "exclamation",
	},
	// ComStart : angLBrk exclamation ∙DubDash
	{
		token.T_3: "--",
	},
	// ComStart : angLBrk exclamation DubDash ∙
	{
		token.T_3:  "--",
		token.T_17: "let",
	},
	// Content : ∙ContentAlts Content
	{
		token.T_0: "&",
		token.T_1: "&#",
		token.T_2: "&#x",
		token.T_7: "angLBrk",
		token.T_9: "charData",
	},
	// Content : ContentAlts ∙Content
	{
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_7:  "angLBrk",
		token.T_9:  "charData",
		token.T_22: "slashAngLBrk",
	},
	// Content : ContentAlts Content ∙
	{
		token.T_22: "slashAngLBrk",
	},
	// Content : ∙
	{
		token.T_22: "slashAngLBrk",
	},
	// ContentAlts : ∙COMMENT
	{
		token.T_7: "angLBrk",
	},
	// ContentAlts : COMMENT ∙
	{
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_7:  "angLBrk",
		token.T_9:  "charData",
		token.T_22: "slashAngLBrk",
	},
	// ContentAlts : ∙Element
	{
		token.T_7: "angLBrk",
	},
	// ContentAlts : Element ∙
	{
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_7:  "angLBrk",
		token.T_9:  "charData",
		token.T_22: "slashAngLBrk",
	},
	// ContentAlts : ∙REFERENCE
	{
		token.T_0: "&",
		token.T_1: "&#",
		token.T_2: "&#x",
	},
	// ContentAlts : REFERENCE ∙
	{
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_7:  "angLBrk",
		token.T_9:  "charData",
		token.T_22: "slashAngLBrk",
	},
	// ContentAlts : ∙charData
	{
		token.T_9: "charData",
	},
	// ContentAlts : charData ∙
	{
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_7:  "angLBrk",
		token.T_9:  "charData",
		token.T_22: "slashAngLBrk",
	},
	// Document : ∙Prolog Element RepMisc0x
	{
		token.T_7:  "angLBrk",
		token.T_24: "spaceEsc",
		token.T_27: "xmlDeclStart",
	},
	// Document : Prolog ∙Element RepMisc0x
	{
		token.T_7: "angLBrk",
	},
	// Document : Prolog Element ∙RepMisc0x
	{
		token.EOF:  "$",
		token.T_7:  "angLBrk",
		token.T_24: "spaceEsc",
	},
	// Document : Prolog Element RepMisc0x ∙
	{
		token.EOF: "$",
	},
	// DubCondClose : ∙dubQu
	{
		token.T_13: "dubQu",
	},
	// DubCondClose : dubQu ∙
	{
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// DubCondClose : ∙SymRefAlts DubCondClose
	{
		token.T_0: "&",
		token.T_1: "&#",
		token.T_2: "&#x",
		token.T_6: "andCarrs",
	},
	// DubCondClose : SymRefAlts ∙DubCondClose
	{
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_6:  "andCarrs",
		token.T_13: "dubQu",
	},
	// DubCondClose : SymRefAlts DubCondClose ∙
	{
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// DubDash : ∙--
	{
		token.T_3: "--",
	},
	// DubDash : -- ∙
	{
		token.T_3:  "--",
		token.T_8:  "angRBrk",
		token.T_17: "let",
	},
	// ENTITY_REF : ∙& NAME ;
	{
		token.T_0: "&",
	},
	// ENTITY_REF : & ∙NAME ;
	{
		token.T_10: "col_",
		token.T_17: "let",
	},
	// ENTITY_REF : & NAME ∙;
	{
		token.T_4: ";",
	},
	// ENTITY_REF : & NAME ; ∙
	{
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_6:  "andCarrs",
		token.T_7:  "angLBrk",
		token.T_9:  "charData",
		token.T_13: "dubQu",
		token.T_21: "sinQu",
		token.T_22: "slashAngLBrk",
	},
	// ElemCloseAlts : ∙angRBrk Content slashAngLBrk NAME optSpaceEsc angRBrk
	{
		token.T_8: "angRBrk",
	},
	// ElemCloseAlts : angRBrk ∙Content slashAngLBrk NAME optSpaceEsc angRBrk
	{
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_7:  "angLBrk",
		token.T_9:  "charData",
		token.T_22: "slashAngLBrk",
	},
	// ElemCloseAlts : angRBrk Content ∙slashAngLBrk NAME optSpaceEsc angRBrk
	{
		token.T_22: "slashAngLBrk",
	},
	// ElemCloseAlts : angRBrk Content slashAngLBrk ∙NAME optSpaceEsc angRBrk
	{
		token.T_10: "col_",
		token.T_17: "let",
	},
	// ElemCloseAlts : angRBrk Content slashAngLBrk NAME ∙optSpaceEsc angRBrk
	{
		token.T_19: "optSpaceEsc",
	},
	// ElemCloseAlts : angRBrk Content slashAngLBrk NAME optSpaceEsc ∙angRBrk
	{
		token.T_8: "angRBrk",
	},
	// ElemCloseAlts : angRBrk Content slashAngLBrk NAME optSpaceEsc angRBrk ∙
	{
		token.EOF:  "$",
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_7:  "angLBrk",
		token.T_9:  "charData",
		token.T_22: "slashAngLBrk",
		token.T_24: "spaceEsc",
	},
	// ElemCloseAlts : ∙slashAngRBrk
	{
		token.T_23: "slashAngRBrk",
	},
	// ElemCloseAlts : slashAngRBrk ∙
	{
		token.EOF:  "$",
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_7:  "angLBrk",
		token.T_9:  "charData",
		token.T_22: "slashAngLBrk",
		token.T_24: "spaceEsc",
	},
	// Element : ∙angLBrk NAME RepSAttx0x optSpaceEsc ElemCloseAlts
	{
		token.T_7: "angLBrk",
	},
	// Element : angLBrk ∙NAME RepSAttx0x optSpaceEsc ElemCloseAlts
	{
		token.T_10: "col_",
		token.T_17: "let",
	},
	// Element : angLBrk NAME ∙RepSAttx0x optSpaceEsc ElemCloseAlts
	{
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// Element : angLBrk NAME RepSAttx0x ∙optSpaceEsc ElemCloseAlts
	{
		token.T_19: "optSpaceEsc",
	},
	// Element : angLBrk NAME RepSAttx0x optSpaceEsc ∙ElemCloseAlts
	{
		token.T_8:  "angRBrk",
		token.T_23: "slashAngRBrk",
	},
	// Element : angLBrk NAME RepSAttx0x optSpaceEsc ElemCloseAlts ∙
	{
		token.EOF:  "$",
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_7:  "angLBrk",
		token.T_9:  "charData",
		token.T_22: "slashAngLBrk",
		token.T_24: "spaceEsc",
	},
	// EncName : ∙let RepLDSAlts0x
	{
		token.T_17: "let",
	},
	// EncName : let ∙RepLDSAlts0x
	{
		token.T_11: "dot_BSlashDash",
		token.T_13: "dubQu",
		token.T_17: "let",
		token.T_18: "num",
		token.T_21: "sinQu",
	},
	// EncName : let RepLDSAlts0x ∙
	{
		token.T_13: "dubQu",
		token.T_21: "sinQu",
	},
	// EncodingDecl : ∙spaceEsc encoding Eq QuoEncNam
	{
		token.T_24: "spaceEsc",
	},
	// EncodingDecl : spaceEsc ∙encoding Eq QuoEncNam
	{
		token.T_14: "encoding",
	},
	// EncodingDecl : spaceEsc encoding ∙Eq QuoEncNam
	{
		token.T_19: "optSpaceEsc",
	},
	// EncodingDecl : spaceEsc encoding Eq ∙QuoEncNam
	{
		token.T_13: "dubQu",
		token.T_21: "sinQu",
	},
	// EncodingDecl : spaceEsc encoding Eq QuoEncNam ∙
	{
		token.T_19: "optSpaceEsc",
	},
	// Eq : ∙optSpaceEsc eq optSpaceEsc
	{
		token.T_19: "optSpaceEsc",
	},
	// Eq : optSpaceEsc ∙eq optSpaceEsc
	{
		token.T_15: "eq",
	},
	// Eq : optSpaceEsc eq ∙optSpaceEsc
	{
		token.T_19: "optSpaceEsc",
	},
	// Eq : optSpaceEsc eq optSpaceEsc ∙
	{
		token.T_13: "dubQu",
		token.T_21: "sinQu",
	},
	// Hex : ∙HexAlts RepHexAlts0x
	{
		token.T_5:  "aA_fF",
		token.T_18: "num",
	},
	// Hex : HexAlts ∙RepHexAlts0x
	{
		token.T_4:  ";",
		token.T_5:  "aA_fF",
		token.T_18: "num",
	},
	// Hex : HexAlts RepHexAlts0x ∙
	{
		token.T_4: ";",
	},
	// HexAlts : ∙num
	{
		token.T_18: "num",
	},
	// HexAlts : num ∙
	{
		token.T_4:  ";",
		token.T_5:  "aA_fF",
		token.T_18: "num",
	},
	// HexAlts : ∙aA_fF
	{
		token.T_5: "aA_fF",
	},
	// HexAlts : aA_fF ∙
	{
		token.T_4:  ";",
		token.T_5:  "aA_fF",
		token.T_18: "num",
	},
	// LetColonAlts : ∙let
	{
		token.T_17: "let",
	},
	// LetColonAlts : let ∙
	{
		token.T_4:  ";",
		token.T_12: "dot_BSlashDashCol",
		token.T_17: "let",
		token.T_18: "num",
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// LetColonAlts : ∙col_
	{
		token.T_10: "col_",
	},
	// LetColonAlts : col_ ∙
	{
		token.T_4:  ";",
		token.T_12: "dot_BSlashDashCol",
		token.T_17: "let",
		token.T_18: "num",
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// LetDigSymAlts : ∙let
	{
		token.T_17: "let",
	},
	// LetDigSymAlts : let ∙
	{
		token.T_11: "dot_BSlashDash",
		token.T_13: "dubQu",
		token.T_17: "let",
		token.T_18: "num",
		token.T_21: "sinQu",
	},
	// LetDigSymAlts : ∙num
	{
		token.T_18: "num",
	},
	// LetDigSymAlts : num ∙
	{
		token.T_11: "dot_BSlashDash",
		token.T_13: "dubQu",
		token.T_17: "let",
		token.T_18: "num",
		token.T_21: "sinQu",
	},
	// LetDigSymAlts : ∙dot_BSlashDash
	{
		token.T_11: "dot_BSlashDash",
	},
	// LetDigSymAlts : dot_BSlashDash ∙
	{
		token.T_11: "dot_BSlashDash",
		token.T_13: "dubQu",
		token.T_17: "let",
		token.T_18: "num",
		token.T_21: "sinQu",
	},
	// Misc : ∙COMMENT
	{
		token.T_7: "angLBrk",
	},
	// Misc : COMMENT ∙
	{
		token.EOF:  "$",
		token.T_7:  "angLBrk",
		token.T_24: "spaceEsc",
	},
	// Misc : ∙spaceEsc
	{
		token.T_24: "spaceEsc",
	},
	// Misc : spaceEsc ∙
	{
		token.EOF:  "$",
		token.T_7:  "angLBrk",
		token.T_24: "spaceEsc",
	},
	// NAME : ∙LetColonAlts RepNameChar0x
	{
		token.T_10: "col_",
		token.T_17: "let",
	},
	// NAME : LetColonAlts ∙RepNameChar0x
	{
		token.T_4:  ";",
		token.T_12: "dot_BSlashDashCol",
		token.T_17: "let",
		token.T_18: "num",
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// NAME : LetColonAlts RepNameChar0x ∙
	{
		token.T_4:  ";",
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// NAME_CHAR : ∙let
	{
		token.T_17: "let",
	},
	// NAME_CHAR : let ∙
	{
		token.T_4:  ";",
		token.T_12: "dot_BSlashDashCol",
		token.T_13: "dubQu",
		token.T_17: "let",
		token.T_18: "num",
		token.T_19: "optSpaceEsc",
		token.T_21: "sinQu",
		token.T_24: "spaceEsc",
	},
	// NAME_CHAR : ∙num
	{
		token.T_18: "num",
	},
	// NAME_CHAR : num ∙
	{
		token.T_4:  ";",
		token.T_12: "dot_BSlashDashCol",
		token.T_13: "dubQu",
		token.T_17: "let",
		token.T_18: "num",
		token.T_19: "optSpaceEsc",
		token.T_21: "sinQu",
		token.T_24: "spaceEsc",
	},
	// NAME_CHAR : ∙dot_BSlashDashCol
	{
		token.T_12: "dot_BSlashDashCol",
	},
	// NAME_CHAR : dot_BSlashDashCol ∙
	{
		token.T_4:  ";",
		token.T_12: "dot_BSlashDashCol",
		token.T_13: "dubQu",
		token.T_17: "let",
		token.T_18: "num",
		token.T_19: "optSpaceEsc",
		token.T_21: "sinQu",
		token.T_24: "spaceEsc",
	},
	// NameCharRep : ∙NAME_CHAR NameCharRep
	{
		token.T_12: "dot_BSlashDashCol",
		token.T_17: "let",
		token.T_18: "num",
	},
	// NameCharRep : NAME_CHAR ∙NameCharRep
	{
		token.T_12: "dot_BSlashDashCol",
		token.T_13: "dubQu",
		token.T_17: "let",
		token.T_18: "num",
		token.T_21: "sinQu",
	},
	// NameCharRep : NAME_CHAR NameCharRep ∙
	{
		token.T_13: "dubQu",
		token.T_21: "sinQu",
	},
	// NameCharRep : ∙
	{
		token.T_13: "dubQu",
		token.T_21: "sinQu",
	},
	// OptEncodDecl : ∙EncodingDecl
	{
		token.T_24: "spaceEsc",
	},
	// OptEncodDecl : EncodingDecl ∙
	{
		token.T_19: "optSpaceEsc",
	},
	// OptEncodDecl : ∙
	{
		token.T_19: "optSpaceEsc",
	},
	// OptXMLDecl : ∙XMLDecl
	{
		token.T_27: "xmlDeclStart",
	},
	// OptXMLDecl : XMLDecl ∙
	{
		token.T_7:  "angLBrk",
		token.T_24: "spaceEsc",
	},
	// OptXMLDecl : ∙
	{
		token.T_7:  "angLBrk",
		token.T_24: "spaceEsc",
	},
	// Prolog : ∙OptXMLDecl RepMisc0x
	{
		token.T_7:  "angLBrk",
		token.T_24: "spaceEsc",
		token.T_27: "xmlDeclStart",
	},
	// Prolog : OptXMLDecl ∙RepMisc0x
	{
		token.T_7:  "angLBrk",
		token.T_24: "spaceEsc",
	},
	// Prolog : OptXMLDecl RepMisc0x ∙
	{
		token.T_7: "angLBrk",
	},
	// QuoEncNam : ∙sinQu EncName sinQu
	{
		token.T_21: "sinQu",
	},
	// QuoEncNam : sinQu ∙EncName sinQu
	{
		token.T_17: "let",
	},
	// QuoEncNam : sinQu EncName ∙sinQu
	{
		token.T_21: "sinQu",
	},
	// QuoEncNam : sinQu EncName sinQu ∙
	{
		token.T_19: "optSpaceEsc",
	},
	// QuoEncNam : ∙dubQu EncName dubQu
	{
		token.T_13: "dubQu",
	},
	// QuoEncNam : dubQu ∙EncName dubQu
	{
		token.T_17: "let",
	},
	// QuoEncNam : dubQu EncName ∙dubQu
	{
		token.T_13: "dubQu",
	},
	// QuoEncNam : dubQu EncName dubQu ∙
	{
		token.T_19: "optSpaceEsc",
	},
	// QuoVerNum : ∙sinQu VersionNum sinQu
	{
		token.T_21: "sinQu",
	},
	// QuoVerNum : sinQu ∙VersionNum sinQu
	{
		token.T_12: "dot_BSlashDashCol",
		token.T_17: "let",
		token.T_18: "num",
	},
	// QuoVerNum : sinQu VersionNum ∙sinQu
	{
		token.T_21: "sinQu",
	},
	// QuoVerNum : sinQu VersionNum sinQu ∙
	{
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// QuoVerNum : ∙dubQu VersionNum dubQu
	{
		token.T_13: "dubQu",
	},
	// QuoVerNum : dubQu ∙VersionNum dubQu
	{
		token.T_12: "dot_BSlashDashCol",
		token.T_17: "let",
		token.T_18: "num",
	},
	// QuoVerNum : dubQu VersionNum ∙dubQu
	{
		token.T_13: "dubQu",
	},
	// QuoVerNum : dubQu VersionNum dubQu ∙
	{
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// REFERENCE : ∙ENTITY_REF
	{
		token.T_0: "&",
	},
	// REFERENCE : ENTITY_REF ∙
	{
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_6:  "andCarrs",
		token.T_7:  "angLBrk",
		token.T_9:  "charData",
		token.T_13: "dubQu",
		token.T_21: "sinQu",
		token.T_22: "slashAngLBrk",
	},
	// REFERENCE : ∙CHAR_REF
	{
		token.T_1: "&#",
		token.T_2: "&#x",
	},
	// REFERENCE : CHAR_REF ∙
	{
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_6:  "andCarrs",
		token.T_7:  "angLBrk",
		token.T_9:  "charData",
		token.T_13: "dubQu",
		token.T_21: "sinQu",
		token.T_22: "slashAngLBrk",
	},
	// RepHexAlts0x : ∙HexAlts Hex
	{
		token.T_5:  "aA_fF",
		token.T_18: "num",
	},
	// RepHexAlts0x : HexAlts ∙Hex
	{
		token.T_5:  "aA_fF",
		token.T_18: "num",
	},
	// RepHexAlts0x : HexAlts Hex ∙
	{
		token.T_4: ";",
	},
	// RepHexAlts0x : ∙
	{
		token.T_4: ";",
	},
	// RepLDSAlts0x : ∙LetDigSymAlts RepLDSAlts0x
	{
		token.T_11: "dot_BSlashDash",
		token.T_17: "let",
		token.T_18: "num",
	},
	// RepLDSAlts0x : LetDigSymAlts ∙RepLDSAlts0x
	{
		token.T_11: "dot_BSlashDash",
		token.T_13: "dubQu",
		token.T_17: "let",
		token.T_18: "num",
		token.T_21: "sinQu",
	},
	// RepLDSAlts0x : LetDigSymAlts RepLDSAlts0x ∙
	{
		token.T_13: "dubQu",
		token.T_21: "sinQu",
	},
	// RepLDSAlts0x : ∙
	{
		token.T_13: "dubQu",
		token.T_21: "sinQu",
	},
	// RepMisc0x : ∙Misc RepMisc0x
	{
		token.T_7:  "angLBrk",
		token.T_24: "spaceEsc",
	},
	// RepMisc0x : Misc ∙RepMisc0x
	{
		token.EOF:  "$",
		token.T_7:  "angLBrk",
		token.T_24: "spaceEsc",
	},
	// RepMisc0x : Misc RepMisc0x ∙
	{
		token.EOF: "$",
		token.T_7: "angLBrk",
	},
	// RepMisc0x : ∙
	{
		token.EOF: "$",
		token.T_7: "angLBrk",
	},
	// RepNameChar0x : ∙NAME_CHAR RepNameChar0x
	{
		token.T_12: "dot_BSlashDashCol",
		token.T_17: "let",
		token.T_18: "num",
	},
	// RepNameChar0x : NAME_CHAR ∙RepNameChar0x
	{
		token.T_4:  ";",
		token.T_12: "dot_BSlashDashCol",
		token.T_17: "let",
		token.T_18: "num",
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// RepNameChar0x : NAME_CHAR RepNameChar0x ∙
	{
		token.T_4:  ";",
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// RepNameChar0x : ∙
	{
		token.T_4:  ";",
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// RepSAttx0x : ∙SAtt RepSAttx0x
	{
		token.T_24: "spaceEsc",
	},
	// RepSAttx0x : SAtt ∙RepSAttx0x
	{
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// RepSAttx0x : SAtt RepSAttx0x ∙
	{
		token.T_19: "optSpaceEsc",
	},
	// RepSAttx0x : ∙
	{
		token.T_19: "optSpaceEsc",
	},
	// SAtt : ∙spaceEsc Attribute
	{
		token.T_24: "spaceEsc",
	},
	// SAtt : spaceEsc ∙Attribute
	{
		token.T_10: "col_",
		token.T_17: "let",
	},
	// SAtt : spaceEsc Attribute ∙
	{
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// SinCondClose : ∙sinQu
	{
		token.T_21: "sinQu",
	},
	// SinCondClose : sinQu ∙
	{
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// SinCondClose : ∙SymRefAlts SinCondClose
	{
		token.T_0: "&",
		token.T_1: "&#",
		token.T_2: "&#x",
		token.T_6: "andCarrs",
	},
	// SinCondClose : SymRefAlts ∙SinCondClose
	{
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_6:  "andCarrs",
		token.T_21: "sinQu",
	},
	// SinCondClose : SymRefAlts SinCondClose ∙
	{
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// SymRefAlts : ∙andCarrs
	{
		token.T_6: "andCarrs",
	},
	// SymRefAlts : andCarrs ∙
	{
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_6:  "andCarrs",
		token.T_13: "dubQu",
		token.T_21: "sinQu",
	},
	// SymRefAlts : ∙REFERENCE
	{
		token.T_0: "&",
		token.T_1: "&#",
		token.T_2: "&#x",
	},
	// SymRefAlts : REFERENCE ∙
	{
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_6:  "andCarrs",
		token.T_13: "dubQu",
		token.T_21: "sinQu",
	},
	// VersionInfo : ∙spaceEsc version Eq QuoVerNum
	{
		token.T_24: "spaceEsc",
	},
	// VersionInfo : spaceEsc ∙version Eq QuoVerNum
	{
		token.T_25: "version",
	},
	// VersionInfo : spaceEsc version ∙Eq QuoVerNum
	{
		token.T_19: "optSpaceEsc",
	},
	// VersionInfo : spaceEsc version Eq ∙QuoVerNum
	{
		token.T_13: "dubQu",
		token.T_21: "sinQu",
	},
	// VersionInfo : spaceEsc version Eq QuoVerNum ∙
	{
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// VersionNum : ∙NAME_CHAR NameCharRep
	{
		token.T_12: "dot_BSlashDashCol",
		token.T_17: "let",
		token.T_18: "num",
	},
	// VersionNum : NAME_CHAR ∙NameCharRep
	{
		token.T_12: "dot_BSlashDashCol",
		token.T_13: "dubQu",
		token.T_17: "let",
		token.T_18: "num",
		token.T_21: "sinQu",
	},
	// VersionNum : NAME_CHAR NameCharRep ∙
	{
		token.T_13: "dubQu",
		token.T_21: "sinQu",
	},
	// XMLDecl : ∙xmlDeclStart VersionInfo OptEncodDecl optSpaceEsc xmlDeclEnd
	{
		token.T_27: "xmlDeclStart",
	},
	// XMLDecl : xmlDeclStart ∙VersionInfo OptEncodDecl optSpaceEsc xmlDeclEnd
	{
		token.T_24: "spaceEsc",
	},
	// XMLDecl : xmlDeclStart VersionInfo ∙OptEncodDecl optSpaceEsc xmlDeclEnd
	{
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// XMLDecl : xmlDeclStart VersionInfo OptEncodDecl ∙optSpaceEsc xmlDeclEnd
	{
		token.T_19: "optSpaceEsc",
	},
	// XMLDecl : xmlDeclStart VersionInfo OptEncodDecl optSpaceEsc ∙xmlDeclEnd
	{
		token.T_26: "xmlDeclEnd",
	},
	// XMLDecl : xmlDeclStart VersionInfo OptEncodDecl optSpaceEsc xmlDeclEnd ∙
	{
		token.T_7:  "angLBrk",
		token.T_24: "spaceEsc",
	},
}

var followSets = []map[token.Type]string{
	// ATT_VALUE
	{
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// Attribute
	{
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// CHAR_REF
	{
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_6:  "andCarrs",
		token.T_7:  "angLBrk",
		token.T_9:  "charData",
		token.T_13: "dubQu",
		token.T_21: "sinQu",
		token.T_22: "slashAngLBrk",
	},
	// COMMENT
	{
		token.EOF:  "$",
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_7:  "angLBrk",
		token.T_9:  "charData",
		token.T_22: "slashAngLBrk",
		token.T_24: "spaceEsc",
	},
	// ComEnterior
	{
		token.T_8: "angRBrk",
	},
	// ComStart
	{
		token.T_3:  "--",
		token.T_17: "let",
	},
	// Content
	{
		token.T_22: "slashAngLBrk",
	},
	// ContentAlts
	{
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_7:  "angLBrk",
		token.T_9:  "charData",
		token.T_22: "slashAngLBrk",
	},
	// Document
	{
		token.EOF: "$",
	},
	// DubCondClose
	{
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// DubDash
	{
		token.T_3:  "--",
		token.T_8:  "angRBrk",
		token.T_17: "let",
	},
	// ENTITY_REF
	{
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_6:  "andCarrs",
		token.T_7:  "angLBrk",
		token.T_9:  "charData",
		token.T_13: "dubQu",
		token.T_21: "sinQu",
		token.T_22: "slashAngLBrk",
	},
	// ElemCloseAlts
	{
		token.EOF:  "$",
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_7:  "angLBrk",
		token.T_9:  "charData",
		token.T_22: "slashAngLBrk",
		token.T_24: "spaceEsc",
	},
	// Element
	{
		token.EOF:  "$",
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_7:  "angLBrk",
		token.T_9:  "charData",
		token.T_22: "slashAngLBrk",
		token.T_24: "spaceEsc",
	},
	// EncName
	{
		token.T_13: "dubQu",
		token.T_21: "sinQu",
	},
	// EncodingDecl
	{
		token.T_19: "optSpaceEsc",
	},
	// Eq
	{
		token.T_13: "dubQu",
		token.T_21: "sinQu",
	},
	// Hex
	{
		token.T_4: ";",
	},
	// HexAlts
	{
		token.T_4:  ";",
		token.T_5:  "aA_fF",
		token.T_18: "num",
	},
	// LetColonAlts
	{
		token.T_4:  ";",
		token.T_12: "dot_BSlashDashCol",
		token.T_17: "let",
		token.T_18: "num",
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// LetDigSymAlts
	{
		token.T_11: "dot_BSlashDash",
		token.T_13: "dubQu",
		token.T_17: "let",
		token.T_18: "num",
		token.T_21: "sinQu",
	},
	// Misc
	{
		token.EOF:  "$",
		token.T_7:  "angLBrk",
		token.T_24: "spaceEsc",
	},
	// NAME
	{
		token.T_4:  ";",
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// NAME_CHAR
	{
		token.T_4:  ";",
		token.T_12: "dot_BSlashDashCol",
		token.T_13: "dubQu",
		token.T_17: "let",
		token.T_18: "num",
		token.T_19: "optSpaceEsc",
		token.T_21: "sinQu",
		token.T_24: "spaceEsc",
	},
	// NameCharRep
	{
		token.T_13: "dubQu",
		token.T_21: "sinQu",
	},
	// OptEncodDecl
	{
		token.T_19: "optSpaceEsc",
	},
	// OptXMLDecl
	{
		token.T_7:  "angLBrk",
		token.T_24: "spaceEsc",
	},
	// Prolog
	{
		token.T_7: "angLBrk",
	},
	// QuoEncNam
	{
		token.T_19: "optSpaceEsc",
	},
	// QuoVerNum
	{
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// REFERENCE
	{
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_6:  "andCarrs",
		token.T_7:  "angLBrk",
		token.T_9:  "charData",
		token.T_13: "dubQu",
		token.T_21: "sinQu",
		token.T_22: "slashAngLBrk",
	},
	// RepHexAlts0x
	{
		token.T_4: ";",
	},
	// RepLDSAlts0x
	{
		token.T_13: "dubQu",
		token.T_21: "sinQu",
	},
	// RepMisc0x
	{
		token.EOF: "$",
		token.T_7: "angLBrk",
	},
	// RepNameChar0x
	{
		token.T_4:  ";",
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// RepSAttx0x
	{
		token.T_19: "optSpaceEsc",
	},
	// SAtt
	{
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// SinCondClose
	{
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// SymRefAlts
	{
		token.T_0:  "&",
		token.T_1:  "&#",
		token.T_2:  "&#x",
		token.T_6:  "andCarrs",
		token.T_13: "dubQu",
		token.T_21: "sinQu",
	},
	// VersionInfo
	{
		token.T_19: "optSpaceEsc",
		token.T_24: "spaceEsc",
	},
	// VersionNum
	{
		token.T_13: "dubQu",
		token.T_21: "sinQu",
	},
	// XMLDecl
	{
		token.T_7:  "angLBrk",
		token.T_24: "spaceEsc",
	},
}

/*** Errors ***/

/*
Error is returned by Parse at every point at which the parser fails to parse
a grammar production. For non-LL-1 grammars there will be an error for each
alternate attempted by the parser.

The errors are sorted in descending order of input position (index of token in
the stream of tokens).

Normally the error of interest is the one that has parsed the largest number of
tokens.
*/
type Error struct {
	// Index of token that caused the error.
	cI int

	// Grammar slot at which the error occured.
	Slot slot.Label

	// The token at which the error occurred.
	Token *token.Token

	// The line and column in the input text at which the error occurred
	Line, Column int

	// The tokens expected at the point where the error occurred
	Expected map[token.Type]string
}

func (pe *Error) String() string {
	w := new(bytes.Buffer)
	fmt.Fprintf(w, "Parse Error: %s I[%d]=%s at line %d col %d\n",
		pe.Slot, pe.cI, pe.Token, pe.Line, pe.Column)
	exp := []string{}
	for _, e := range pe.Expected {
		exp = append(exp, e)
	}
	fmt.Fprintf(w, "Expected one of: [%s]", strings.Join(exp, ","))
	return w.String()
}

func (p *parser) parseError(slot slot.Label, i int, expected map[token.Type]string) {
	pe := &Error{cI: i, Slot: slot, Token: p.lex.Tokens[i], Expected: expected}
	p.parseErrors = append(p.parseErrors, pe)
}

func (p *parser) sortParseErrors() {
	sort.Slice(p.parseErrors,
		func(i, j int) bool {
			return p.parseErrors[j].Token.Lext() < p.parseErrors[i].Token.Lext()
		})
	for _, pe := range p.parseErrors {
		pe.Line, pe.Column = p.lex.GetLineColumn(pe.Token.Lext())
	}
}

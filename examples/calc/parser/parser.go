// Package parser is generated by gogll. Do not edit.
package parser

import (
	"bytes"
	"fmt"
	"sort"
	"strings"

	"calc/lexer"
	"calc/parser/bsr"
	"calc/parser/slot"
	"calc/parser/symbols"
	"calc/token"
)

type parser struct {
	cI int

	R *descriptors
	U *descriptors

	popped   map[poppedNode]bool
	crf_m    map[clusterNode][]*crfNode
	crf_f    map[clusterNode][]*crfNode
	crfNodes map[crfNode]*crfNode

	lex         *lexer.Lexer
	parseErrors []*Error

	bsrSet *bsr.Set
}

// index used for non-matches
const failInd = -1

func newParser(l *lexer.Lexer) *parser {
	return &parser{
		cI:     0,
		lex:    l,
		R:      &descriptors{},
		U:      &descriptors{},
		popped: make(map[poppedNode]bool),
		crf_m: map[clusterNode][]*crfNode{
			{symbols.NT_EXPR, 0}: {},
		},
		crf_f:       map[clusterNode][]*crfNode{},
		crfNodes:    map[crfNode]*crfNode{},
		bsrSet:      bsr.New(symbols.NT_EXPR, l),
		parseErrors: nil,
	}
}

// Parse returns the BSR set containing the parse forest.
// If the parse was successfull []*Error is nil
func Parse(l *lexer.Lexer) (*bsr.Set, []*Error) {
	return newParser(l).parse()
}

func (p *parser) parse() (*bsr.Set, []*Error) {
	var L slot.Label
	m, cU := len(p.lex.Tokens)-1, 0
	p.ntAdd(symbols.NT_EXPR, 0)
	// p.DumpDescriptors()
	for !p.R.empty() {
		L, cU, p.cI = p.R.remove()

		// fmt.Println()
		// fmt.Printf("L:%s, cI:%d, I[p.cI]:%s, cU:%d\n", L, p.cI, p.lex.Tokens[p.cI], cU)
		// p.DumpDescriptors()

		for {
			switch L {
			case slot.CLOSE0R0: // CLOSE : ∙) WS

				if !p.testSelect(slot.CLOSE0R0) {
					p.parseError(slot.CLOSE0R0, p.cI, first[slot.CLOSE0R0])
					L, p.cI = slot.CLOSE1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.CLOSE0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.CLOSE0R1) {
					p.parseError(slot.CLOSE0R1, p.cI, first[slot.CLOSE0R1])
					L, p.cI = slot.CLOSE1F0, cU
					goto nextSlot
				}
				p.call(slot.CLOSE0R2, slot.CLOSE1F0, symbols.NT_WS, cU, p.cI)
			case slot.CLOSE0R2: // CLOSE : ) WS ∙

				p.rtn(symbols.NT_CLOSE, cU, p.cI)
			case slot.CLOSE1F0: // CLOSE failure case
				p.rtn(symbols.NT_CLOSE, cU, failInd)
			case slot.DIVIDE0R0: // DIVIDE : ∙/ WS

				if !p.testSelect(slot.DIVIDE0R0) {
					p.parseError(slot.DIVIDE0R0, p.cI, first[slot.DIVIDE0R0])
					L, p.cI = slot.DIVIDE1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.DIVIDE0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.DIVIDE0R1) {
					p.parseError(slot.DIVIDE0R1, p.cI, first[slot.DIVIDE0R1])
					L, p.cI = slot.DIVIDE1F0, cU
					goto nextSlot
				}
				p.call(slot.DIVIDE0R2, slot.DIVIDE1F0, symbols.NT_WS, cU, p.cI)
			case slot.DIVIDE0R2: // DIVIDE : / WS ∙

				p.rtn(symbols.NT_DIVIDE, cU, p.cI)
			case slot.DIVIDE1F0: // DIVIDE failure case
				p.rtn(symbols.NT_DIVIDE, cU, failInd)
			case slot.ELEMENT0R0: // ELEMENT : ∙OPEN SUM CLOSE

				if !p.testSelect(slot.ELEMENT0R0) {
					p.parseError(slot.ELEMENT0R0, p.cI, first[slot.ELEMENT0R0])
					L, p.cI = slot.ELEMENT1R0, cU
					goto nextSlot
				}
				p.call(slot.ELEMENT0R1, slot.ELEMENT1R0, symbols.NT_OPEN, cU, p.cI)
			case slot.ELEMENT0R1: // ELEMENT : OPEN ∙SUM CLOSE

				p.rtn(symbols.NT_ELEMENT, cU, p.cI)
				L, p.cI = slot.ELEMENT1M0, cU
				goto nextSlot
				if !p.testSelect(slot.ELEMENT0R1) {
					p.parseError(slot.ELEMENT0R1, p.cI, first[slot.ELEMENT0R1])
					L, p.cI = slot.ELEMENT1R0, cU
					goto nextSlot
				}
				p.call(slot.ELEMENT0R2, slot.ELEMENT1R0, symbols.NT_SUM, cU, p.cI)
			case slot.ELEMENT0R2: // ELEMENT : OPEN SUM ∙CLOSE

				p.rtn(symbols.NT_ELEMENT, cU, p.cI)
				L, p.cI = slot.ELEMENT1M0, cU
				goto nextSlot
				if !p.testSelect(slot.ELEMENT0R2) {
					p.parseError(slot.ELEMENT0R2, p.cI, first[slot.ELEMENT0R2])
					L, p.cI = slot.ELEMENT1R0, cU
					goto nextSlot
				}
				p.call(slot.ELEMENT0R3, slot.ELEMENT1R0, symbols.NT_CLOSE, cU, p.cI)
			case slot.ELEMENT0R3: // ELEMENT : OPEN SUM CLOSE ∙

				p.rtn(symbols.NT_ELEMENT, cU, p.cI)
				L, p.cI = slot.ELEMENT1M0, cU
				goto nextSlot

			case slot.ELEMENT1R0: // ELEMENT : ∙Number

				if !p.testSelect(slot.ELEMENT1R0) {
					p.parseError(slot.ELEMENT1R0, p.cI, first[slot.ELEMENT1R0])
					L, p.cI = slot.ELEMENT2F0, cU
					goto nextSlot
				}
				p.call(slot.ELEMENT1R1, slot.ELEMENT2F0, symbols.NT_Number, cU, p.cI)
			case slot.ELEMENT1R1: // ELEMENT : Number ∙

				p.rtn(symbols.NT_ELEMENT, cU, p.cI)

			case slot.ELEMENT1M0: // ELEMENT : ∙Number  [with previous match]

				if !p.testSelect(slot.ELEMENT1R0) {
					p.parseError(slot.ELEMENT1R0, p.cI, first[slot.ELEMENT1R0])

				}
				p.call(slot.ELEMENT1M0, failInd, symbols.NT_Number, cU, p.cI)
			case slot.ELEMENT1M0: // ELEMENT : Number ∙

				p.rtn(symbols.NT_ELEMENT, cU, p.cI)

			case slot.ELEMENT2F0: // ELEMENT failure case
				p.rtn(symbols.NT_ELEMENT, cU, failInd)
			case slot.EXPR0R0: // EXPR : ∙WS SUM

				if !p.testSelect(slot.EXPR0R0) {
					p.parseError(slot.EXPR0R0, p.cI, first[slot.EXPR0R0])
					L, p.cI = slot.EXPR1F0, cU
					goto nextSlot
				}
				p.call(slot.EXPR0R1, slot.EXPR1F0, symbols.NT_WS, cU, p.cI)
			case slot.EXPR0R1: // EXPR : WS ∙SUM

				if !p.testSelect(slot.EXPR0R1) {
					p.parseError(slot.EXPR0R1, p.cI, first[slot.EXPR0R1])
					L, p.cI = slot.EXPR1F0, cU
					goto nextSlot
				}
				p.call(slot.EXPR0R2, slot.EXPR1F0, symbols.NT_SUM, cU, p.cI)
			case slot.EXPR0R2: // EXPR : WS SUM ∙

				p.rtn(symbols.NT_EXPR, cU, p.cI)
			case slot.EXPR1F0: // EXPR failure case
				p.rtn(symbols.NT_EXPR, cU, failInd)
			case slot.MINUS0R0: // MINUS : ∙- WS

				if !p.testSelect(slot.MINUS0R0) {
					p.parseError(slot.MINUS0R0, p.cI, first[slot.MINUS0R0])
					L, p.cI = slot.MINUS1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.MINUS0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.MINUS0R1) {
					p.parseError(slot.MINUS0R1, p.cI, first[slot.MINUS0R1])
					L, p.cI = slot.MINUS1F0, cU
					goto nextSlot
				}
				p.call(slot.MINUS0R2, slot.MINUS1F0, symbols.NT_WS, cU, p.cI)
			case slot.MINUS0R2: // MINUS : - WS ∙

				p.rtn(symbols.NT_MINUS, cU, p.cI)
			case slot.MINUS1F0: // MINUS failure case
				p.rtn(symbols.NT_MINUS, cU, failInd)
			case slot.Number0R0: // Number : ∙repNumber1x WS

				if !p.testSelect(slot.Number0R0) {
					p.parseError(slot.Number0R0, p.cI, first[slot.Number0R0])
					L, p.cI = slot.Number1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.Number0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.Number0R1) {
					p.parseError(slot.Number0R1, p.cI, first[slot.Number0R1])
					L, p.cI = slot.Number1F0, cU
					goto nextSlot
				}
				p.call(slot.Number0R2, slot.Number1F0, symbols.NT_WS, cU, p.cI)
			case slot.Number0R2: // Number : repNumber1x WS ∙

				p.rtn(symbols.NT_Number, cU, p.cI)
			case slot.Number1F0: // Number failure case
				p.rtn(symbols.NT_Number, cU, failInd)
			case slot.OPEN0R0: // OPEN : ∙( WS

				if !p.testSelect(slot.OPEN0R0) {
					p.parseError(slot.OPEN0R0, p.cI, first[slot.OPEN0R0])
					L, p.cI = slot.OPEN1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.OPEN0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.OPEN0R1) {
					p.parseError(slot.OPEN0R1, p.cI, first[slot.OPEN0R1])
					L, p.cI = slot.OPEN1F0, cU
					goto nextSlot
				}
				p.call(slot.OPEN0R2, slot.OPEN1F0, symbols.NT_WS, cU, p.cI)
			case slot.OPEN0R2: // OPEN : ( WS ∙

				p.rtn(symbols.NT_OPEN, cU, p.cI)
			case slot.OPEN1F0: // OPEN failure case
				p.rtn(symbols.NT_OPEN, cU, failInd)
			case slot.PLUS0R0: // PLUS : ∙+ WS

				if !p.testSelect(slot.PLUS0R0) {
					p.parseError(slot.PLUS0R0, p.cI, first[slot.PLUS0R0])
					L, p.cI = slot.PLUS1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.PLUS0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.PLUS0R1) {
					p.parseError(slot.PLUS0R1, p.cI, first[slot.PLUS0R1])
					L, p.cI = slot.PLUS1F0, cU
					goto nextSlot
				}
				p.call(slot.PLUS0R2, slot.PLUS1F0, symbols.NT_WS, cU, p.cI)
			case slot.PLUS0R2: // PLUS : + WS ∙

				p.rtn(symbols.NT_PLUS, cU, p.cI)
			case slot.PLUS1F0: // PLUS failure case
				p.rtn(symbols.NT_PLUS, cU, failInd)
			case slot.PLUSorMINUS0R0: // PLUSorMINUS : ∙PLUS PRODUCT

				if !p.testSelect(slot.PLUSorMINUS0R0) {
					p.parseError(slot.PLUSorMINUS0R0, p.cI, first[slot.PLUSorMINUS0R0])
					L, p.cI = slot.PLUSorMINUS1R0, cU
					goto nextSlot
				}
				p.call(slot.PLUSorMINUS0R1, slot.PLUSorMINUS1R0, symbols.NT_PLUS, cU, p.cI)
			case slot.PLUSorMINUS0R1: // PLUSorMINUS : PLUS ∙PRODUCT

				p.rtn(symbols.NT_PLUSorMINUS, cU, p.cI)
				L, p.cI = slot.PLUSorMINUS1M0, cU
				goto nextSlot
				if !p.testSelect(slot.PLUSorMINUS0R1) {
					p.parseError(slot.PLUSorMINUS0R1, p.cI, first[slot.PLUSorMINUS0R1])
					L, p.cI = slot.PLUSorMINUS1R0, cU
					goto nextSlot
				}
				p.call(slot.PLUSorMINUS0R2, slot.PLUSorMINUS1R0, symbols.NT_PRODUCT, cU, p.cI)
			case slot.PLUSorMINUS0R2: // PLUSorMINUS : PLUS PRODUCT ∙

				p.rtn(symbols.NT_PLUSorMINUS, cU, p.cI)
				L, p.cI = slot.PLUSorMINUS1M0, cU
				goto nextSlot

			case slot.PLUSorMINUS1R0: // PLUSorMINUS : ∙MINUS PRODUCT

				if !p.testSelect(slot.PLUSorMINUS1R0) {
					p.parseError(slot.PLUSorMINUS1R0, p.cI, first[slot.PLUSorMINUS1R0])
					L, p.cI = slot.PLUSorMINUS2F0, cU
					goto nextSlot
				}
				p.call(slot.PLUSorMINUS1R1, slot.PLUSorMINUS2F0, symbols.NT_MINUS, cU, p.cI)
			case slot.PLUSorMINUS1R1: // PLUSorMINUS : MINUS ∙PRODUCT

				p.rtn(symbols.NT_PLUSorMINUS, cU, p.cI)

				if !p.testSelect(slot.PLUSorMINUS1R1) {
					p.parseError(slot.PLUSorMINUS1R1, p.cI, first[slot.PLUSorMINUS1R1])
					L, p.cI = slot.PLUSorMINUS2F0, cU
					goto nextSlot
				}
				p.call(slot.PLUSorMINUS1R2, slot.PLUSorMINUS2F0, symbols.NT_PRODUCT, cU, p.cI)
			case slot.PLUSorMINUS1R2: // PLUSorMINUS : MINUS PRODUCT ∙

				p.rtn(symbols.NT_PLUSorMINUS, cU, p.cI)

			case slot.PLUSorMINUS1M0: // PLUSorMINUS : ∙MINUS PRODUCT  [with previous match]

				if !p.testSelect(slot.PLUSorMINUS1R0) {
					p.parseError(slot.PLUSorMINUS1R0, p.cI, first[slot.PLUSorMINUS1R0])

				}
				p.call(slot.PLUSorMINUS1M0, failInd, symbols.NT_MINUS, cU, p.cI)
			case slot.PLUSorMINUS1M0: // PLUSorMINUS : MINUS ∙PRODUCT

				p.rtn(symbols.NT_PLUSorMINUS, cU, p.cI)

				if !p.testSelect(slot.PLUSorMINUS1R1) {
					p.parseError(slot.PLUSorMINUS1R1, p.cI, first[slot.PLUSorMINUS1R1])

				}
				p.call(slot.PLUSorMINUS1M1, failInd, symbols.NT_PRODUCT, cU, p.cI)
			case slot.PLUSorMINUS1M1: // PLUSorMINUS : MINUS PRODUCT ∙

				p.rtn(symbols.NT_PLUSorMINUS, cU, p.cI)

			case slot.PLUSorMINUS2F0: // PLUSorMINUS failure case
				p.rtn(symbols.NT_PLUSorMINUS, cU, failInd)
			case slot.PRODUCT0R0: // PRODUCT : ∙ELEMENT SuffTIMESorDIVIDE

				if !p.testSelect(slot.PRODUCT0R0) {
					p.parseError(slot.PRODUCT0R0, p.cI, first[slot.PRODUCT0R0])
					L, p.cI = slot.PRODUCT1F0, cU
					goto nextSlot
				}
				p.call(slot.PRODUCT0R1, slot.PRODUCT1F0, symbols.NT_ELEMENT, cU, p.cI)
			case slot.PRODUCT0R1: // PRODUCT : ELEMENT ∙SuffTIMESorDIVIDE

				if !p.testSelect(slot.PRODUCT0R1) {
					p.parseError(slot.PRODUCT0R1, p.cI, first[slot.PRODUCT0R1])
					L, p.cI = slot.PRODUCT1F0, cU
					goto nextSlot
				}
				p.call(slot.PRODUCT0R2, slot.PRODUCT1F0, symbols.NT_SuffTIMESorDIVIDE, cU, p.cI)
			case slot.PRODUCT0R2: // PRODUCT : ELEMENT SuffTIMESorDIVIDE ∙

				p.rtn(symbols.NT_PRODUCT, cU, p.cI)
			case slot.PRODUCT1F0: // PRODUCT failure case
				p.rtn(symbols.NT_PRODUCT, cU, failInd)
			case slot.SUM0R0: // SUM : ∙PRODUCT SuffPLUSorMINUS

				if !p.testSelect(slot.SUM0R0) {
					p.parseError(slot.SUM0R0, p.cI, first[slot.SUM0R0])
					L, p.cI = slot.SUM1F0, cU
					goto nextSlot
				}
				p.call(slot.SUM0R1, slot.SUM1F0, symbols.NT_PRODUCT, cU, p.cI)
			case slot.SUM0R1: // SUM : PRODUCT ∙SuffPLUSorMINUS

				if !p.testSelect(slot.SUM0R1) {
					p.parseError(slot.SUM0R1, p.cI, first[slot.SUM0R1])
					L, p.cI = slot.SUM1F0, cU
					goto nextSlot
				}
				p.call(slot.SUM0R2, slot.SUM1F0, symbols.NT_SuffPLUSorMINUS, cU, p.cI)
			case slot.SUM0R2: // SUM : PRODUCT SuffPLUSorMINUS ∙

				p.rtn(symbols.NT_SUM, cU, p.cI)
			case slot.SUM1F0: // SUM failure case
				p.rtn(symbols.NT_SUM, cU, failInd)
			case slot.SuffPLUSorMINUS0R0: // SuffPLUSorMINUS : ∙PLUSorMINUS SuffPLUSorMINUS

				if !p.testSelect(slot.SuffPLUSorMINUS0R0) {
					p.parseError(slot.SuffPLUSorMINUS0R0, p.cI, first[slot.SuffPLUSorMINUS0R0])
					L, p.cI = slot.SuffPLUSorMINUS1R0, cU
					goto nextSlot
				}
				p.call(slot.SuffPLUSorMINUS0R1, slot.SuffPLUSorMINUS1R0, symbols.NT_PLUSorMINUS, cU, p.cI)
			case slot.SuffPLUSorMINUS0R1: // SuffPLUSorMINUS : PLUSorMINUS ∙SuffPLUSorMINUS

				if !p.testSelect(slot.SuffPLUSorMINUS0R1) {
					p.parseError(slot.SuffPLUSorMINUS0R1, p.cI, first[slot.SuffPLUSorMINUS0R1])
					L, p.cI = slot.SuffPLUSorMINUS1R0, cU
					goto nextSlot
				}
				p.call(slot.SuffPLUSorMINUS0R2, slot.SuffPLUSorMINUS1R0, symbols.NT_SuffPLUSorMINUS, cU, p.cI)
			case slot.SuffPLUSorMINUS0R2: // SuffPLUSorMINUS : PLUSorMINUS SuffPLUSorMINUS ∙

				p.rtn(symbols.NT_SuffPLUSorMINUS, cU, p.cI)
			case slot.SuffPLUSorMINUS1R0: // SuffPLUSorMINUS : ∙
				p.bsrSet.AddEmpty(slot.SuffPLUSorMINUS1R0, p.cI)
				p.rtn(symbols.NT_SuffPLUSorMINUS, cU, p.cI)
			case slot.SuffTIMESorDIVIDE0R0: // SuffTIMESorDIVIDE : ∙TIMESorDIVIDE SuffTIMESorDIVIDE

				if !p.testSelect(slot.SuffTIMESorDIVIDE0R0) {
					p.parseError(slot.SuffTIMESorDIVIDE0R0, p.cI, first[slot.SuffTIMESorDIVIDE0R0])
					L, p.cI = slot.SuffTIMESorDIVIDE1R0, cU
					goto nextSlot
				}
				p.call(slot.SuffTIMESorDIVIDE0R1, slot.SuffTIMESorDIVIDE1R0, symbols.NT_TIMESorDIVIDE, cU, p.cI)
			case slot.SuffTIMESorDIVIDE0R1: // SuffTIMESorDIVIDE : TIMESorDIVIDE ∙SuffTIMESorDIVIDE

				if !p.testSelect(slot.SuffTIMESorDIVIDE0R1) {
					p.parseError(slot.SuffTIMESorDIVIDE0R1, p.cI, first[slot.SuffTIMESorDIVIDE0R1])
					L, p.cI = slot.SuffTIMESorDIVIDE1R0, cU
					goto nextSlot
				}
				p.call(slot.SuffTIMESorDIVIDE0R2, slot.SuffTIMESorDIVIDE1R0, symbols.NT_SuffTIMESorDIVIDE, cU, p.cI)
			case slot.SuffTIMESorDIVIDE0R2: // SuffTIMESorDIVIDE : TIMESorDIVIDE SuffTIMESorDIVIDE ∙

				p.rtn(symbols.NT_SuffTIMESorDIVIDE, cU, p.cI)
			case slot.SuffTIMESorDIVIDE1R0: // SuffTIMESorDIVIDE : ∙
				p.bsrSet.AddEmpty(slot.SuffTIMESorDIVIDE1R0, p.cI)
				p.rtn(symbols.NT_SuffTIMESorDIVIDE, cU, p.cI)
			case slot.TIMES0R0: // TIMES : ∙* WS

				if !p.testSelect(slot.TIMES0R0) {
					p.parseError(slot.TIMES0R0, p.cI, first[slot.TIMES0R0])
					L, p.cI = slot.TIMES1F0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.TIMES0R1, cU, p.cI, p.cI+1)
				p.cI++
				if !p.testSelect(slot.TIMES0R1) {
					p.parseError(slot.TIMES0R1, p.cI, first[slot.TIMES0R1])
					L, p.cI = slot.TIMES1F0, cU
					goto nextSlot
				}
				p.call(slot.TIMES0R2, slot.TIMES1F0, symbols.NT_WS, cU, p.cI)
			case slot.TIMES0R2: // TIMES : * WS ∙

				p.rtn(symbols.NT_TIMES, cU, p.cI)
			case slot.TIMES1F0: // TIMES failure case
				p.rtn(symbols.NT_TIMES, cU, failInd)
			case slot.TIMESorDIVIDE0R0: // TIMESorDIVIDE : ∙TIMES ELEMENT

				if !p.testSelect(slot.TIMESorDIVIDE0R0) {
					p.parseError(slot.TIMESorDIVIDE0R0, p.cI, first[slot.TIMESorDIVIDE0R0])
					L, p.cI = slot.TIMESorDIVIDE1R0, cU
					goto nextSlot
				}
				p.call(slot.TIMESorDIVIDE0R1, slot.TIMESorDIVIDE1R0, symbols.NT_TIMES, cU, p.cI)
			case slot.TIMESorDIVIDE0R1: // TIMESorDIVIDE : TIMES ∙ELEMENT

				p.rtn(symbols.NT_TIMESorDIVIDE, cU, p.cI)
				L, p.cI = slot.TIMESorDIVIDE1M0, cU
				goto nextSlot
				if !p.testSelect(slot.TIMESorDIVIDE0R1) {
					p.parseError(slot.TIMESorDIVIDE0R1, p.cI, first[slot.TIMESorDIVIDE0R1])
					L, p.cI = slot.TIMESorDIVIDE1R0, cU
					goto nextSlot
				}
				p.call(slot.TIMESorDIVIDE0R2, slot.TIMESorDIVIDE1R0, symbols.NT_ELEMENT, cU, p.cI)
			case slot.TIMESorDIVIDE0R2: // TIMESorDIVIDE : TIMES ELEMENT ∙

				p.rtn(symbols.NT_TIMESorDIVIDE, cU, p.cI)
				L, p.cI = slot.TIMESorDIVIDE1M0, cU
				goto nextSlot

			case slot.TIMESorDIVIDE1R0: // TIMESorDIVIDE : ∙DIVIDE ELEMENT

				if !p.testSelect(slot.TIMESorDIVIDE1R0) {
					p.parseError(slot.TIMESorDIVIDE1R0, p.cI, first[slot.TIMESorDIVIDE1R0])
					L, p.cI = slot.TIMESorDIVIDE2F0, cU
					goto nextSlot
				}
				p.call(slot.TIMESorDIVIDE1R1, slot.TIMESorDIVIDE2F0, symbols.NT_DIVIDE, cU, p.cI)
			case slot.TIMESorDIVIDE1R1: // TIMESorDIVIDE : DIVIDE ∙ELEMENT

				p.rtn(symbols.NT_TIMESorDIVIDE, cU, p.cI)

				if !p.testSelect(slot.TIMESorDIVIDE1R1) {
					p.parseError(slot.TIMESorDIVIDE1R1, p.cI, first[slot.TIMESorDIVIDE1R1])
					L, p.cI = slot.TIMESorDIVIDE2F0, cU
					goto nextSlot
				}
				p.call(slot.TIMESorDIVIDE1R2, slot.TIMESorDIVIDE2F0, symbols.NT_ELEMENT, cU, p.cI)
			case slot.TIMESorDIVIDE1R2: // TIMESorDIVIDE : DIVIDE ELEMENT ∙

				p.rtn(symbols.NT_TIMESorDIVIDE, cU, p.cI)

			case slot.TIMESorDIVIDE1M0: // TIMESorDIVIDE : ∙DIVIDE ELEMENT  [with previous match]

				if !p.testSelect(slot.TIMESorDIVIDE1R0) {
					p.parseError(slot.TIMESorDIVIDE1R0, p.cI, first[slot.TIMESorDIVIDE1R0])

				}
				p.call(slot.TIMESorDIVIDE1M0, failInd, symbols.NT_DIVIDE, cU, p.cI)
			case slot.TIMESorDIVIDE1M0: // TIMESorDIVIDE : DIVIDE ∙ELEMENT

				p.rtn(symbols.NT_TIMESorDIVIDE, cU, p.cI)

				if !p.testSelect(slot.TIMESorDIVIDE1R1) {
					p.parseError(slot.TIMESorDIVIDE1R1, p.cI, first[slot.TIMESorDIVIDE1R1])

				}
				p.call(slot.TIMESorDIVIDE1M1, failInd, symbols.NT_ELEMENT, cU, p.cI)
			case slot.TIMESorDIVIDE1M1: // TIMESorDIVIDE : DIVIDE ELEMENT ∙

				p.rtn(symbols.NT_TIMESorDIVIDE, cU, p.cI)

			case slot.TIMESorDIVIDE2F0: // TIMESorDIVIDE failure case
				p.rtn(symbols.NT_TIMESorDIVIDE, cU, failInd)
			case slot.WS0R0: // WS : ∙sp

				if !p.testSelect(slot.WS0R0) {
					p.parseError(slot.WS0R0, p.cI, first[slot.WS0R0])
					L, p.cI = slot.WS1R0, cU
					goto nextSlot
				}
				p.bsrSet.Add(slot.WS0R1, cU, p.cI, p.cI+1)
				p.cI++
				p.rtn(symbols.NT_WS, cU, p.cI)
			case slot.WS1R0: // WS : ∙
				p.bsrSet.AddEmpty(slot.WS1R0, p.cI)
				p.rtn(symbols.NT_WS, cU, p.cI)

			default:
				panic("This must not happen")
			}
			// if exit switch normally, also exit loop and proceed to next
			// descriptor; if exit with goto nextSlot, repeat switch at next
			// slot
			break
		nextSlot:
		}
	}
	if !p.bsrSet.Contain(symbols.NT_EXPR, 0, m) {
		p.sortParseErrors()
		return nil, p.parseErrors
	}
	return p.bsrSet, nil
}

func (p *parser) ntAdd(nt symbols.NT, j int) {
	l := slot.GetAlternates(nt)[0]
	p.dscAdd(l, j, j)
}

/*** Call Return Forest ***/

type poppedNode struct {
	X    symbols.NT
	k, j int
}

type clusterNode struct {
	X symbols.NT
	k int
}

type crfNode struct {
	L slot.Label
	i int
}

func (p *parser) call(Lm, Lf slot.Label, X symbols.NT, i, j int) {
	// fmt.Printf("p.call(%s,%d,%d)\n", L,i,j)
	um, exist := p.crfNodes[crfNode{Lm, i}]
	// fmt.Printf("  u exist=%t\n", exist)
	if !exist {
		um = &crfNode{Lm, i}
		p.crfNodes[*um] = um
	}
	uf, exist := p.crfNodes[crfNode{Lf, i}]
	if !exist {
		uf = &crfNode{Lf, i}
		p.crfNodes[*uf] = uf
	}

	ndV := clusterNode{X, j}
	vm, existm := p.crf_m[ndV]
	vf, existf := p.crf_f[ndV]
	if !existm && !existf {
		// fmt.Println("  v !exist")
		p.crf_m[ndV] = []*crfNode{um}
		p.crf_f[ndV] = []*crfNode{uf}
		p.ntAdd(X, j)
	} else {
		// fmt.Println("  v exist")
		if !existEdge(vm, um) {
			// fmt.Printf("  !existEdge(%v)\n", u)
			p.crf_m[ndV] = append(vm, um)
			// fmt.Printf("|popped|=%d\n", len(popped))
			for pnd := range p.popped {
				if pnd.X == X && pnd.k == j && pnd.j != failInd {
					p.addMatch(Lm, i, j, pnd.j)
				}
			}
		}
		if !existEdge(vf, uf) {
			p.crf_f[ndV] = append(vf, uf)
			for pnd := range p.popped {
				if pnd.X == X && pnd.k == j && pnd.j == failInd {
					p.addFail(Lf, i, j)
				}
			}
		}
	}
}

func existEdge(nds []*crfNode, nd *crfNode) bool {
	for _, nd1 := range nds {
		if nd1 == nd {
			return true
		}
	}
	return false
}

func (p *parser) rtn(X symbols.NT, k, j int) {
	// fmt.Printf("p.rtn(%s,%d,%d)\n", X,k,j)
	pn := poppedNode{X, k, j}
	if _, exist := p.popped[pn]; !exist {
		p.popped[pn] = true
		if j != failInd {
			for _, nd := range p.crf_m[clusterNode{X, k}] {
				p.addMatch(nd.L, nd.i, k, j)
			}
		} else {
			for _, nd := range p.crf_f[clusterNode{X, k}] {
				p.addFail(nd.L, nd.i, k)
			}
		}
	}
}

func (p *parser) addMatch(L slot.Label, i, k, j int) {
	p.bsrSet.Add(L, i, k, j)
	if L.IsLookahead() {
		p.dscAdd(L, i, k)
	} else {
		p.dscAdd(L, i, j)
	}
}

func (p *parser) addFail(L slot.Label, i, k int) {
	if L.IsLookahead() {
		p.dscAdd(L, i, k)
	} else {
		p.dscAdd(L, i, i)
	}
}

// func CRFString() string {
// 	buf := new(bytes.Buffer)
// 	buf.WriteString("CRF: {")
// 	for cn, nds := range crf{
// 		for _, nd := range nds {
// 			fmt.Fprintf(buf, "%s->%s, ", cn, nd)
// 		}
// 	}
// 	buf.WriteString("}")
// 	return buf.String()
// }

func (cn clusterNode) String() string {
	return fmt.Sprintf("(%s,%d)", cn.X, cn.k)
}

func (n crfNode) String() string {
	return fmt.Sprintf("(%s,%d)", n.L.String(), n.i)
}

// func PoppedString() string {
// 	buf := new(bytes.Buffer)
// 	buf.WriteString("Popped: {")
// 	for p, _ := range popped {
// 		fmt.Fprintf(buf, "(%s,%d,%d) ", p.X, p.k, p.j)
// 	}
// 	buf.WriteString("}")
// 	return buf.String()
// }

/*** descriptors ***/

type descriptors struct {
	set []*descriptor
}

func (ds *descriptors) contain(d *descriptor) bool {
	for _, d1 := range ds.set {
		if d1 == d {
			return true
		}
	}
	return false
}

func (ds *descriptors) empty() bool {
	return len(ds.set) == 0
}

func (ds *descriptors) String() string {
	buf := new(bytes.Buffer)
	buf.WriteString("{")
	for i, d := range ds.set {
		if i > 0 {
			buf.WriteString("; ")
		}
		fmt.Fprintf(buf, "%s", d)
	}
	buf.WriteString("}")
	return buf.String()
}

type descriptor struct {
	L slot.Label
	k int
	i int
}

func (d *descriptor) String() string {
	return fmt.Sprintf("%s,%d,%d", d.L, d.k, d.i)
}

func (p *parser) dscAdd(L slot.Label, k, i int) {
	// fmt.Printf("p.dscAdd(%s,%d,%d)\n", L, k, i)
	d := &descriptor{L, k, i}
	if !p.U.contain(d) {
		p.R.set = append(p.R.set, d)
		p.U.set = append(p.U.set, d)
	}
}

func (ds *descriptors) remove() (L slot.Label, k, i int) {
	d := ds.set[len(ds.set)-1]
	ds.set = ds.set[:len(ds.set)-1]
	// fmt.Printf("remove: %s,%d,%d\n", d.L, d.k, d.i)
	return d.L, d.k, d.i
}

func (p *parser) DumpDescriptors() {
	p.DumpR()
	p.DumpU()
}

func (p *parser) DumpR() {
	fmt.Println("R:")
	for _, d := range p.R.set {
		fmt.Printf(" %s\n", d)
	}
}

func (p *parser) DumpU() {
	fmt.Println("U:")
	for _, d := range p.U.set {
		fmt.Printf(" %s\n", d)
	}
}

/*** TestSelect ***/

func (p *parser) follow(nt symbols.NT) bool {
	_, exist := followSets[nt][p.lex.Tokens[p.cI].Type()]
	return exist
}

func (p *parser) testSelect(l slot.Label) bool {
	return l.IsNullable() || l.FirstContains(p.lex.Tokens[p.cI].Type())
	// _, exist := first[l][p.lex.Tokens[p.cI].Type()]
	// return exist
}

var first = []map[token.Type]string{
	// CLOSE : ∙) WS
	{
		token.T_1: ")",
	},
	// CLOSE : ) ∙WS
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
		token.T_7: "sp",
	},
	// CLOSE : ) WS ∙
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
	},
	// CLOSE : ∙
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
	},
	// DIVIDE : ∙/ WS
	{
		token.T_5: "/",
	},
	// DIVIDE : / ∙WS
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
		token.T_7: "sp",
	},
	// DIVIDE : / WS ∙
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// DIVIDE : ∙
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// ELEMENT : ∙OPEN SUM CLOSE
	{
		token.T_0: "(",
	},
	// ELEMENT : OPEN ∙SUM CLOSE
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// ELEMENT : OPEN SUM ∙CLOSE
	{
		token.T_1: ")",
	},
	// ELEMENT : OPEN SUM CLOSE ∙
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
	},
	// ELEMENT : ∙Number
	{
		token.T_6: "repNumber1x",
	},
	// ELEMENT : ∙Number
	{
		token.T_6: "repNumber1x",
	},
	// ELEMENT : Number ∙
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
	},
	// ELEMENT : Number ∙
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
	},
	// ELEMENT : ∙
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
	},
	// EXPR : ∙WS SUM
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
		token.T_7: "sp",
	},
	// EXPR : WS ∙SUM
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// EXPR : WS SUM ∙
	{
		token.EOF: "$",
	},
	// EXPR : ∙
	{
		token.EOF: "$",
	},
	// MINUS : ∙- WS
	{
		token.T_4: "-",
	},
	// MINUS : - ∙WS
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
		token.T_7: "sp",
	},
	// MINUS : - WS ∙
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// MINUS : ∙
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// Number : ∙repNumber1x WS
	{
		token.T_6: "repNumber1x",
	},
	// Number : repNumber1x ∙WS
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
		token.T_7: "sp",
	},
	// Number : repNumber1x WS ∙
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
	},
	// Number : ∙
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
	},
	// OPEN : ∙( WS
	{
		token.T_0: "(",
	},
	// OPEN : ( ∙WS
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
		token.T_7: "sp",
	},
	// OPEN : ( WS ∙
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// OPEN : ∙
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// PLUS : ∙+ WS
	{
		token.T_3: "+",
	},
	// PLUS : + ∙WS
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
		token.T_7: "sp",
	},
	// PLUS : + WS ∙
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// PLUS : ∙
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// PLUSorMINUS : ∙PLUS PRODUCT
	{
		token.T_3: "+",
	},
	// PLUSorMINUS : PLUS ∙PRODUCT
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// PLUSorMINUS : PLUS PRODUCT ∙
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_3: "+",
		token.T_4: "-",
	},
	// PLUSorMINUS : ∙MINUS PRODUCT
	{
		token.T_4: "-",
	},
	// PLUSorMINUS : ∙MINUS PRODUCT
	{
		token.T_4: "-",
	},
	// PLUSorMINUS : MINUS ∙PRODUCT
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// PLUSorMINUS : MINUS ∙PRODUCT
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// PLUSorMINUS : MINUS PRODUCT ∙
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_3: "+",
		token.T_4: "-",
	},
	// PLUSorMINUS : MINUS PRODUCT ∙
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_3: "+",
		token.T_4: "-",
	},
	// PLUSorMINUS : ∙
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_3: "+",
		token.T_4: "-",
	},
	// PRODUCT : ∙ELEMENT SuffTIMESorDIVIDE
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// PRODUCT : ELEMENT ∙SuffTIMESorDIVIDE
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
	},
	// PRODUCT : ELEMENT SuffTIMESorDIVIDE ∙
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_3: "+",
		token.T_4: "-",
	},
	// PRODUCT : ∙
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_3: "+",
		token.T_4: "-",
	},
	// SUM : ∙PRODUCT SuffPLUSorMINUS
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// SUM : PRODUCT ∙SuffPLUSorMINUS
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_3: "+",
		token.T_4: "-",
	},
	// SUM : PRODUCT SuffPLUSorMINUS ∙
	{
		token.EOF: "$",
		token.T_1: ")",
	},
	// SUM : ∙
	{
		token.EOF: "$",
		token.T_1: ")",
	},
	// SuffPLUSorMINUS : ∙PLUSorMINUS SuffPLUSorMINUS
	{
		token.T_3: "+",
		token.T_4: "-",
	},
	// SuffPLUSorMINUS : PLUSorMINUS ∙SuffPLUSorMINUS
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_3: "+",
		token.T_4: "-",
	},
	// SuffPLUSorMINUS : PLUSorMINUS SuffPLUSorMINUS ∙
	{
		token.EOF: "$",
		token.T_1: ")",
	},
	// SuffPLUSorMINUS : ∙
	{
		token.EOF: "$",
		token.T_1: ")",
	},
	// SuffTIMESorDIVIDE : ∙TIMESorDIVIDE SuffTIMESorDIVIDE
	{
		token.T_2: "*",
		token.T_5: "/",
	},
	// SuffTIMESorDIVIDE : TIMESorDIVIDE ∙SuffTIMESorDIVIDE
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
	},
	// SuffTIMESorDIVIDE : TIMESorDIVIDE SuffTIMESorDIVIDE ∙
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_3: "+",
		token.T_4: "-",
	},
	// SuffTIMESorDIVIDE : ∙
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_3: "+",
		token.T_4: "-",
	},
	// TIMES : ∙* WS
	{
		token.T_2: "*",
	},
	// TIMES : * ∙WS
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
		token.T_7: "sp",
	},
	// TIMES : * WS ∙
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// TIMES : ∙
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// TIMESorDIVIDE : ∙TIMES ELEMENT
	{
		token.T_2: "*",
	},
	// TIMESorDIVIDE : TIMES ∙ELEMENT
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// TIMESorDIVIDE : TIMES ELEMENT ∙
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
	},
	// TIMESorDIVIDE : ∙DIVIDE ELEMENT
	{
		token.T_5: "/",
	},
	// TIMESorDIVIDE : ∙DIVIDE ELEMENT
	{
		token.T_5: "/",
	},
	// TIMESorDIVIDE : DIVIDE ∙ELEMENT
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// TIMESorDIVIDE : DIVIDE ∙ELEMENT
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// TIMESorDIVIDE : DIVIDE ELEMENT ∙
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
	},
	// TIMESorDIVIDE : DIVIDE ELEMENT ∙
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
	},
	// TIMESorDIVIDE : ∙
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
	},
	// WS : ∙sp
	{
		token.T_7: "sp",
	},
	// WS : sp ∙
	{
		token.EOF: "$",
		token.T_0: "(",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
		token.T_6: "repNumber1x",
	},
	// WS : ∙
	{
		token.EOF: "$",
		token.T_0: "(",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
		token.T_6: "repNumber1x",
	},
}

var followSets = []map[token.Type]string{
	// CLOSE
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
	},
	// DIVIDE
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// ELEMENT
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
	},
	// EXPR
	{
		token.EOF: "$",
	},
	// MINUS
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// Number
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
	},
	// OPEN
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// PLUS
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// PLUSorMINUS
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_3: "+",
		token.T_4: "-",
	},
	// PRODUCT
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_3: "+",
		token.T_4: "-",
	},
	// SUM
	{
		token.EOF: "$",
		token.T_1: ")",
	},
	// SuffPLUSorMINUS
	{
		token.EOF: "$",
		token.T_1: ")",
	},
	// SuffTIMESorDIVIDE
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_3: "+",
		token.T_4: "-",
	},
	// TIMES
	{
		token.T_0: "(",
		token.T_6: "repNumber1x",
	},
	// TIMESorDIVIDE
	{
		token.EOF: "$",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
	},
	// WS
	{
		token.EOF: "$",
		token.T_0: "(",
		token.T_1: ")",
		token.T_2: "*",
		token.T_3: "+",
		token.T_4: "-",
		token.T_5: "/",
		token.T_6: "repNumber1x",
	},
}

/*** Errors ***/

/*
Error is returned by Parse at every point at which the parser fails to parse
a grammar production. For non-LL-1 grammars there will be an error for each
alternate attempted by the parser.

The errors are sorted in descending order of input position (index of token in
the stream of tokens).

Normally the error of interest is the one that has parsed the largest number of
tokens.
*/
type Error struct {
	// Index of token that caused the error.
	cI int

	// Grammar slot at which the error occured.
	Slot slot.Label

	// The token at which the error occurred.
	Token *token.Token

	// The line and column in the input text at which the error occurred
	Line, Column int

	// The tokens expected at the point where the error occurred
	Expected map[token.Type]string
}

func (pe *Error) String() string {
	w := new(bytes.Buffer)
	fmt.Fprintf(w, "Parse Error: %s I[%d]=%s at line %d col %d\n",
		pe.Slot, pe.cI, pe.Token, pe.Line, pe.Column)
	exp := []string{}
	for _, e := range pe.Expected {
		exp = append(exp, e)
	}
	fmt.Fprintf(w, "Expected one of: [%s]", strings.Join(exp, ","))
	return w.String()
}

func (p *parser) parseError(slot slot.Label, i int, expected map[token.Type]string) {
	pe := &Error{cI: i, Slot: slot, Token: p.lex.Tokens[i], Expected: expected}
	p.parseErrors = append(p.parseErrors, pe)
}

func (p *parser) sortParseErrors() {
	sort.Slice(p.parseErrors,
		func(i, j int) bool {
			return p.parseErrors[j].Token.Lext() < p.parseErrors[i].Token.Lext()
		})
	for _, pe := range p.parseErrors {
		pe.Line, pe.Column = p.lex.GetLineColumn(pe.Token.Lext())
	}
}

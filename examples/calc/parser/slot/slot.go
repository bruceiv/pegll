
// Package slot is generated by gogll. Do not edit. 
package slot

import(
	"bytes"
	"fmt"
	
	"calc/parser/symbols"
)

type Label int

const(
	ELEM0R0 Label = iota
	ELEM0R1
	ELEM0R2
	ELEM0R3
	ELEM1R0
	ELEM1R1
	EXPR0R0
	EXPR0R1
	PROD0R0
	PROD0R1
	PROD0R2
	PROD0R3
	PROD1R0
	PROD1R1
	PROD1R2
	SUM0R0
	SUM0R1
	SUM0R2
	SUM0R3
	SUM1R0
	SUM1R1
)

type Slot struct {
	NT      symbols.NT
	Alt     int
	Pos     int
	Symbols symbols.Symbols
	Label 	Label
}

type Index struct {
	NT      symbols.NT
	Alt     int
	Pos     int
}

func GetAlternates(nt symbols.NT) []Label {
	alts, exist := alternates[nt]
	if !exist {
		panic(fmt.Sprintf("Invalid NT %s", nt))
	}
	return alts
}

func GetLabel(nt symbols.NT, alt, pos int) Label {
	l, exist := slotIndex[Index{nt,alt,pos}]
	if exist {
		return l
	}
	panic(fmt.Sprintf("Error: no slot label for NT=%s, alt=%d, pos=%d", nt, alt, pos))
}

func (l Label) EoR() bool {
	return l.Slot().EoR()
}

func (l Label) Head() symbols.NT {
	return l.Slot().NT
}

func (l Label) Index() Index {
	s := l.Slot()
	return Index{s.NT, s.Alt, s.Pos}
}

func (l Label) Alternate() int {
	return l.Slot().Alt
}

func (l Label) Pos() int {
	return l.Slot().Pos
}

func (l Label) Slot() *Slot {
	s, exist := slots[l]
	if !exist {
		panic(fmt.Sprintf("Invalid slot label %d", l))
	}
	return s
}

func (l Label) String() string {
	return l.Slot().String()
}

func (l Label) Symbols() symbols.Symbols {
	return l.Slot().Symbols
}

func (s *Slot) EoR() bool {
	return s.Pos >= len(s.Symbols)
}

func (s *Slot) String() string {
	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, "%s : ", s.NT)
	for i, sym := range s.Symbols {
		if i == s.Pos {
			fmt.Fprintf(buf, "∙")
		}
		fmt.Fprintf(buf, "%s ", sym)
	}
	if s.Pos >= len(s.Symbols) {
		fmt.Fprintf(buf, "∙")
	}
	return buf.String()
}

var slots = map[Label]*Slot{ 
	ELEM0R0: {
		symbols.NT_ELEM, 0, 0, 
		symbols.Symbols{  
			symbols.T_4, 
			symbols.NT_SUM, 
			symbols.T_0,
		}, 
		ELEM0R0, 
	},
	ELEM0R1: {
		symbols.NT_ELEM, 0, 1, 
		symbols.Symbols{  
			symbols.T_4, 
			symbols.NT_SUM, 
			symbols.T_0,
		}, 
		ELEM0R1, 
	},
	ELEM0R2: {
		symbols.NT_ELEM, 0, 2, 
		symbols.Symbols{  
			symbols.T_4, 
			symbols.NT_SUM, 
			symbols.T_0,
		}, 
		ELEM0R2, 
	},
	ELEM0R3: {
		symbols.NT_ELEM, 0, 3, 
		symbols.Symbols{  
			symbols.T_4, 
			symbols.NT_SUM, 
			symbols.T_0,
		}, 
		ELEM0R3, 
	},
	ELEM1R0: {
		symbols.NT_ELEM, 1, 0, 
		symbols.Symbols{  
			symbols.T_3,
		}, 
		ELEM1R0, 
	},
	ELEM1R1: {
		symbols.NT_ELEM, 1, 1, 
		symbols.Symbols{  
			symbols.T_3,
		}, 
		ELEM1R1, 
	},
	EXPR0R0: {
		symbols.NT_EXPR, 0, 0, 
		symbols.Symbols{  
			symbols.NT_SUM,
		}, 
		EXPR0R0, 
	},
	EXPR0R1: {
		symbols.NT_EXPR, 0, 1, 
		symbols.Symbols{  
			symbols.NT_SUM,
		}, 
		EXPR0R1, 
	},
	PROD0R0: {
		symbols.NT_PROD, 0, 0, 
		symbols.Symbols{  
			symbols.NT_ELEM, 
			symbols.T_6, 
			symbols.NT_ELEM,
		}, 
		PROD0R0, 
	},
	PROD0R1: {
		symbols.NT_PROD, 0, 1, 
		symbols.Symbols{  
			symbols.NT_ELEM, 
			symbols.T_6, 
			symbols.NT_ELEM,
		}, 
		PROD0R1, 
	},
	PROD0R2: {
		symbols.NT_PROD, 0, 2, 
		symbols.Symbols{  
			symbols.NT_ELEM, 
			symbols.T_6, 
			symbols.NT_ELEM,
		}, 
		PROD0R2, 
	},
	PROD0R3: {
		symbols.NT_PROD, 0, 3, 
		symbols.Symbols{  
			symbols.NT_ELEM, 
			symbols.T_6, 
			symbols.NT_ELEM,
		}, 
		PROD0R3, 
	},
	PROD1R0: {
		symbols.NT_PROD, 1, 0, 
		symbols.Symbols{  
			symbols.T_1, 
			symbols.NT_ELEM,
		}, 
		PROD1R0, 
	},
	PROD1R1: {
		symbols.NT_PROD, 1, 1, 
		symbols.Symbols{  
			symbols.T_1, 
			symbols.NT_ELEM,
		}, 
		PROD1R1, 
	},
	PROD1R2: {
		symbols.NT_PROD, 1, 2, 
		symbols.Symbols{  
			symbols.T_1, 
			symbols.NT_ELEM,
		}, 
		PROD1R2, 
	},
	SUM0R0: {
		symbols.NT_SUM, 0, 0, 
		symbols.Symbols{  
			symbols.NT_PROD, 
			symbols.T_5, 
			symbols.NT_PROD,
		}, 
		SUM0R0, 
	},
	SUM0R1: {
		symbols.NT_SUM, 0, 1, 
		symbols.Symbols{  
			symbols.NT_PROD, 
			symbols.T_5, 
			symbols.NT_PROD,
		}, 
		SUM0R1, 
	},
	SUM0R2: {
		symbols.NT_SUM, 0, 2, 
		symbols.Symbols{  
			symbols.NT_PROD, 
			symbols.T_5, 
			symbols.NT_PROD,
		}, 
		SUM0R2, 
	},
	SUM0R3: {
		symbols.NT_SUM, 0, 3, 
		symbols.Symbols{  
			symbols.NT_PROD, 
			symbols.T_5, 
			symbols.NT_PROD,
		}, 
		SUM0R3, 
	},
	SUM1R0: {
		symbols.NT_SUM, 1, 0, 
		symbols.Symbols{  
			symbols.T_2,
		}, 
		SUM1R0, 
	},
	SUM1R1: {
		symbols.NT_SUM, 1, 1, 
		symbols.Symbols{  
			symbols.T_2,
		}, 
		SUM1R1, 
	},
}

var slotIndex = map[Index]Label { 
	Index{ symbols.NT_ELEM,0,0 }: ELEM0R0,
	Index{ symbols.NT_ELEM,0,1 }: ELEM0R1,
	Index{ symbols.NT_ELEM,0,2 }: ELEM0R2,
	Index{ symbols.NT_ELEM,0,3 }: ELEM0R3,
	Index{ symbols.NT_ELEM,1,0 }: ELEM1R0,
	Index{ symbols.NT_ELEM,1,1 }: ELEM1R1,
	Index{ symbols.NT_EXPR,0,0 }: EXPR0R0,
	Index{ symbols.NT_EXPR,0,1 }: EXPR0R1,
	Index{ symbols.NT_PROD,0,0 }: PROD0R0,
	Index{ symbols.NT_PROD,0,1 }: PROD0R1,
	Index{ symbols.NT_PROD,0,2 }: PROD0R2,
	Index{ symbols.NT_PROD,0,3 }: PROD0R3,
	Index{ symbols.NT_PROD,1,0 }: PROD1R0,
	Index{ symbols.NT_PROD,1,1 }: PROD1R1,
	Index{ symbols.NT_PROD,1,2 }: PROD1R2,
	Index{ symbols.NT_SUM,0,0 }: SUM0R0,
	Index{ symbols.NT_SUM,0,1 }: SUM0R1,
	Index{ symbols.NT_SUM,0,2 }: SUM0R2,
	Index{ symbols.NT_SUM,0,3 }: SUM0R3,
	Index{ symbols.NT_SUM,1,0 }: SUM1R0,
	Index{ symbols.NT_SUM,1,1 }: SUM1R1,
}

var alternates = map[symbols.NT][]Label{ 
	symbols.NT_EXPR:[]Label{ EXPR0R0 },
	symbols.NT_SUM:[]Label{ SUM0R0,SUM1R0 },
	symbols.NT_PROD:[]Label{ PROD0R0,PROD1R0 },
	symbols.NT_ELEM:[]Label{ ELEM0R0,ELEM1R0 },
}


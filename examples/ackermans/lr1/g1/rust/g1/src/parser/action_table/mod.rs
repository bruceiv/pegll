//! Generated by GoGLL. Do not edit.

use crate::token;

use std::collections::HashMap;
use lazy_static::lazy_static;

use super::productions_table::PROD_TABLE;

#[derive(PartialEq, Eq)]
pub enum Action {
	Accept,
	Shift(usize),
	Reduce(usize),
}

impl std::fmt::Display for Action {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Action::Accept => write!(f, "Accept(0)"),
			Action::Reduce(s) => write!(f, "Reduce({}) {}", s, PROD_TABLE[*s].string),
			Action::Shift(s) => write!(f, "Shift({})", s),
		}
    }
}

#[derive(std::default::Default)]
pub struct ActionRow {
	pub can_recover: bool,
	pub actions: HashMap<token::Type,  Action>,
}

lazy_static! {
	pub static ref ACTION_TABLE: Vec<ActionRow> = {
		let mut v: Vec<ActionRow> = Vec::with_capacity(6);
        v.resize_with(6, Default::default);
		
		v[0].can_recover = false;
		v[0].actions.insert(token::Type::T_1, Action::Shift(3),		/* a */); 
		v[1].can_recover = false;
		v[1].actions.insert(token::Type::EOF, Action::Accept,		/* $ */); 
		v[1].actions.insert(token::Type::T_0, Action::Shift(4),		/* + */); 
		v[2].can_recover = false;
		v[2].actions.insert(token::Type::EOF, Action::Reduce(2),		/* $, Reduce: E1 */); 
		v[2].actions.insert(token::Type::T_0, Action::Reduce(2),		/* +, Reduce: E1 */); 
		v[3].can_recover = false;
		v[3].actions.insert(token::Type::EOF, Action::Reduce(3),		/* $, Reduce: T1 */); 
		v[3].actions.insert(token::Type::T_0, Action::Reduce(3),		/* +, Reduce: T1 */); 
		v[4].can_recover = false;
		v[4].actions.insert(token::Type::T_1, Action::Shift(3),		/* a */); 
		v[5].can_recover = false;
		v[5].actions.insert(token::Type::EOF, Action::Reduce(1),		/* $, Reduce: E1 */); 
		v[5].actions.insert(token::Type::T_0, Action::Reduce(1),		/* +, Reduce: E1 */); 

		v
	};
}

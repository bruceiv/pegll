//! Module slot is generated by gogll. Do not edit. 

extern crate lazy_static;

use lazy_static::lazy_static;

use super::symbols::{Symbol, NT, T};
use std::collections::HashMap;
use std::fmt;

#[derive(Hash, Eq, PartialEq, Clone, Copy, Debug)]
pub enum Label { 
    A10R0,
    A10R1,
    A10R2,
    Name0R0,
    Name0R1,
    Name1R0,
}

#[allow(dead_code)]
pub struct Slot {
    nt:      NT,
    alt:     usize,
    pos:     usize,
    symbols: Vec<Symbol>,
    label: 	 Label,
}

#[derive(Hash, Eq, PartialEq)]
pub struct Index {
    pub nt:      NT,
    pub alt:     usize,
    pub pos:     usize,
}

#[allow(dead_code)]
pub fn get_alternates(nt: &NT) -> &'static Vec<Label> {
    if let Some(alts) = ALTERNATES.get(nt) {
        return alts
    }
    panic!("{} has no alternates", nt)
}

#[allow(dead_code)]
pub fn get_label(nt: &NT, alt: usize, pos: usize) -> Label {
    if let Some(l) = LABELS.get(&Index{nt: nt.clone(), alt: alt, pos: pos}) {
        return l.clone()
    }
    panic!("No label for {} alt {} pos {}", nt, alt, pos)
}

impl <'a>Label {
    #[allow(dead_code)]
    pub fn eor(&self) -> bool {
        self.slot().eor()
    }
    
    #[allow(dead_code)]
    pub fn head(&self) -> &'static NT {
        &self.slot().nt
    }
    
    pub fn index(&self) -> Index {
        let s = self.slot();
        Index{nt: s.nt, alt: s.alt, pos: s.pos}
    }
    
    #[allow(dead_code)]
    pub fn alternate(&self) -> usize {
        self.slot().alt
    }
    
    #[allow(dead_code)]
    pub fn pos(&self) -> usize {
        self.slot().pos
    }
    
    #[allow(dead_code)]
    pub fn slot(&self) -> &'static Slot {
        if let Some(s) = SLOTS.get(self) {
            return s
        }
        panic!("Invalid slot label {}", self)
    }

    #[allow(dead_code)]
    pub fn symbols(&self) -> &'a Vec<Symbol> {
        &self.slot().symbols
    }
}
/*** end of impl Label***/

impl fmt::Display for Label {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let slt = self.slot();
        let mut s = format!("{} :", slt.nt);
        for (i, sym) in slt.symbols.iter().enumerate() {
            if i == slt.pos {
                s.push_str("•")
            }
            s.push_str(&format!("{} ", sym));
        }
        write!(f, "{}", s)
    }
}

impl Slot {
    #[allow(dead_code)]
    pub fn eor(&self) -> bool {
        self.pos >= self.symbols.len()
    }    
} /*** impl Slot ***/


impl fmt::Display for Slot {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut s = format!("{} : ", self.nt);
        for (i, sym) in self.symbols.iter().enumerate() {
            if i == self.pos {
                s.push_str("•")
            }
            s.push_str(&format!("{} ", sym));
        }
        if self.pos >= self.symbols.len() {
            s.push_str("•")
        }
        write!(f, "{}", s)
    }
}

lazy_static! {
    static ref ALTERNATES: HashMap<NT, Vec<Label>> = {
        let mut m = HashMap::new(); 
        m.insert(NT::A1, 
            vec![ 
                Label::A10R0,
            ]);
        m.insert(NT::Name, 
            vec![ 
                Label::Name0R0,
                Label::Name1R0,
            ]);
        m
     };

    static ref LABELS: HashMap<Index, Label> = { 
        let mut m = HashMap::new(); 
        m.insert(Index{nt:NT::A1, alt:0, pos:0}, Label::A10R0); 
        m.insert(Index{nt:NT::A1, alt:0, pos:1}, Label::A10R1); 
        m.insert(Index{nt:NT::A1, alt:0, pos:2}, Label::A10R2); 
        m.insert(Index{nt:NT::Name, alt:0, pos:0}, Label::Name0R0); 
        m.insert(Index{nt:NT::Name, alt:0, pos:1}, Label::Name0R1); 
        m.insert(Index{nt:NT::Name, alt:1, pos:0}, Label::Name1R0); 
        m
    };

    static ref SLOTS: HashMap<Label, Slot> = {
        let mut m = HashMap::new(); 
        // A1 : ∙Name int 
        m.insert(Label::A10R0, 
            Slot{
                nt: NT::A1,
                alt: 0,
                pos: 0,
                symbols: vec![ 
                    Symbol::NT(NT::Name), 
                    Symbol::T(T::T0), 
                ],
                label: Label::A10R0,
            });
        // A1 : Name ∙int 
        m.insert(Label::A10R1, 
            Slot{
                nt: NT::A1,
                alt: 0,
                pos: 1,
                symbols: vec![ 
                    Symbol::NT(NT::Name), 
                    Symbol::T(T::T0), 
                ],
                label: Label::A10R1,
            });
        // A1 : Name int ∙
        m.insert(Label::A10R2, 
            Slot{
                nt: NT::A1,
                alt: 0,
                pos: 2,
                symbols: vec![ 
                    Symbol::NT(NT::Name), 
                    Symbol::T(T::T0), 
                ],
                label: Label::A10R2,
            });
        // Name : ∙name 
        m.insert(Label::Name0R0, 
            Slot{
                nt: NT::Name,
                alt: 0,
                pos: 0,
                symbols: vec![ 
                    Symbol::T(T::T1), 
                ],
                label: Label::Name0R0,
            });
        // Name : name ∙
        m.insert(Label::Name0R1, 
            Slot{
                nt: NT::Name,
                alt: 0,
                pos: 1,
                symbols: vec![ 
                    Symbol::T(T::T1), 
                ],
                label: Label::Name0R1,
            });
        // Name : ∙
        m.insert(Label::Name1R0, 
            Slot{
                nt: NT::Name,
                alt: 1,
                pos: 0,
                symbols: vec![ 
                ],
                label: Label::Name1R0,
            });
        m
	};
}

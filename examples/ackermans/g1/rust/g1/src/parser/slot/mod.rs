//! Module slot is generated by gogll. Do not edit. 

extern crate lazy_static;

use lazy_static::lazy_static;

use super::symbols::{Symbol, NT, T};
use std::collections::HashMap;
use std::fmt;

#[derive(Hash, Eq, PartialEq, Clone, Copy, Debug)]
pub enum Label { 
    Exp0R0,
    Exp0R1,
    Exp0R2,
    Exp0R3,
    Exp1R0,
    Exp1R1,
    Op0R0,
    Op0R1,
    Op1R0,
    Op1R1,
}

#[allow(dead_code)]
pub struct Slot {
    nt:      NT,
    alt:     usize,
    pos:     usize,
    symbols: Vec<Symbol>,
    label: 	 Label,
}

#[derive(Hash, Eq, PartialEq)]
pub struct Index {
    pub nt:      NT,
    pub alt:     usize,
    pub pos:     usize,
}

#[allow(dead_code)]
pub fn get_alternates(nt: &NT) -> &'static Vec<Label> {
    if let Some(alts) = ALTERNATES.get(nt) {
        return alts
    }
    panic!("{} has no alternates", nt)
}

#[allow(dead_code)]
pub fn get_label(nt: &NT, alt: usize, pos: usize) -> Label {
    if let Some(l) = LABELS.get(&Index{nt: nt.clone(), alt: alt, pos: pos}) {
        return l.clone()
    }
    panic!("No label for {} alt {} pos {}", nt, alt, pos)
}

impl <'a>Label {
    #[allow(dead_code)]
    pub fn eor(&self) -> bool {
        self.slot().eor()
    }
    
    #[allow(dead_code)]
    pub fn head(&self) -> &'static NT {
        &self.slot().nt
    }
    
    pub fn index(&self) -> Index {
        let s = self.slot();
        Index{nt: s.nt, alt: s.alt, pos: s.pos}
    }
    
    #[allow(dead_code)]
    pub fn alternate(&self) -> usize {
        self.slot().alt
    }
    
    #[allow(dead_code)]
    pub fn pos(&self) -> usize {
        self.slot().pos
    }
    
    #[allow(dead_code)]
    pub fn slot(&self) -> &'static Slot {
        if let Some(s) = SLOTS.get(self) {
            return s
        }
        panic!("Invalid slot label {}", self)
    }

    #[allow(dead_code)]
    pub fn symbols(&self) -> &'a Vec<Symbol> {
        &self.slot().symbols
    }
}
/*** end of impl Label***/

impl fmt::Display for Label {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let slt = self.slot();
        let mut s = format!("{} :", slt.nt);
        for (i, sym) in slt.symbols.iter().enumerate() {
            if i == slt.pos {
                s.push_str("•")
            }
            s.push_str(&format!("{} ", sym));
        }
        write!(f, "{}", s)
    }
}

impl Slot {
    #[allow(dead_code)]
    pub fn eor(&self) -> bool {
        self.pos >= self.symbols.len()
    }    
} /*** impl Slot ***/


impl fmt::Display for Slot {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut s = format!("{} : ", self.nt);
        for (i, sym) in self.symbols.iter().enumerate() {
            if i == self.pos {
                s.push_str("•")
            }
            s.push_str(&format!("{} ", sym));
        }
        if self.pos >= self.symbols.len() {
            s.push_str("•")
        }
        write!(f, "{}", s)
    }
}

lazy_static! {
    static ref ALTERNATES: HashMap<NT, Vec<Label>> = {
        let mut m = HashMap::new(); 
        m.insert(NT::Exp, 
            vec![ 
                Label::Exp0R0,
                Label::Exp1R0,
            ]);
        m.insert(NT::Op, 
            vec![ 
                Label::Op0R0,
                Label::Op1R0,
            ]);
        m
     };

    static ref LABELS: HashMap<Index, Label> = { 
        let mut m = HashMap::new(); 
        m.insert(Index{nt:NT::Exp, alt:0, pos:0}, Label::Exp0R0); 
        m.insert(Index{nt:NT::Exp, alt:0, pos:1}, Label::Exp0R1); 
        m.insert(Index{nt:NT::Exp, alt:0, pos:2}, Label::Exp0R2); 
        m.insert(Index{nt:NT::Exp, alt:0, pos:3}, Label::Exp0R3); 
        m.insert(Index{nt:NT::Exp, alt:1, pos:0}, Label::Exp1R0); 
        m.insert(Index{nt:NT::Exp, alt:1, pos:1}, Label::Exp1R1); 
        m.insert(Index{nt:NT::Op, alt:0, pos:0}, Label::Op0R0); 
        m.insert(Index{nt:NT::Op, alt:0, pos:1}, Label::Op0R1); 
        m.insert(Index{nt:NT::Op, alt:1, pos:0}, Label::Op1R0); 
        m.insert(Index{nt:NT::Op, alt:1, pos:1}, Label::Op1R1); 
        m
    };

    static ref SLOTS: HashMap<Label, Slot> = {
        let mut m = HashMap::new(); 
        // Exp : ∙Exp Op Exp 
        m.insert(Label::Exp0R0, 
            Slot{
                nt: NT::Exp,
                alt: 0,
                pos: 0,
                symbols: vec![ 
                    Symbol::NT(NT::Exp), 
                    Symbol::NT(NT::Op), 
                    Symbol::NT(NT::Exp), 
                ],
                label: Label::Exp0R0,
            });
        // Exp : Exp ∙Op Exp 
        m.insert(Label::Exp0R1, 
            Slot{
                nt: NT::Exp,
                alt: 0,
                pos: 1,
                symbols: vec![ 
                    Symbol::NT(NT::Exp), 
                    Symbol::NT(NT::Op), 
                    Symbol::NT(NT::Exp), 
                ],
                label: Label::Exp0R1,
            });
        // Exp : Exp Op ∙Exp 
        m.insert(Label::Exp0R2, 
            Slot{
                nt: NT::Exp,
                alt: 0,
                pos: 2,
                symbols: vec![ 
                    Symbol::NT(NT::Exp), 
                    Symbol::NT(NT::Op), 
                    Symbol::NT(NT::Exp), 
                ],
                label: Label::Exp0R2,
            });
        // Exp : Exp Op Exp ∙
        m.insert(Label::Exp0R3, 
            Slot{
                nt: NT::Exp,
                alt: 0,
                pos: 3,
                symbols: vec![ 
                    Symbol::NT(NT::Exp), 
                    Symbol::NT(NT::Op), 
                    Symbol::NT(NT::Exp), 
                ],
                label: Label::Exp0R3,
            });
        // Exp : ∙id 
        m.insert(Label::Exp1R0, 
            Slot{
                nt: NT::Exp,
                alt: 1,
                pos: 0,
                symbols: vec![ 
                    Symbol::T(T::T1), 
                ],
                label: Label::Exp1R0,
            });
        // Exp : id ∙
        m.insert(Label::Exp1R1, 
            Slot{
                nt: NT::Exp,
                alt: 1,
                pos: 1,
                symbols: vec![ 
                    Symbol::T(T::T1), 
                ],
                label: Label::Exp1R1,
            });
        // Op : ∙& 
        m.insert(Label::Op0R0, 
            Slot{
                nt: NT::Op,
                alt: 0,
                pos: 0,
                symbols: vec![ 
                    Symbol::T(T::T0), 
                ],
                label: Label::Op0R0,
            });
        // Op : & ∙
        m.insert(Label::Op0R1, 
            Slot{
                nt: NT::Op,
                alt: 0,
                pos: 1,
                symbols: vec![ 
                    Symbol::T(T::T0), 
                ],
                label: Label::Op0R1,
            });
        // Op : ∙| 
        m.insert(Label::Op1R0, 
            Slot{
                nt: NT::Op,
                alt: 1,
                pos: 0,
                symbols: vec![ 
                    Symbol::T(T::T2), 
                ],
                label: Label::Op1R0,
            });
        // Op : | ∙
        m.insert(Label::Op1R1, 
            Slot{
                nt: NT::Op,
                alt: 1,
                pos: 1,
                symbols: vec![ 
                    Symbol::T(T::T2), 
                ],
                label: Label::Op1R1,
            });
        m
	};
}

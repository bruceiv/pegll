// Module symbols is generated by gogll. Do not edit.

use std::fmt;

#[allow(dead_code)]
#[derive(Hash, Eq, PartialEq)]
pub enum Symbol {
    NT(NT),
    T(T)
}

// NT is the type of non-terminals symbols
#[allow(dead_code)]
#[derive(Hash, Eq, PartialEq, Clone, Copy, Debug)]
pub enum NT { 
    Exp,
    Op,
}

// T is the type of terminals symbols
#[allow(dead_code)]
#[derive(Hash, Eq, PartialEq)]
pub enum T { 
    T0, // & 
    T1, // id 
    T2, // | 	
}

/// Format a &Vec<Symbol> into a String
#[allow(dead_code)]
pub fn to_string(symbols: &Vec<Symbol>) -> String {
    let mut st: String = "".to_string();
    for sym in symbols.iter() {
        st.push_str(&format!("{} ",sym));
    }
    st
}

impl Symbol {
    #[allow(dead_code)]
    pub fn is_nt(&self) -> bool {
        match self {
            Symbol::NT(_) => return true,
            Symbol::T(_) => return false,
        }
    }
}

impl fmt::Display for NT {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {  
            NT::Exp => write!(f, "Exp"), 
            NT::Op => write!(f, "Op"),
        }
    }
}

impl fmt::Display for T {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {  
            T::T0 => write!(f, "&"), 
            T::T1 => write!(f, "id"), 
            T::T2 => write!(f, "|"),
        }
    }
}

impl fmt::Display for Symbol {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self { 
            Symbol::NT(nt) => write!(f, "{}", nt),
            Symbol::T(t) => write!(f, "{}", t)
        }
    }
}


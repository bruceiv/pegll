
// Package slot is generated by gogll. Do not edit. 
package slot

import(
	"bytes"
	"fmt"
	
	"anbncn/parser/symbols"
	"anbncn/token"
)

type Label int

const(
	A10R0 Label = iota
	A10R1
	A10R2
	A10R3
	A11R0
	A11R1
	A11R2
	Ac0R0
	Ac0R1
	Ac0R2
	B10R0
	B10R1
	B10R2
	B10R3
	B11R0
	B11R1
	B11R2
	G10R0
	G10R1
	G10R2
	G10R3
	G10R4
	Repa0x0R0
	Repa0x0R1
	Repa0x0R2
	Repa0x1R0
)

type Slot struct {
	NT      symbols.NT
	Alt     int
	Pos     int
	Symbols symbols.Symbols
	Label 	Label
}

type Index struct {
	NT      symbols.NT
	Alt     int
	Pos     int
}

func GetAlternates(nt symbols.NT) []Label {
	alts, exist := alternates[nt]
	if !exist {
		panic(fmt.Sprintf("Invalid NT %s", nt))
	}
	return alts
}

func GetLabel(nt symbols.NT, alt, pos int) Label {
	l, exist := slotIndex[Index{nt,alt,pos}]
	if exist {
		return l
	}
	panic(fmt.Sprintf("Error: no slot label for NT=%s, alt=%d, pos=%d", nt, alt, pos))
}

func (l Label) EoR() bool {
	return l.Slot().EoR()
}

func (l Label) Head() symbols.NT {
	return l.Slot().NT
}

func (l Label) Index() Index {
	s := l.Slot()
	return Index{s.NT, s.Alt, s.Pos}
}

func (l Label) Alternate() int {
	return l.Slot().Alt
}

func (l Label) Pos() int {
	return l.Slot().Pos
}

func (l Label) Slot() *Slot {
	s, exist := slots[l]
	if !exist {
		panic(fmt.Sprintf("Invalid slot label %d", l))
	}
	return s
}

func (l Label) String() string {
	return l.Slot().String()
}

func (l Label) Symbols() symbols.Symbols {
	return l.Slot().Symbols
}

func (l Label) IsNullable() bool {
	return nullable[l]
}

func (l Label) FirstContains(typ token.Type) bool {
	return firstT[l][typ]
}

func (s *Slot) EoR() bool {
	return s.Pos >= len(s.Symbols)
}

func (s *Slot) Successor() *Slot {
	if s.EoR() {
		return nil
	} else {
		// TODO try slots[s.Label + 1]
		return slots[slotIndex[Index{s.NT,s.Alt,s.Pos+1}]]
	}
}

func (s *Slot) String() string {
	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, "%s : ", s.NT)
	for i, sym := range s.Symbols {
		if i == s.Pos {
			fmt.Fprintf(buf, "∙")
		}
		fmt.Fprintf(buf, "%s ", sym)
	}
	if s.Pos >= len(s.Symbols) {
		fmt.Fprintf(buf, "∙")
	}
	return buf.String()
}

var slots = map[Label]*Slot{ 
	A10R0: {
		symbols.NT_A1, 0, 0, 
		symbols.Symbols{  
			symbols.T_0, 
			symbols.NT_A1, 
			symbols.T_1,
		}, 
		A10R0, 
	},
	A10R1: {
		symbols.NT_A1, 0, 1, 
		symbols.Symbols{  
			symbols.T_0, 
			symbols.NT_A1, 
			symbols.T_1,
		}, 
		A10R1, 
	},
	A10R2: {
		symbols.NT_A1, 0, 2, 
		symbols.Symbols{  
			symbols.T_0, 
			symbols.NT_A1, 
			symbols.T_1,
		}, 
		A10R2, 
	},
	A10R3: {
		symbols.NT_A1, 0, 3, 
		symbols.Symbols{  
			symbols.T_0, 
			symbols.NT_A1, 
			symbols.T_1,
		}, 
		A10R3, 
	},
	A11R0: {
		symbols.NT_A1, 1, 0, 
		symbols.Symbols{  
			symbols.T_0, 
			symbols.T_1,
		}, 
		A11R0, 
	},
	A11R1: {
		symbols.NT_A1, 1, 1, 
		symbols.Symbols{  
			symbols.T_0, 
			symbols.T_1,
		}, 
		A11R1, 
	},
	A11R2: {
		symbols.NT_A1, 1, 2, 
		symbols.Symbols{  
			symbols.T_0, 
			symbols.T_1,
		}, 
		A11R2, 
	},
	Ac0R0: {
		symbols.NT_Ac, 0, 0, 
		symbols.Symbols{  
			symbols.NT_A1, 
			symbols.T_2,
		}, 
		Ac0R0, 
	},
	Ac0R1: {
		symbols.NT_Ac, 0, 1, 
		symbols.Symbols{  
			symbols.NT_A1, 
			symbols.T_2,
		}, 
		Ac0R1, 
	},
	Ac0R2: {
		symbols.NT_Ac, 0, 2, 
		symbols.Symbols{  
			symbols.NT_A1, 
			symbols.T_2,
		}, 
		Ac0R2, 
	},
	B10R0: {
		symbols.NT_B1, 0, 0, 
		symbols.Symbols{  
			symbols.T_1, 
			symbols.NT_B1, 
			symbols.T_2,
		}, 
		B10R0, 
	},
	B10R1: {
		symbols.NT_B1, 0, 1, 
		symbols.Symbols{  
			symbols.T_1, 
			symbols.NT_B1, 
			symbols.T_2,
		}, 
		B10R1, 
	},
	B10R2: {
		symbols.NT_B1, 0, 2, 
		symbols.Symbols{  
			symbols.T_1, 
			symbols.NT_B1, 
			symbols.T_2,
		}, 
		B10R2, 
	},
	B10R3: {
		symbols.NT_B1, 0, 3, 
		symbols.Symbols{  
			symbols.T_1, 
			symbols.NT_B1, 
			symbols.T_2,
		}, 
		B10R3, 
	},
	B11R0: {
		symbols.NT_B1, 1, 0, 
		symbols.Symbols{  
			symbols.T_1, 
			symbols.T_2,
		}, 
		B11R0, 
	},
	B11R1: {
		symbols.NT_B1, 1, 1, 
		symbols.Symbols{  
			symbols.T_1, 
			symbols.T_2,
		}, 
		B11R1, 
	},
	B11R2: {
		symbols.NT_B1, 1, 2, 
		symbols.Symbols{  
			symbols.T_1, 
			symbols.T_2,
		}, 
		B11R2, 
	},
	G10R0: {
		symbols.NT_G1, 0, 0, 
		symbols.Symbols{  
			symbols.LP_NT_Ac, 
			symbols.T_0, 
			symbols.NT_Repa0x, 
			symbols.NT_B1,
		}, 
		G10R0, 
	},
	G10R1: {
		symbols.NT_G1, 0, 1, 
		symbols.Symbols{  
			symbols.LP_NT_Ac, 
			symbols.T_0, 
			symbols.NT_Repa0x, 
			symbols.NT_B1,
		}, 
		G10R1, 
	},
	G10R2: {
		symbols.NT_G1, 0, 2, 
		symbols.Symbols{  
			symbols.LP_NT_Ac, 
			symbols.T_0, 
			symbols.NT_Repa0x, 
			symbols.NT_B1,
		}, 
		G10R2, 
	},
	G10R3: {
		symbols.NT_G1, 0, 3, 
		symbols.Symbols{  
			symbols.LP_NT_Ac, 
			symbols.T_0, 
			symbols.NT_Repa0x, 
			symbols.NT_B1,
		}, 
		G10R3, 
	},
	G10R4: {
		symbols.NT_G1, 0, 4, 
		symbols.Symbols{  
			symbols.LP_NT_Ac, 
			symbols.T_0, 
			symbols.NT_Repa0x, 
			symbols.NT_B1,
		}, 
		G10R4, 
	},
	Repa0x0R0: {
		symbols.NT_Repa0x, 0, 0, 
		symbols.Symbols{  
			symbols.T_0, 
			symbols.NT_Repa0x,
		}, 
		Repa0x0R0, 
	},
	Repa0x0R1: {
		symbols.NT_Repa0x, 0, 1, 
		symbols.Symbols{  
			symbols.T_0, 
			symbols.NT_Repa0x,
		}, 
		Repa0x0R1, 
	},
	Repa0x0R2: {
		symbols.NT_Repa0x, 0, 2, 
		symbols.Symbols{  
			symbols.T_0, 
			symbols.NT_Repa0x,
		}, 
		Repa0x0R2, 
	},
	Repa0x1R0: {
		symbols.NT_Repa0x, 1, 0, 
		symbols.Symbols{ 
		}, 
		Repa0x1R0, 
	},
}

var slotIndex = map[Index]Label { 
	Index{ symbols.NT_A1,0,0 }: A10R0,
	Index{ symbols.NT_A1,0,1 }: A10R1,
	Index{ symbols.NT_A1,0,2 }: A10R2,
	Index{ symbols.NT_A1,0,3 }: A10R3,
	Index{ symbols.NT_A1,1,0 }: A11R0,
	Index{ symbols.NT_A1,1,1 }: A11R1,
	Index{ symbols.NT_A1,1,2 }: A11R2,
	Index{ symbols.NT_Ac,0,0 }: Ac0R0,
	Index{ symbols.NT_Ac,0,1 }: Ac0R1,
	Index{ symbols.NT_Ac,0,2 }: Ac0R2,
	Index{ symbols.NT_B1,0,0 }: B10R0,
	Index{ symbols.NT_B1,0,1 }: B10R1,
	Index{ symbols.NT_B1,0,2 }: B10R2,
	Index{ symbols.NT_B1,0,3 }: B10R3,
	Index{ symbols.NT_B1,1,0 }: B11R0,
	Index{ symbols.NT_B1,1,1 }: B11R1,
	Index{ symbols.NT_B1,1,2 }: B11R2,
	Index{ symbols.NT_G1,0,0 }: G10R0,
	Index{ symbols.NT_G1,0,1 }: G10R1,
	Index{ symbols.NT_G1,0,2 }: G10R2,
	Index{ symbols.NT_G1,0,3 }: G10R3,
	Index{ symbols.NT_G1,0,4 }: G10R4,
	Index{ symbols.NT_Repa0x,0,0 }: Repa0x0R0,
	Index{ symbols.NT_Repa0x,0,1 }: Repa0x0R1,
	Index{ symbols.NT_Repa0x,0,2 }: Repa0x0R2,
	Index{ symbols.NT_Repa0x,1,0 }: Repa0x1R0,
}

var alternates = map[symbols.NT][]Label{ 
	symbols.NT_G1:[]Label{ G10R0 },
	symbols.NT_A1:[]Label{ A10R0,A11R0 },
	symbols.NT_B1:[]Label{ B10R0,B11R0 },
	symbols.NT_Ac:[]Label{ Ac0R0 },
	symbols.NT_Repa0x:[]Label{ Repa0x0R0,Repa0x1R0 },
}

var nullable = []bool { 
	false, // A10R0 
	false, // A10R1 
	false, // A10R2 
	true, // A10R3 
	false, // A11R0 
	false, // A11R1 
	true, // A11R2 
	false, // Ac0R0 
	false, // Ac0R1 
	true, // Ac0R2 
	false, // B10R0 
	false, // B10R1 
	false, // B10R2 
	true, // B10R3 
	false, // B11R0 
	false, // B11R1 
	true, // B11R2 
	false, // G10R0 
	false, // G10R1 
	false, // G10R2 
	false, // G10R3 
	true, // G10R4 
	false, // Repa0x0R0 
	true, // Repa0x0R1 
	true, // Repa0x0R2 
	true, // Repa0x1R0 
}

var firstT = []map[token.Type]bool { 
	{  token.T_0: true,  }, // A10R0 
	{  token.T_0: true,  }, // A10R1 
	{  token.T_1: true,  }, // A10R2 
	{  }, // A10R3 
	{  token.T_0: true,  }, // A11R0 
	{  token.T_1: true,  }, // A11R1 
	{  }, // A11R2 
	{  token.T_0: true,  }, // Ac0R0 
	{  token.T_2: true,  }, // Ac0R1 
	{  }, // Ac0R2 
	{  token.T_1: true,  }, // B10R0 
	{  token.T_1: true,  }, // B10R1 
	{  token.T_2: true,  }, // B10R2 
	{  }, // B10R3 
	{  token.T_1: true,  }, // B11R0 
	{  token.T_2: true,  }, // B11R1 
	{  }, // B11R2 
	{  token.T_0: true,  }, // G10R0 
	{  token.T_0: true,  }, // G10R1 
	{  token.T_1: true,  token.T_0: true,  }, // G10R2 
	{  token.T_1: true,  }, // G10R3 
	{  }, // G10R4 
	{  token.T_0: true,  }, // Repa0x0R0 
	{  token.T_0: true,  }, // Repa0x0R1 
	{  }, // Repa0x0R2 
	{  }, // Repa0x1R0 
}
